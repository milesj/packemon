// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Feature flags > compiles > lib/helpers.js 1`] = `
"'use strict';

var _newArrowCheck = require("@babel/runtime/helpers/newArrowCheck");
var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");
var _createClass = require("@babel/runtime/helpers/createClass");
var _defineProperty = require("@babel/runtime/helpers/defineProperty");
var Example = /*#__PURE__*/function () {
  function Example() {
    var _this = this;
    _classCallCheck(this, Example);
    _defineProperty(this, "property", 123);
    _defineProperty(this, "method", function () {
      _newArrowCheck(this, _this);
      return [].concat();
    }.bind(this));
  }
  return _createClass(Example, [{
    key: "log",
    value: function log() {}
  }, {
    key: "foo",
    get: function get() {
      return '';
    },
    set: function set(value) {}
  }]);
}();
exports.Example = Example;
//# sourceMappingURL=helpers.js.map
"
`;

exports[`Feature flags > compiles > lib/helpers.js 2`] = `
"'use strict';

var Example = /*#__PURE__*/function () {
  function Example() {
    var _this = this;
    babelHelpers.classCallCheck(this, Example);
    babelHelpers.defineProperty(this, "property", 123);
    babelHelpers.defineProperty(this, "method", function () {
      babelHelpers.newArrowCheck(this, _this);
      return [].concat();
    }.bind(this));
  }
  return babelHelpers.createClass(Example, [{
    key: "log",
    value: function log() {}
  }, {
    key: "foo",
    get: function get() {
      return '';
    },
    set: function set(value) {}
  }]);
}();
exports.Example = Example;
//# sourceMappingURL=helpers.js.map
"
`;

exports[`Feature flags > compiles > lib/helpers.js 3`] = `
""use strict";
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var Example = /*#__PURE__*/ function() {
    function Example() {
        _class_call_check(this, Example);
        _define_property(this, "property", 123);
        _define_property(this, "method", function() {
            return _to_consumable_array([]);
        });
    }
    _create_class(Example, [
        {
            key: "log",
            value: function log() {}
        },
        {
            key: "foo",
            get: function get() {
                return "";
            },
            set: function set(value) {}
        }
    ]);
    return Example;
}();
exports.Example = Example;
//# sourceMappingURL=helpers.js.map
"
`;

exports[`Feature flags > compiles > lib/helpers.js 4`] = `
""use strict";
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var Example = /*#__PURE__*/ function() {
    function Example() {
        _class_call_check(this, Example);
        _define_property(this, "property", 123);
        _define_property(this, "method", function() {
            return _to_consumable_array([]);
        });
    }
    _create_class(Example, [
        {
            key: "log",
            value: function log() {}
        },
        {
            key: "foo",
            get: function get() {
                return "";
            },
            set: function set(value) {}
        }
    ]);
    return Example;
}();
exports.Example = Example;
//# sourceMappingURL=helpers.js.map
"
`;

exports[`Outputs (babel) > artifacts > builds all the artifacts with rollup > cjs/server.cjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: current, Format: cjs

'use strict';

const https = require('node:https');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const https__default = /*#__PURE__*/_interopDefault(https);
https__default.default.createServer((req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/plain'
  });
  res.write('Hello World!');
  res.end();
}).listen(8080);
//# sourceMappingURL=server.cjs.map
"
`;

exports[`Outputs (babel) > artifacts > builds all the artifacts with rollup > cjs/server-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import './server.cjs';"
`;

exports[`Outputs (babel) > artifacts > builds all the artifacts with rollup > esm/client.js 1`] = `
"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// Bundled with Packemon: https://packemon.dev
// Platform: browser, Support: legacy, Format: esm
var Client = /*#__PURE__*/_createClass(function Client() {
  _classCallCheck(this, Client);
  _defineProperty(this, "prop", 123);
});
function* gen() {}
async function wait() {}
async function createClient() {
  await wait();
  var _iterator = _createForOfIteratorHelper(gen()),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var iterator = _step.value;
      console.log(iterator);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return new Client();
}
export { createClient };
//# sourceMappingURL=client.js.map
"
`;

exports[`Outputs (babel) > artifacts > builds all the artifacts with rollup > lib/bundle-D7lcxiVj.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: native, Support: experimental, Format: lib

'use strict';

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const comma = ','.charCodeAt(0);
const semicolon = ';'.charCodeAt(0);
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const intToChar = new Uint8Array(64); // 64 possible chars.
const charToInt = new Uint8Array(128); // z is 122 in ASCII
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
// Provide a fallback for older environments.
const td = typeof TextDecoder !== 'undefined' ? /* #__PURE__ */new TextDecoder() : typeof Buffer !== 'undefined' ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = '';
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
function encode(decoded) {
  const state = new Int32Array(5);
  const bufLength = 1024 * 16;
  const subLength = bufLength - 36;
  const buf = new Uint8Array(bufLength);
  const sub = buf.subarray(0, subLength);
  let pos = 0;
  let out = '';
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) {
      if (pos === bufLength) {
        out += td.decode(buf);
        pos = 0;
      }
      buf[pos++] = semicolon;
    }
    if (line.length === 0) continue;
    state[0] = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      // We can push up to 5 ints, each int can take at most 7 chars, and we
      // may push a comma.
      if (pos > subLength) {
        out += td.decode(sub);
        buf.copyWithin(0, subLength, pos);
        pos -= subLength;
      }
      if (j > 0) buf[pos++] = comma;
      pos = encodeInteger(buf, pos, state, segment, 0); // genColumn
      if (segment.length === 1) continue;
      pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex
      pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine
      pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn
      if (segment.length === 4) continue;
      pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex
    }
  }
  return out + td.decode(buf.subarray(0, pos));
}
function encodeInteger(buf, pos, state, segment, j) {
  const next = segment[j];
  let num = next - state[j];
  state[j] = next;
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    let clamped = num & 0b011111;
    num >>>= 5;
    if (num > 0) clamped |= 0b100000;
    buf[pos++] = intToChar[clamped];
  } while (num > 0);
  return pos;
}
class BitSet {
  constructor(arg) {
    this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
  }
  add(n) {
    this.bits[n >> 5] |= 1 << (n & 31);
  }
  has(n) {
    return !!(this.bits[n >> 5] & 1 << (n & 31));
  }
}
class Chunk {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = '';
    this.outro = '';
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = '';
      this.outro = '';
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  reset() {
    this.intro = '';
    this.outro = '';
    if (this.edited) {
      this.content = this.original;
      this.storeName = false;
      this.edited = false;
    }
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = '';
    this.end = index;
    if (this.edited) {
      // after split we should save the edit content record into the correct chunk
      // to make sure sourcemap correct
      // For example:
      // '  test'.trim()
      //     split   -> '  ' + 'test'
      //   ✔️ edit    -> '' + 'test'
      //   ✖️ edit    -> 'test' + '' 
      // TODO is this block necessary?...
      newChunk.edit('', false);
      this.content = '';
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next) newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, '');
    if (this.outro.length) return true;
    const trimmed = this.content.replace(rx, '');
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit('', undefined, true);
        if (this.edited) {
          // save the change, if it has been edited
          this.edit(trimmed, this.storeName, true);
        }
      }
      return true;
    } else {
      this.edit('', undefined, true);
      this.intro = this.intro.replace(rx, '');
      if (this.intro.length) return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, '');
    if (this.intro.length) return true;
    const trimmed = this.content.replace(rx, '');
    if (trimmed.length) {
      if (trimmed !== this.content) {
        const newChunk = this.split(this.end - trimmed.length);
        if (this.edited) {
          // save the change, if it has been edited
          newChunk.edit(trimmed, this.storeName, true);
        }
        this.edit('', undefined, true);
      }
      return true;
    } else {
      this.edit('', undefined, true);
      this.outro = this.outro.replace(rx, '');
      if (this.outro.length) return true;
    }
  }
}
function getBtoa() {
  if (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {
    return str => globalThis.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === 'function') {
    return str => Buffer.from(str, 'utf-8').toString('base64');
  } else {
    return () => {
      throw new Error('Unsupported environment: \`window.btoa\` or \`Buffer\` should be supported.');
    };
  }
}
const btoa = /*#__PURE__*/getBtoa();
class SourceMap {
  constructor(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = encode(properties.mappings);
    if (typeof properties.x_google_ignoreList !== 'undefined') {
      this.x_google_ignoreList = properties.x_google_ignoreList;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
  }
}
function guessIndent(code) {
  const lines = code.split('\\n');
  const tabbed = lines.filter(line => /^\\t+/.test(line));
  const spaced = lines.filter(line => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }

  // More lines tabbed than spaced? Assume tabs, and
  // default to tabs in the case of a tie (or nothing
  // to go on)
  if (tabbed.length >= spaced.length) {
    return '\\t';
  }

  // Otherwise, we need to guess the multiple
  const min = spaced.reduce((previous, current) => {
    const numSpaces = /^ +/.exec(current)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(' ');
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\\\]/);
  const toParts = to.split(/[/\\\\]/);
  fromParts.pop(); // get dirname

  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--) fromParts[i] = '..';
  }
  return fromParts.concat(toParts).join('/');
}
const toString = Object.prototype.toString;
function isObject(thing) {
  return toString.call(thing) === '[object Object]';
}
function getLocator(source) {
  const originalLines = source.split('\\n');
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return {
      line,
      column
    };
  };
}
const wordRegex = /\\w/;
class Mappings {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const contentLengthMinusOne = content.length - 1;
      let contentLineEnd = content.indexOf('\\n', 0);
      let previousContentLineEnd = -1;
      // Loop through each line in the content and add a segment, but stop if the last line is empty,
      // else code afterwards would fill one line too many
      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
        const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment.push(nameIndex);
        }
        this.rawSegments.push(segment);
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        previousContentLineEnd = contentLineEnd;
        contentLineEnd = content.indexOf('\\n', contentLineEnd + 1);
      }
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
      this.advance(content.slice(previousContentLineEnd + 1));
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
      this.advance(content);
    }
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first = true;
    // when iterating each char, check if it's in a word boundary
    let charInHiresBoundary = false;
    while (originalCharIndex < chunk.end) {
      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
        const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (this.hires === 'boundary') {
          // in hires "boundary", group segments per word boundary than per char
          if (wordRegex.test(original[originalCharIndex])) {
            // for first char in the boundary found, start the boundary by pushing a segment
            if (!charInHiresBoundary) {
              this.rawSegments.push(segment);
              charInHiresBoundary = true;
            }
          } else {
            // for non-word char, end the boundary by pushing a segment
            this.rawSegments.push(segment);
            charInHiresBoundary = false;
          }
        } else {
          this.rawSegments.push(segment);
        }
      }
      if (original[originalCharIndex] === '\\n') {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
      } else {
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str) {
    if (!str) return;
    const lines = str.split('\\n');
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
}
const n = '\\n';
const warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
class MagicString {
  constructor(string, options = {}) {
    const chunk = new Chunk(0, string.length, string);
    Object.defineProperties(this, {
      original: {
        writable: true,
        value: string
      },
      outro: {
        writable: true,
        value: ''
      },
      intro: {
        writable: true,
        value: ''
      },
      firstChunk: {
        writable: true,
        value: chunk
      },
      lastChunk: {
        writable: true,
        value: chunk
      },
      lastSearchedChunk: {
        writable: true,
        value: chunk
      },
      byStart: {
        writable: true,
        value: {}
      },
      byEnd: {
        writable: true,
        value: {}
      },
      filename: {
        writable: true,
        value: options.filename
      },
      indentExclusionRanges: {
        writable: true,
        value: options.indentExclusionRanges
      },
      sourcemapLocations: {
        writable: true,
        value: new BitSet()
      },
      storedNames: {
        writable: true,
        value: {}
      },
      indentStr: {
        writable: true,
        value: undefined
      },
      ignoreList: {
        writable: true,
        value: options.ignoreList
      }
    });
    this.byStart[0] = chunk;
    this.byEnd[string.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== 'string') throw new TypeError('outro content must be a string');
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new MagicString(this.original, {
      filename: this.filename
    });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options) {
    options = options || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options.hires);
    const locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext(chunk => {
      const loc = locate(chunk.start);
      if (chunk.intro.length) mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length) mappings.advance(chunk.outro);
    });
    return {
      file: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,
      sources: [options.source ? getRelativePath(options.file || '', options.source) : options.file || ''],
      sourcesContent: options.includeContent ? [this.original] : undefined,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined
    };
  }
  generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
  }
  _ensureindentStr() {
    if (this.indentStr === undefined) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? '\\t' : this.indentStr;
  }
  indent(indentStr, options) {
    const pattern = /^[^\\r\\n]/gm;
    if (isObject(indentStr)) {
      options = indentStr;
      indentStr = undefined;
    }
    if (indentStr === undefined) {
      this._ensureindentStr();
      indentStr = this.indentStr || '\\t';
    }
    if (indentStr === '') return this; // noop

    options = options || {};

    // Process exclusion ranges
    const isExcluded = {};
    if (options.exclude) {
      const exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
      exclusions.forEach(exclusion => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options.indentStart !== false;
    const replacer = match => {
      if (shouldIndentNextCharacter) return \`\${indentStr}\${match}\`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === '\\n') {
              shouldIndentNextCharacter = true;
            } else if (char !== '\\r' && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  }
  insert() {
    throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
  }
  insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start, end, index) {
    if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');
    this._split(start);
    this._split(end);
    this._split(index);
    const first = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk) return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft) oldLeft.next = oldRight;
    if (oldRight) oldRight.previous = oldLeft;
    if (newLeft) newLeft.next = first;
    if (newRight) newRight.previous = last;
    if (!first.previous) this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft) this.firstChunk = first;
    if (!newRight) this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options) {
    options = options || {};
    return this.update(start, end, content, _objectSpread(_objectSpread({}, options), {}, {
      overwrite: !options.contentOnly
    }));
  }
  update(start, end, content, options) {
    if (typeof content !== 'string') throw new TypeError('replacement content must be a string');
    while (start < 0) start += this.original.length;
    while (end < 0) end += this.original.length;
    if (end > this.original.length) throw new Error('end is out of bounds');
    if (start === end) throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');
    this._split(start);
    this._split(end);
    if (options === true) {
      if (!warned.storeName) {
        console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console
        warned.storeName = true;
      }
      options = {
        storeName: true
      };
    }
    const storeName = options !== undefined ? options.storeName : false;
    const overwrite = options !== undefined ? options.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first = this.byStart[start];
    const last = this.byEnd[end];
    if (first) {
      let chunk = first;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error('Cannot overwrite across a split point');
        }
        chunk = chunk.next;
        chunk.edit('', false);
      }
      first.edit(content, storeName, !overwrite);
    } else {
      // must be inserting at the end
      const newChunk = new Chunk(start, end, '').edit(content, storeName);

      // TODO last chunk in the array may not be the last chunk, if it's moved...
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== 'string') throw new TypeError('outro content must be a string');
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    while (start < 0) start += this.original.length;
    while (end < 0) end += this.original.length;
    if (start === end) return this;
    if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
    if (start > end) throw new Error('end must be greater than start');
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = '';
      chunk.outro = '';
      chunk.edit('');
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  reset(start, end) {
    while (start < 0) start += this.original.length;
    while (end < 0) end += this.original.length;
    if (start === end) return this;
    if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
    if (start > end) throw new Error('end must be greater than start');
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.reset();
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length) return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length) return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length) return this.intro[this.intro.length - 1];
    return '';
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length) {
    while (start < 0) start += this.original.length;
    while (end < 0) end += this.original.length;
    let result = '';

    // find start chunk
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      // found end chunk before start
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start) throw new Error(\`Cannot use replaced character \${start} as slice start anchor.\`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(\`Cannot use replaced character \${end} as slice end anchor.\`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }

  // TODO deprecate this? not really very useful
  snip(start, end) {
    const clone = this.clone();
    clone.remove(0, start);
    clone.remove(end, clone.original.length);
    return clone;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index]) return;
    let chunk = this.lastSearchedChunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index)) return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      // zero-length edited chunks are a special case (overlapping replacements)
      const loc = getLocator(this.original)(index);
      throw new Error(\`Cannot split a chunk that has already been edited (\${loc.line}:\${loc.column} – "\${chunk.original}")\`);
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk) this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim('[\\\\r\\\\n]');
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || '\\\\s') + '+$');
    this.outro = this.outro.replace(rx, '');
    if (this.outro.length) return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);

      // if chunk was trimmed, we have a new lastChunk
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp('^' + (charType || '\\\\s') + '+');
    this.intro = this.intro.replace(rx, '');
    if (this.intro.length) return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        // special case...
        if (chunk === this.lastChunk) this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str) {
      if (typeof replacement === 'string') {
        return replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {
          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
          if (i === '$') return '$';
          if (i === '&') return match[0];
          const num = +i;
          if (num < match.length) return match[+i];
          return \`$\${i}\`;
        });
      } else {
        return replacement(...match, match.index, str, match.groups);
      }
    }
    function matchAll(re, str) {
      let match;
      const matches = [];
      while (match = re.exec(str)) {
        matches.push(match);
      }
      return matches;
    }
    if (searchValue.global) {
      const matches = matchAll(searchValue, this.original);
      matches.forEach(match => {
        if (match.index != null) {
          const replacement = getReplacement(match, this.original);
          if (replacement !== match[0]) {
            this.overwrite(match.index, match.index + match[0].length, replacement);
          }
        }
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null) {
        const replacement = getReplacement(match, this.original);
        if (replacement !== match[0]) {
          this.overwrite(match.index, match.index + match[0].length, replacement);
        }
      }
    }
    return this;
  }
  _replaceString(string, replacement) {
    const original = this.original;
    const index = original.indexOf(string);
    if (index !== -1) {
      this.overwrite(index, index + string.length, replacement);
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === 'string') {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string, replacement) {
    const original = this.original;
    const stringLength = string.length;
    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {
      const previous = original.slice(index, index + stringLength);
      if (previous !== replacement) this.overwrite(index, index + stringLength, replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === 'string') {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError('MagicString.prototype.replaceAll called with a non-global RegExp argument');
    }
    return this._replaceRegexp(searchValue, replacement);
  }
}
exports.SourceMap = SourceMap;
exports.default = MagicString;
//# sourceMappingURL=bundle-D7lcxiVj.js.map
"
`;

exports[`Outputs (babel) > artifacts > builds all the artifacts with rollup > lib/client.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: browser, Support: legacy, Format: lib

'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Client = /*#__PURE__*/_createClass(function Client() {
  _classCallCheck(this, Client);
  _defineProperty(this, "prop", 123);
});
function* gen() {}
async function wait() {}
async function createClient() {
  await wait();
  var _iterator = _createForOfIteratorHelper(gen()),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var iterator = _step.value;
      console.log(iterator);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return new Client();
}
exports.createClient = createClient;
//# sourceMappingURL=client.js.map
"
`;

exports[`Outputs (babel) > artifacts > builds all the artifacts with rollup > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: lib

'use strict';

const EXAMPLE = 'foo';
exports.EXAMPLE = EXAMPLE;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > artifacts > builds all the artifacts with rollup > lib/test.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: native, Support: experimental, Format: lib
'use strict';const _excluded=["maxLength"],_excluded2=["value"];function _objectWithoutProperties(source,excluded){if(source==null)return{};var target=_objectWithoutPropertiesLoose(source,excluded);var key,i;if(Object.getOwnPropertySymbols){var sourceSymbolKeys=Object.getOwnPropertySymbols(source);for(i=0;i<sourceSymbolKeys.length;i++){key=sourceSymbolKeys[i];if(excluded.indexOf(key)>=0)continue;if(!Object.prototype.propertyIsEnumerable.call(source,key))continue;target[key]=source[key];}}return target;}function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return{};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key];}return target;}function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_unsupportedIterableToArray(arr,i)||_nonIterableRest();}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o==="string")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2;}function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1;}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r;}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return;}finally{if(o)throw n;}}return a;}}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr;}function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}function _defineProperty(obj,key,value){key=_toPropertyKey(key);if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _toPropertyKey(t){var i=_toPrimitive(t,"string");return"symbol"==typeof i?i:i+"";}function _toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.");}return("string"===r?String:Number)(t);}function assertTypes(value,name,types){const receivedType=typeof value;const pass=types.includes(receivedType);if(!pass)throw new TypeError(\`\${name} value must be \${types.join(" or ")}, received "\${receivedType}"\`);}function isObject$1(item){return item!=null&&typeof item==="object"&&!Array.isArray(item);}function isFinalObj(obj){return obj===Object.prototype||obj===Function.prototype||obj===RegExp.prototype;}function getType$2(value){return Object.prototype.toString.apply(value).slice(8,-1);}function collectOwnProperties(obj,collector){const collect=typeof collector==="function"?collector:key=>collector.add(key);Object.getOwnPropertyNames(obj).forEach(collect);Object.getOwnPropertySymbols(obj).forEach(collect);}function getOwnProperties(obj){const ownProps=/* @__PURE__ */new Set();if(isFinalObj(obj))return[];collectOwnProperties(obj,ownProps);return Array.from(ownProps);}const defaultCloneOptions={forceWritable:false};function deepClone(val,options=defaultCloneOptions){const seen=/* @__PURE__ */new WeakMap();return clone(val,seen,options);}function clone(val,seen,options=defaultCloneOptions){let k,out;if(seen.has(val))return seen.get(val);if(Array.isArray(val)){out=Array(k=val.length);seen.set(val,out);while(k--)out[k]=clone(val[k],seen,options);return out;}if(Object.prototype.toString.call(val)==="[object Object]"){out=Object.create(Object.getPrototypeOf(val));seen.set(val,out);const props=getOwnProperties(val);for(const k2 of props){const descriptor=Object.getOwnPropertyDescriptor(val,k2);if(!descriptor)continue;const cloned=clone(val[k2],seen,options);if(options.forceWritable){Object.defineProperty(out,k2,{enumerable:descriptor.enumerable,configurable:true,writable:true,value:cloned});}else if("get"in descriptor){Object.defineProperty(out,k2,_objectSpread(_objectSpread({},descriptor),{},{get(){return cloned;}}));}else{Object.defineProperty(out,k2,_objectSpread(_objectSpread({},descriptor),{},{value:cloned}));}}return out;}return val;}function objectAttr(source,path,defaultValue=void 0){const paths=path.replace(/\\[(\\d+)\\]/g,".$1").split(".");let result=source;for(const p of paths){result=Object(result)[p];if(result===void 0)return defaultValue;}return result;}function createDefer(){let resolve=null;let reject=null;const p=new Promise((_resolve,_reject)=>{resolve=_resolve;reject=_reject;});p.resolve=resolve;p.reject=reject;return p;}var commonjsGlobal$1=typeof globalThis!=='undefined'?globalThis:typeof window!=='undefined'?window:typeof global!=='undefined'?global:typeof self!=='undefined'?self:{};function getDefaultExportFromCjs$2(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,'default')?x['default']:x;}function getAugmentedNamespace(n){if(n.__esModule)return n;var f=n.default;if(typeof f=="function"){var a=function a(){if(this instanceof a){return Reflect.construct(f,arguments,this.constructor);}return f.apply(this,arguments);};a.prototype=f.prototype;}else a={};Object.defineProperty(a,'__esModule',{value:true});Object.keys(n).forEach(function(k){var d=Object.getOwnPropertyDescriptor(n,k);Object.defineProperty(a,k,d.get?d:{enumerable:true,get:function(){return n[k];}});});return a;}var build$1={};var ansiStyles={exports:{}};ansiStyles.exports;(function(module){const ANSI_BACKGROUND_OFFSET=10;const wrapAnsi256=(offset=0)=>code=>\`\\u001B[\${38+offset};5;\${code}m\`;const wrapAnsi16m=(offset=0)=>(red,green,blue)=>\`\\u001B[\${38+offset};2;\${red};\${green};\${blue}m\`;function assembleStyles(){const codes=new Map();const styles={modifier:{reset:[0,0],// 21 isn't widely supported and 22 does the same thing
bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],// Bright color
blackBright:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],// Bright color
bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};// Alias bright black as gray (and grey)
styles.color.gray=styles.color.blackBright;styles.bgColor.bgGray=styles.bgColor.bgBlackBright;styles.color.grey=styles.color.blackBright;styles.bgColor.bgGrey=styles.bgColor.bgBlackBright;for(const _ref of Object.entries(styles)){var _ref2=_slicedToArray(_ref,2);const groupName=_ref2[0];const group=_ref2[1];for(const _ref3 of Object.entries(group)){var _ref4=_slicedToArray(_ref3,2);const styleName=_ref4[0];const style=_ref4[1];styles[styleName]={open:\`\\u001B[\${style[0]}m\`,close:\`\\u001B[\${style[1]}m\`};group[styleName]=styles[styleName];codes.set(style[0],style[1]);}Object.defineProperty(styles,groupName,{value:group,enumerable:false});}Object.defineProperty(styles,'codes',{value:codes,enumerable:false});styles.color.close='\\u001B[39m';styles.bgColor.close='\\u001B[49m';styles.color.ansi256=wrapAnsi256();styles.color.ansi16m=wrapAnsi16m();styles.bgColor.ansi256=wrapAnsi256(ANSI_BACKGROUND_OFFSET);styles.bgColor.ansi16m=wrapAnsi16m(ANSI_BACKGROUND_OFFSET);// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
Object.defineProperties(styles,{rgbToAnsi256:{value:(red,green,blue)=>{// We use the extended greyscale palette here, with the exception of
// black and white. normal palette only has 4 greyscale shades.
if(red===green&&green===blue){if(red<8){return 16;}if(red>248){return 231;}return Math.round((red-8)/247*24)+232;}return 16+36*Math.round(red/255*5)+6*Math.round(green/255*5)+Math.round(blue/255*5);},enumerable:false},hexToRgb:{value:hex=>{const matches=/(?<colorString>[a-f\\d]{6}|[a-f\\d]{3})/i.exec(hex.toString(16));if(!matches){return[0,0,0];}let colorString=matches.groups.colorString;if(colorString.length===3){colorString=colorString.split('').map(character=>character+character).join('');}const integer=Number.parseInt(colorString,16);return[integer>>16&0xFF,integer>>8&0xFF,integer&0xFF];},enumerable:false},hexToAnsi256:{value:hex=>styles.rgbToAnsi256(...styles.hexToRgb(hex)),enumerable:false}});return styles;}// Make the export immutable
Object.defineProperty(module,'exports',{enumerable:true,get:assembleStyles});})(ansiStyles);var ansiStylesExports=ansiStyles.exports;var collections={};Object.defineProperty(collections,'__esModule',{value:true});collections.printIteratorEntries=printIteratorEntries;collections.printIteratorValues=printIteratorValues;collections.printListItems=printListItems;collections.printObjectProperties=printObjectProperties;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */const getKeysOfEnumerableProperties=(object,compareKeys)=>{const rawKeys=Object.keys(object);const keys=compareKeys!==null?rawKeys.sort(compareKeys):rawKeys;if(Object.getOwnPropertySymbols){Object.getOwnPropertySymbols(object).forEach(symbol=>{if(Object.getOwnPropertyDescriptor(object,symbol).enumerable){keys.push(symbol);}});}return keys;};/**
 * Return entries (for example, of a map)
 * with spacing, indentation, and comma
 * without surrounding punctuation (for example, braces)
 */function printIteratorEntries(iterator,config,indentation,depth,refs,printer,// Too bad, so sad that separator for ECMAScript Map has been ' => '
// What a distracting diff if you change a data structure to/from
// ECMAScript Object or Immutable.Map/OrderedMap which use the default.
separator=': '){let result='';let width=0;let current=iterator.next();if(!current.done){result+=config.spacingOuter;const indentationNext=indentation+config.indent;while(!current.done){result+=indentationNext;if(width++===config.maxWidth){result+='…';break;}const name=printer(current.value[0],config,indentationNext,depth,refs);const value=printer(current.value[1],config,indentationNext,depth,refs);result+=name+separator+value;current=iterator.next();if(!current.done){result+=\`,\${config.spacingInner}\`;}else if(!config.min){result+=',';}}result+=config.spacingOuter+indentation;}return result;}/**
 * Return values (for example, of a set)
 * with spacing, indentation, and comma
 * without surrounding punctuation (braces or brackets)
 */function printIteratorValues(iterator,config,indentation,depth,refs,printer){let result='';let width=0;let current=iterator.next();if(!current.done){result+=config.spacingOuter;const indentationNext=indentation+config.indent;while(!current.done){result+=indentationNext;if(width++===config.maxWidth){result+='…';break;}result+=printer(current.value,config,indentationNext,depth,refs);current=iterator.next();if(!current.done){result+=\`,\${config.spacingInner}\`;}else if(!config.min){result+=',';}}result+=config.spacingOuter+indentation;}return result;}/**
 * Return items (for example, of an array)
 * with spacing, indentation, and comma
 * without surrounding punctuation (for example, brackets)
 **/function printListItems(list,config,indentation,depth,refs,printer){let result='';if(list.length){result+=config.spacingOuter;const indentationNext=indentation+config.indent;for(let i=0;i<list.length;i++){result+=indentationNext;if(i===config.maxWidth){result+='…';break;}if(i in list){result+=printer(list[i],config,indentationNext,depth,refs);}if(i<list.length-1){result+=\`,\${config.spacingInner}\`;}else if(!config.min){result+=',';}}result+=config.spacingOuter+indentation;}return result;}/**
 * Return properties of an object
 * with spacing, indentation, and comma
 * without surrounding punctuation (for example, braces)
 */function printObjectProperties(val,config,indentation,depth,refs,printer){let result='';const keys=getKeysOfEnumerableProperties(val,config.compareKeys);if(keys.length){result+=config.spacingOuter;const indentationNext=indentation+config.indent;for(let i=0;i<keys.length;i++){const key=keys[i];const name=printer(key,config,indentationNext,depth,refs);const value=printer(val[key],config,indentationNext,depth,refs);result+=\`\${indentationNext+name}: \${value}\`;if(i<keys.length-1){result+=\`,\${config.spacingInner}\`;}else if(!config.min){result+=',';}}result+=config.spacingOuter+indentation;}return result;}var AsymmetricMatcher$4={};Object.defineProperty(AsymmetricMatcher$4,'__esModule',{value:true});AsymmetricMatcher$4.test=AsymmetricMatcher$4.serialize=AsymmetricMatcher$4.default=void 0;var _collections$3=collections;var Symbol$2=globalThis['jest-symbol-do-not-touch']||globalThis.Symbol;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */const asymmetricMatcher=typeof Symbol$2==='function'&&Symbol$2.for?Symbol$2.for('jest.asymmetricMatcher'):0x1357a5;const SPACE$2=' ';const serialize$7=(val,config,indentation,depth,refs,printer)=>{const stringedValue=val.toString();if(stringedValue==='ArrayContaining'||stringedValue==='ArrayNotContaining'){if(++depth>config.maxDepth){return\`[\${stringedValue}]\`;}return\`\${stringedValue+SPACE$2}[\${(0,_collections$3.printListItems)(val.sample,config,indentation,depth,refs,printer)}]\`;}if(stringedValue==='ObjectContaining'||stringedValue==='ObjectNotContaining'){if(++depth>config.maxDepth){return\`[\${stringedValue}]\`;}return\`\${stringedValue+SPACE$2}{\${(0,_collections$3.printObjectProperties)(val.sample,config,indentation,depth,refs,printer)}}\`;}if(stringedValue==='StringMatching'||stringedValue==='StringNotMatching'){return stringedValue+SPACE$2+printer(val.sample,config,indentation,depth,refs);}if(stringedValue==='StringContaining'||stringedValue==='StringNotContaining'){return stringedValue+SPACE$2+printer(val.sample,config,indentation,depth,refs);}if(typeof val.toAsymmetricMatcher!=='function'){throw new Error(\`Asymmetric matcher \${val.constructor.name} does not implement toAsymmetricMatcher()\`);}return val.toAsymmetricMatcher();};AsymmetricMatcher$4.serialize=serialize$7;const test$7=val=>val&&val.$$typeof===asymmetricMatcher;AsymmetricMatcher$4.test=test$7;const plugin$6={serialize:serialize$7,test:test$7};var _default$7=plugin$6;AsymmetricMatcher$4.default=_default$7;var DOMCollection$3={};Object.defineProperty(DOMCollection$3,'__esModule',{value:true});DOMCollection$3.test=DOMCollection$3.serialize=DOMCollection$3.default=void 0;var _collections$2=collections;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */const SPACE$1=' ';const OBJECT_NAMES=['DOMStringMap','NamedNodeMap'];const ARRAY_REGEXP=/^(HTML\\w*Collection|NodeList)$/;const testName=name=>OBJECT_NAMES.indexOf(name)!==-1||ARRAY_REGEXP.test(name);const test$6=val=>val&&val.constructor&&!!val.constructor.name&&testName(val.constructor.name);DOMCollection$3.test=test$6;const isNamedNodeMap=collection=>collection.constructor.name==='NamedNodeMap';const serialize$6=(collection,config,indentation,depth,refs,printer)=>{const name=collection.constructor.name;if(++depth>config.maxDepth){return\`[\${name}]\`;}return(config.min?'':name+SPACE$1)+(OBJECT_NAMES.indexOf(name)!==-1?\`{\${(0,_collections$2.printObjectProperties)(isNamedNodeMap(collection)?Array.from(collection).reduce((props,attribute)=>{props[attribute.name]=attribute.value;return props;},{}):_objectSpread({},collection),config,indentation,depth,refs,printer)}}\`:\`[\${(0,_collections$2.printListItems)(Array.from(collection),config,indentation,depth,refs,printer)}]\`);};DOMCollection$3.serialize=serialize$6;const plugin$5={serialize:serialize$6,test:test$6};var _default$6=plugin$5;DOMCollection$3.default=_default$6;var DOMElement$3={};var markup={};var escapeHTML$1={};Object.defineProperty(escapeHTML$1,'__esModule',{value:true});escapeHTML$1.default=escapeHTML;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */function escapeHTML(str){return str.replace(/</g,'&lt;').replace(/>/g,'&gt;');}Object.defineProperty(markup,'__esModule',{value:true});markup.printText=markup.printProps=markup.printElementAsLeaf=markup.printElement=markup.printComment=markup.printChildren=void 0;var _escapeHTML=_interopRequireDefault$1(escapeHTML$1);function _interopRequireDefault$1(obj){return obj&&obj.__esModule?obj:{default:obj};}/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Return empty string if keys is empty.
const printProps=(keys,props,config,indentation,depth,refs,printer)=>{const indentationNext=indentation+config.indent;const colors=config.colors;return keys.map(key=>{const value=props[key];let printed=printer(value,config,indentationNext,depth,refs);if(typeof value!=='string'){if(printed.indexOf('\\n')!==-1){printed=config.spacingOuter+indentationNext+printed+config.spacingOuter+indentation;}printed=\`{\${printed}}\`;}return\`\${config.spacingInner+indentation+colors.prop.open+key+colors.prop.close}=\${colors.value.open}\${printed}\${colors.value.close}\`;}).join('');};// Return empty string if children is empty.
markup.printProps=printProps;const printChildren=(children,config,indentation,depth,refs,printer)=>children.map(child=>config.spacingOuter+indentation+(typeof child==='string'?printText(child,config):printer(child,config,indentation,depth,refs))).join('');markup.printChildren=printChildren;const printText=(text,config)=>{const contentColor=config.colors.content;return contentColor.open+(0,_escapeHTML.default)(text)+contentColor.close;};markup.printText=printText;const printComment=(comment,config)=>{const commentColor=config.colors.comment;return\`\${commentColor.open}<!--\${(0,_escapeHTML.default)(comment)}-->\${commentColor.close}\`;};// Separate the functions to format props, children, and element,
// so a plugin could override a particular function, if needed.
// Too bad, so sad: the traditional (but unnecessary) space
// in a self-closing tagColor requires a second test of printedProps.
markup.printComment=printComment;const printElement=(type,printedProps,printedChildren,config,indentation)=>{const tagColor=config.colors.tag;return\`\${tagColor.open}<\${type}\${printedProps&&tagColor.close+printedProps+config.spacingOuter+indentation+tagColor.open}\${printedChildren?\`>\${tagColor.close}\${printedChildren}\${config.spacingOuter}\${indentation}\${tagColor.open}</\${type}\`:\`\${printedProps&&!config.min?'':' '}/\`}>\${tagColor.close}\`;};markup.printElement=printElement;const printElementAsLeaf=(type,config)=>{const tagColor=config.colors.tag;return\`\${tagColor.open}<\${type}\${tagColor.close} …\${tagColor.open} />\${tagColor.close}\`;};markup.printElementAsLeaf=printElementAsLeaf;Object.defineProperty(DOMElement$3,'__esModule',{value:true});DOMElement$3.test=DOMElement$3.serialize=DOMElement$3.default=void 0;var _markup$2=markup;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */const ELEMENT_NODE=1;const TEXT_NODE=3;const COMMENT_NODE=8;const FRAGMENT_NODE=11;const ELEMENT_REGEXP=/^((HTML|SVG)\\w*)?Element$/;const testHasAttribute=val=>{try{return typeof val.hasAttribute==='function'&&val.hasAttribute('is');}catch{return false;}};const testNode=val=>{const constructorName=val.constructor.name;const nodeType=val.nodeType,tagName=val.tagName;const isCustomElement=typeof tagName==='string'&&tagName.includes('-')||testHasAttribute(val);return nodeType===ELEMENT_NODE&&(ELEMENT_REGEXP.test(constructorName)||isCustomElement)||nodeType===TEXT_NODE&&constructorName==='Text'||nodeType===COMMENT_NODE&&constructorName==='Comment'||nodeType===FRAGMENT_NODE&&constructorName==='DocumentFragment';};const test$5=val=>val?.constructor?.name&&testNode(val);DOMElement$3.test=test$5;function nodeIsText(node){return node.nodeType===TEXT_NODE;}function nodeIsComment(node){return node.nodeType===COMMENT_NODE;}function nodeIsFragment(node){return node.nodeType===FRAGMENT_NODE;}const serialize$5=(node,config,indentation,depth,refs,printer)=>{if(nodeIsText(node)){return(0,_markup$2.printText)(node.data,config);}if(nodeIsComment(node)){return(0,_markup$2.printComment)(node.data,config);}const type=nodeIsFragment(node)?'DocumentFragment':node.tagName.toLowerCase();if(++depth>config.maxDepth){return(0,_markup$2.printElementAsLeaf)(type,config);}return(0,_markup$2.printElement)(type,(0,_markup$2.printProps)(nodeIsFragment(node)?[]:Array.from(node.attributes,attr=>attr.name).sort(),nodeIsFragment(node)?{}:Array.from(node.attributes).reduce((props,attribute)=>{props[attribute.name]=attribute.value;return props;},{}),config,indentation+config.indent,depth,refs,printer),(0,_markup$2.printChildren)(Array.prototype.slice.call(node.childNodes||node.children),config,indentation+config.indent,depth,refs,printer),config,indentation);};DOMElement$3.serialize=serialize$5;const plugin$4={serialize:serialize$5,test:test$5};var _default$5=plugin$4;DOMElement$3.default=_default$5;var Immutable$3={};Object.defineProperty(Immutable$3,'__esModule',{value:true});Immutable$3.test=Immutable$3.serialize=Immutable$3.default=void 0;var _collections$1=collections;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // SENTINEL constants are from https://github.com/facebook/immutable-js
const IS_ITERABLE_SENTINEL='@@__IMMUTABLE_ITERABLE__@@';const IS_LIST_SENTINEL='@@__IMMUTABLE_LIST__@@';const IS_KEYED_SENTINEL$1='@@__IMMUTABLE_KEYED__@@';const IS_MAP_SENTINEL='@@__IMMUTABLE_MAP__@@';const IS_ORDERED_SENTINEL$1='@@__IMMUTABLE_ORDERED__@@';const IS_RECORD_SENTINEL='@@__IMMUTABLE_RECORD__@@';// immutable v4
const IS_SEQ_SENTINEL='@@__IMMUTABLE_SEQ__@@';const IS_SET_SENTINEL$1='@@__IMMUTABLE_SET__@@';const IS_STACK_SENTINEL='@@__IMMUTABLE_STACK__@@';const getImmutableName=name=>\`Immutable.\${name}\`;const printAsLeaf=name=>\`[\${name}]\`;const SPACE=' ';const LAZY='…';// Seq is lazy if it calls a method like filter
const printImmutableEntries=(val,config,indentation,depth,refs,printer,type)=>++depth>config.maxDepth?printAsLeaf(getImmutableName(type)):\`\${getImmutableName(type)+SPACE}{\${(0,_collections$1.printIteratorEntries)(val.entries(),config,indentation,depth,refs,printer)}}\`;// Record has an entries method because it is a collection in immutable v3.
// Return an iterator for Immutable Record from version v3 or v4.
function getRecordEntries(val){let i=0;return{next(){if(i<val._keys.length){const key=val._keys[i++];return{done:false,value:[key,val.get(key)]};}return{done:true,value:undefined};}};}const printImmutableRecord=(val,config,indentation,depth,refs,printer)=>{// _name property is defined only for an Immutable Record instance
// which was constructed with a second optional descriptive name arg
const name=getImmutableName(val._name||'Record');return++depth>config.maxDepth?printAsLeaf(name):\`\${name+SPACE}{\${(0,_collections$1.printIteratorEntries)(getRecordEntries(val),config,indentation,depth,refs,printer)}}\`;};const printImmutableSeq=(val,config,indentation,depth,refs,printer)=>{const name=getImmutableName('Seq');if(++depth>config.maxDepth){return printAsLeaf(name);}if(val[IS_KEYED_SENTINEL$1]){return\`\${name+SPACE}{\${// from Immutable collection of entries or from ECMAScript object
val._iter||val._object?(0,_collections$1.printIteratorEntries)(val.entries(),config,indentation,depth,refs,printer):LAZY}}\`;}return\`\${name+SPACE}[\${val._iter||// from Immutable collection of values
val._array||// from ECMAScript array
val._collection||// from ECMAScript collection in immutable v4
val._iterable// from ECMAScript collection in immutable v3
?(0,_collections$1.printIteratorValues)(val.values(),config,indentation,depth,refs,printer):LAZY}]\`;};const printImmutableValues=(val,config,indentation,depth,refs,printer,type)=>++depth>config.maxDepth?printAsLeaf(getImmutableName(type)):\`\${getImmutableName(type)+SPACE}[\${(0,_collections$1.printIteratorValues)(val.values(),config,indentation,depth,refs,printer)}]\`;const serialize$4=(val,config,indentation,depth,refs,printer)=>{if(val[IS_MAP_SENTINEL]){return printImmutableEntries(val,config,indentation,depth,refs,printer,val[IS_ORDERED_SENTINEL$1]?'OrderedMap':'Map');}if(val[IS_LIST_SENTINEL]){return printImmutableValues(val,config,indentation,depth,refs,printer,'List');}if(val[IS_SET_SENTINEL$1]){return printImmutableValues(val,config,indentation,depth,refs,printer,val[IS_ORDERED_SENTINEL$1]?'OrderedSet':'Set');}if(val[IS_STACK_SENTINEL]){return printImmutableValues(val,config,indentation,depth,refs,printer,'Stack');}if(val[IS_SEQ_SENTINEL]){return printImmutableSeq(val,config,indentation,depth,refs,printer);}// For compatibility with immutable v3 and v4, let record be the default.
return printImmutableRecord(val,config,indentation,depth,refs,printer);};// Explicitly comparing sentinel properties to true avoids false positive
// when mock identity-obj-proxy returns the key as the value for any key.
Immutable$3.serialize=serialize$4;const test$4=val=>val&&(val[IS_ITERABLE_SENTINEL]===true||val[IS_RECORD_SENTINEL]===true);Immutable$3.test=test$4;const plugin$3={serialize:serialize$4,test:test$4};var _default$4=plugin$3;Immutable$3.default=_default$4;var ReactElement$3={};var reactIs={exports:{}};var reactIs_production_min={};/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactIs_production_min;function requireReactIs_production_min(){if(hasRequiredReactIs_production_min)return reactIs_production_min;hasRequiredReactIs_production_min=1;var b=Symbol.for("react.element"),c=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),e=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),g=Symbol.for("react.provider"),h=Symbol.for("react.context"),k=Symbol.for("react.server_context"),l=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),n=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),t=Symbol.for("react.offscreen"),u;u=Symbol.for("react.module.reference");function v(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r;}}case c:return r;}}}reactIs_production_min.ContextConsumer=h;reactIs_production_min.ContextProvider=g;reactIs_production_min.Element=b;reactIs_production_min.ForwardRef=l;reactIs_production_min.Fragment=d;reactIs_production_min.Lazy=q;reactIs_production_min.Memo=p;reactIs_production_min.Portal=c;reactIs_production_min.Profiler=f;reactIs_production_min.StrictMode=e;reactIs_production_min.Suspense=m;reactIs_production_min.SuspenseList=n;reactIs_production_min.isAsyncMode=function(){return!1;};reactIs_production_min.isConcurrentMode=function(){return!1;};reactIs_production_min.isContextConsumer=function(a){return v(a)===h;};reactIs_production_min.isContextProvider=function(a){return v(a)===g;};reactIs_production_min.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===b;};reactIs_production_min.isForwardRef=function(a){return v(a)===l;};reactIs_production_min.isFragment=function(a){return v(a)===d;};reactIs_production_min.isLazy=function(a){return v(a)===q;};reactIs_production_min.isMemo=function(a){return v(a)===p;};reactIs_production_min.isPortal=function(a){return v(a)===c;};reactIs_production_min.isProfiler=function(a){return v(a)===f;};reactIs_production_min.isStrictMode=function(a){return v(a)===e;};reactIs_production_min.isSuspense=function(a){return v(a)===m;};reactIs_production_min.isSuspenseList=function(a){return v(a)===n;};reactIs_production_min.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||"object"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1;};reactIs_production_min.typeOf=v;return reactIs_production_min;}var reactIs_development={};/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactIs_development;function requireReactIs_development(){if(hasRequiredReactIs_development)return reactIs_development;hasRequiredReactIs_development=1;if(process.env.NODE_ENV!=="production"){(function(){// -----------------------------------------------------------------------------
var enableScopeAPI=false;// Experimental Create Event Handle API.
var enableCacheElement=false;var enableTransitionTracing=false;// No known bugs, but needs performance testing
var enableLegacyHidden=false;// Enables unstable_avoidThisFallback feature in Fiber
// stuff. Intended to enable React core members to more easily debug scheduling
// issues in DEV builds.
var enableDebugTracing=false;// Track which Fiber(s) schedule render work.
// ATTENTION
var REACT_ELEMENT_TYPE=Symbol.for('react.element');var REACT_PORTAL_TYPE=Symbol.for('react.portal');var REACT_FRAGMENT_TYPE=Symbol.for('react.fragment');var REACT_STRICT_MODE_TYPE=Symbol.for('react.strict_mode');var REACT_PROFILER_TYPE=Symbol.for('react.profiler');var REACT_PROVIDER_TYPE=Symbol.for('react.provider');var REACT_CONTEXT_TYPE=Symbol.for('react.context');var REACT_SERVER_CONTEXT_TYPE=Symbol.for('react.server_context');var REACT_FORWARD_REF_TYPE=Symbol.for('react.forward_ref');var REACT_SUSPENSE_TYPE=Symbol.for('react.suspense');var REACT_SUSPENSE_LIST_TYPE=Symbol.for('react.suspense_list');var REACT_MEMO_TYPE=Symbol.for('react.memo');var REACT_LAZY_TYPE=Symbol.for('react.lazy');var REACT_OFFSCREEN_TYPE=Symbol.for('react.offscreen');var REACT_MODULE_REFERENCE;{REACT_MODULE_REFERENCE=Symbol.for('react.module.reference');}function isValidElementType(type){if(typeof type==='string'||typeof type==='function'){return true;}// Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).
if(type===REACT_FRAGMENT_TYPE||type===REACT_PROFILER_TYPE||enableDebugTracing||type===REACT_STRICT_MODE_TYPE||type===REACT_SUSPENSE_TYPE||type===REACT_SUSPENSE_LIST_TYPE||enableLegacyHidden||type===REACT_OFFSCREEN_TYPE||enableScopeAPI||enableCacheElement||enableTransitionTracing){return true;}if(typeof type==='object'&&type!==null){if(type.$$typeof===REACT_LAZY_TYPE||type.$$typeof===REACT_MEMO_TYPE||type.$$typeof===REACT_PROVIDER_TYPE||type.$$typeof===REACT_CONTEXT_TYPE||type.$$typeof===REACT_FORWARD_REF_TYPE||// This needs to include all possible module reference object
// types supported by any Flight configuration anywhere since
// we don't know which Flight build this will end up being used
// with.
type.$$typeof===REACT_MODULE_REFERENCE||type.getModuleId!==undefined){return true;}}return false;}function typeOf(object){if(typeof object==='object'&&object!==null){var $$typeof=object.$$typeof;switch($$typeof){case REACT_ELEMENT_TYPE:var type=object.type;switch(type){case REACT_FRAGMENT_TYPE:case REACT_PROFILER_TYPE:case REACT_STRICT_MODE_TYPE:case REACT_SUSPENSE_TYPE:case REACT_SUSPENSE_LIST_TYPE:return type;default:var $$typeofType=type&&type.$$typeof;switch($$typeofType){case REACT_SERVER_CONTEXT_TYPE:case REACT_CONTEXT_TYPE:case REACT_FORWARD_REF_TYPE:case REACT_LAZY_TYPE:case REACT_MEMO_TYPE:case REACT_PROVIDER_TYPE:return $$typeofType;default:return $$typeof;}}case REACT_PORTAL_TYPE:return $$typeof;}}return undefined;}var ContextConsumer=REACT_CONTEXT_TYPE;var ContextProvider=REACT_PROVIDER_TYPE;var Element=REACT_ELEMENT_TYPE;var ForwardRef=REACT_FORWARD_REF_TYPE;var Fragment=REACT_FRAGMENT_TYPE;var Lazy=REACT_LAZY_TYPE;var Memo=REACT_MEMO_TYPE;var Portal=REACT_PORTAL_TYPE;var Profiler=REACT_PROFILER_TYPE;var StrictMode=REACT_STRICT_MODE_TYPE;var Suspense=REACT_SUSPENSE_TYPE;var SuspenseList=REACT_SUSPENSE_LIST_TYPE;var hasWarnedAboutDeprecatedIsAsyncMode=false;var hasWarnedAboutDeprecatedIsConcurrentMode=false;// AsyncMode should be deprecated
function isAsyncMode(object){{if(!hasWarnedAboutDeprecatedIsAsyncMode){hasWarnedAboutDeprecatedIsAsyncMode=true;// Using console['warn'] to evade Babel and ESLint
console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, '+'and will be removed in React 18+.');}}return false;}function isConcurrentMode(object){{if(!hasWarnedAboutDeprecatedIsConcurrentMode){hasWarnedAboutDeprecatedIsConcurrentMode=true;// Using console['warn'] to evade Babel and ESLint
console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, '+'and will be removed in React 18+.');}}return false;}function isContextConsumer(object){return typeOf(object)===REACT_CONTEXT_TYPE;}function isContextProvider(object){return typeOf(object)===REACT_PROVIDER_TYPE;}function isElement(object){return typeof object==='object'&&object!==null&&object.$$typeof===REACT_ELEMENT_TYPE;}function isForwardRef(object){return typeOf(object)===REACT_FORWARD_REF_TYPE;}function isFragment(object){return typeOf(object)===REACT_FRAGMENT_TYPE;}function isLazy(object){return typeOf(object)===REACT_LAZY_TYPE;}function isMemo(object){return typeOf(object)===REACT_MEMO_TYPE;}function isPortal(object){return typeOf(object)===REACT_PORTAL_TYPE;}function isProfiler(object){return typeOf(object)===REACT_PROFILER_TYPE;}function isStrictMode(object){return typeOf(object)===REACT_STRICT_MODE_TYPE;}function isSuspense(object){return typeOf(object)===REACT_SUSPENSE_TYPE;}function isSuspenseList(object){return typeOf(object)===REACT_SUSPENSE_LIST_TYPE;}reactIs_development.ContextConsumer=ContextConsumer;reactIs_development.ContextProvider=ContextProvider;reactIs_development.Element=Element;reactIs_development.ForwardRef=ForwardRef;reactIs_development.Fragment=Fragment;reactIs_development.Lazy=Lazy;reactIs_development.Memo=Memo;reactIs_development.Portal=Portal;reactIs_development.Profiler=Profiler;reactIs_development.StrictMode=StrictMode;reactIs_development.Suspense=Suspense;reactIs_development.SuspenseList=SuspenseList;reactIs_development.isAsyncMode=isAsyncMode;reactIs_development.isConcurrentMode=isConcurrentMode;reactIs_development.isContextConsumer=isContextConsumer;reactIs_development.isContextProvider=isContextProvider;reactIs_development.isElement=isElement;reactIs_development.isForwardRef=isForwardRef;reactIs_development.isFragment=isFragment;reactIs_development.isLazy=isLazy;reactIs_development.isMemo=isMemo;reactIs_development.isPortal=isPortal;reactIs_development.isProfiler=isProfiler;reactIs_development.isStrictMode=isStrictMode;reactIs_development.isSuspense=isSuspense;reactIs_development.isSuspenseList=isSuspenseList;reactIs_development.isValidElementType=isValidElementType;reactIs_development.typeOf=typeOf;})();}return reactIs_development;}if(process.env.NODE_ENV==='production'){reactIs.exports=requireReactIs_production_min();}else{reactIs.exports=requireReactIs_development();}var reactIsExports=reactIs.exports;Object.defineProperty(ReactElement$3,'__esModule',{value:true});ReactElement$3.test=ReactElement$3.serialize=ReactElement$3.default=void 0;var ReactIs=_interopRequireWildcard(reactIsExports);var _markup$1=markup;function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!=='function')return null;var cacheBabelInterop=new WeakMap();var cacheNodeInterop=new WeakMap();return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj;}if(obj===null||typeof obj!=='object'&&typeof obj!=='function'){return{default:obj};}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj);}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!=='default'&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}newObj.default=obj;if(cache){cache.set(obj,newObj);}return newObj;}/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Given element.props.children, or subtree during recursive traversal,
// return flattened array of children.
const getChildren=(arg,children=[])=>{if(Array.isArray(arg)){arg.forEach(item=>{getChildren(item,children);});}else if(arg!=null&&arg!==false){children.push(arg);}return children;};const getType$1=element=>{const type=element.type;if(typeof type==='string'){return type;}if(typeof type==='function'){return type.displayName||type.name||'Unknown';}if(ReactIs.isFragment(element)){return'React.Fragment';}if(ReactIs.isSuspense(element)){return'React.Suspense';}if(typeof type==='object'&&type!==null){if(ReactIs.isContextProvider(element)){return'Context.Provider';}if(ReactIs.isContextConsumer(element)){return'Context.Consumer';}if(ReactIs.isForwardRef(element)){if(type.displayName){return type.displayName;}const functionName=type.render.displayName||type.render.name||'';return functionName!==''?\`ForwardRef(\${functionName})\`:'ForwardRef';}if(ReactIs.isMemo(element)){const functionName=type.displayName||type.type.displayName||type.type.name||'';return functionName!==''?\`Memo(\${functionName})\`:'Memo';}}return'UNDEFINED';};const getPropKeys$1=element=>{const props=element.props;return Object.keys(props).filter(key=>key!=='children'&&props[key]!==undefined).sort();};const serialize$3=(element,config,indentation,depth,refs,printer)=>++depth>config.maxDepth?(0,_markup$1.printElementAsLeaf)(getType$1(element),config):(0,_markup$1.printElement)(getType$1(element),(0,_markup$1.printProps)(getPropKeys$1(element),element.props,config,indentation+config.indent,depth,refs,printer),(0,_markup$1.printChildren)(getChildren(element.props.children),config,indentation+config.indent,depth,refs,printer),config,indentation);ReactElement$3.serialize=serialize$3;const test$3=val=>val!=null&&ReactIs.isElement(val);ReactElement$3.test=test$3;const plugin$2={serialize:serialize$3,test:test$3};var _default$3=plugin$2;ReactElement$3.default=_default$3;var ReactTestComponent$3={};Object.defineProperty(ReactTestComponent$3,'__esModule',{value:true});ReactTestComponent$3.test=ReactTestComponent$3.serialize=ReactTestComponent$3.default=void 0;var _markup=markup;var Symbol$1=globalThis['jest-symbol-do-not-touch']||globalThis.Symbol;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Child can be \`number\` in Stack renderer but not in Fiber renderer.
const testSymbol=typeof Symbol$1==='function'&&Symbol$1.for?Symbol$1.for('react.test.json'):0xea71357;const getPropKeys=object=>{const props=object.props;return props?Object.keys(props).filter(key=>props[key]!==undefined).sort():[];};const serialize$2=(object,config,indentation,depth,refs,printer)=>++depth>config.maxDepth?(0,_markup.printElementAsLeaf)(object.type,config):(0,_markup.printElement)(object.type,object.props?(0,_markup.printProps)(getPropKeys(object),object.props,config,indentation+config.indent,depth,refs,printer):'',object.children?(0,_markup.printChildren)(object.children,config,indentation+config.indent,depth,refs,printer):'',config,indentation);ReactTestComponent$3.serialize=serialize$2;const test$2=val=>val&&val.$$typeof===testSymbol;ReactTestComponent$3.test=test$2;const plugin$1={serialize:serialize$2,test:test$2};var _default$2=plugin$1;ReactTestComponent$3.default=_default$2;Object.defineProperty(build$1,'__esModule',{value:true});build$1.default=build$1.DEFAULT_OPTIONS=void 0;var format_1=build$1.format=format$1;var plugins_1=build$1.plugins=void 0;var _ansiStyles=_interopRequireDefault(ansiStylesExports);var _collections=collections;var _AsymmetricMatcher=_interopRequireDefault(AsymmetricMatcher$4);var _DOMCollection=_interopRequireDefault(DOMCollection$3);var _DOMElement=_interopRequireDefault(DOMElement$3);var _Immutable=_interopRequireDefault(Immutable$3);var _ReactElement=_interopRequireDefault(ReactElement$3);var _ReactTestComponent=_interopRequireDefault(ReactTestComponent$3);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ /* eslint-disable local/ban-types-eventually */const toString$2=Object.prototype.toString;const toISOString=Date.prototype.toISOString;const errorToString=Error.prototype.toString;const regExpToString=RegExp.prototype.toString;/**
 * Explicitly comparing typeof constructor to function avoids undefined as name
 * when mock identity-obj-proxy returns the key as the value for any key.
 */const getConstructorName$1=val=>typeof val.constructor==='function'&&val.constructor.name||'Object';/* global window */ /** Is val is equal to global window object? Works even if it does not exist :) */const isWindow=val=>typeof window!=='undefined'&&val===window;const SYMBOL_REGEXP=/^Symbol\\((.*)\\)(.*)$/;const NEWLINE_REGEXP=/\\n/gi;class PrettyFormatPluginError extends Error{constructor(message,stack){super(message);this.stack=stack;this.name=this.constructor.name;}}function isToStringedArrayType(toStringed){return toStringed==='[object Array]'||toStringed==='[object ArrayBuffer]'||toStringed==='[object DataView]'||toStringed==='[object Float32Array]'||toStringed==='[object Float64Array]'||toStringed==='[object Int8Array]'||toStringed==='[object Int16Array]'||toStringed==='[object Int32Array]'||toStringed==='[object Uint8Array]'||toStringed==='[object Uint8ClampedArray]'||toStringed==='[object Uint16Array]'||toStringed==='[object Uint32Array]';}function printNumber(val){return Object.is(val,-0)?'-0':String(val);}function printBigInt(val){return String(\`\${val}n\`);}function printFunction(val,printFunctionName){if(!printFunctionName){return'[Function]';}return\`[Function \${val.name||'anonymous'}]\`;}function printSymbol(val){return String(val).replace(SYMBOL_REGEXP,'Symbol($1)');}function printError(val){return\`[\${errorToString.call(val)}]\`;}/**
 * The first port of call for printing an object, handles most of the
 * data-types in JS.
 */function printBasicValue(val,printFunctionName,escapeRegex,escapeString){if(val===true||val===false){return\`\${val}\`;}if(val===undefined){return'undefined';}if(val===null){return'null';}const typeOf=typeof val;if(typeOf==='number'){return printNumber(val);}if(typeOf==='bigint'){return printBigInt(val);}if(typeOf==='string'){if(escapeString){return\`"\${val.replace(/"|\\\\/g,'\\\\$&')}"\`;}return\`"\${val}"\`;}if(typeOf==='function'){return printFunction(val,printFunctionName);}if(typeOf==='symbol'){return printSymbol(val);}const toStringed=toString$2.call(val);if(toStringed==='[object WeakMap]'){return'WeakMap {}';}if(toStringed==='[object WeakSet]'){return'WeakSet {}';}if(toStringed==='[object Function]'||toStringed==='[object GeneratorFunction]'){return printFunction(val,printFunctionName);}if(toStringed==='[object Symbol]'){return printSymbol(val);}if(toStringed==='[object Date]'){return isNaN(+val)?'Date { NaN }':toISOString.call(val);}if(toStringed==='[object Error]'){return printError(val);}if(toStringed==='[object RegExp]'){if(escapeRegex){// https://github.com/benjamingr/RegExp.escape/blob/main/polyfill.js
return regExpToString.call(val).replace(/[\\\\^$*+?.()|[\\]{}]/g,'\\\\$&');}return regExpToString.call(val);}if(val instanceof Error){return printError(val);}return null;}/**
 * Handles more complex objects ( such as objects with circular references.
 * maps and sets etc )
 */function printComplexValue(val,config,indentation,depth,refs,hasCalledToJSON){if(refs.indexOf(val)!==-1){return'[Circular]';}refs=refs.slice();refs.push(val);const hitMaxDepth=++depth>config.maxDepth;const min=config.min;if(config.callToJSON&&!hitMaxDepth&&val.toJSON&&typeof val.toJSON==='function'&&!hasCalledToJSON){return printer(val.toJSON(),config,indentation,depth,refs,true);}const toStringed=toString$2.call(val);if(toStringed==='[object Arguments]'){return hitMaxDepth?'[Arguments]':\`\${min?'':'Arguments '}[\${(0,_collections.printListItems)(val,config,indentation,depth,refs,printer)}]\`;}if(isToStringedArrayType(toStringed)){return hitMaxDepth?\`[\${val.constructor.name}]\`:\`\${min?'':!config.printBasicPrototype&&val.constructor.name==='Array'?'':\`\${val.constructor.name} \`}[\${(0,_collections.printListItems)(val,config,indentation,depth,refs,printer)}]\`;}if(toStringed==='[object Map]'){return hitMaxDepth?'[Map]':\`Map {\${(0,_collections.printIteratorEntries)(val.entries(),config,indentation,depth,refs,printer,' => ')}}\`;}if(toStringed==='[object Set]'){return hitMaxDepth?'[Set]':\`Set {\${(0,_collections.printIteratorValues)(val.values(),config,indentation,depth,refs,printer)}}\`;}// Avoid failure to serialize global window object in jsdom test environment.
// For example, not even relevant if window is prop of React element.
return hitMaxDepth||isWindow(val)?\`[\${getConstructorName$1(val)}]\`:\`\${min?'':!config.printBasicPrototype&&getConstructorName$1(val)==='Object'?'':\`\${getConstructorName$1(val)} \`}{\${(0,_collections.printObjectProperties)(val,config,indentation,depth,refs,printer)}}\`;}function isNewPlugin(plugin){return plugin.serialize!=null;}function printPlugin(plugin,val,config,indentation,depth,refs){let printed;try{printed=isNewPlugin(plugin)?plugin.serialize(val,config,indentation,depth,refs,printer):plugin.print(val,valChild=>printer(valChild,config,indentation,depth,refs),str=>{const indentationNext=indentation+config.indent;return indentationNext+str.replace(NEWLINE_REGEXP,\`\\n\${indentationNext}\`);},{edgeSpacing:config.spacingOuter,min:config.min,spacing:config.spacingInner},config.colors);}catch(error){throw new PrettyFormatPluginError(error.message,error.stack);}if(typeof printed!=='string'){throw new Error(\`pretty-format: Plugin must return type "string" but instead returned "\${typeof printed}".\`);}return printed;}function findPlugin(plugins,val){for(let p=0;p<plugins.length;p++){try{if(plugins[p].test(val)){return plugins[p];}}catch(error){throw new PrettyFormatPluginError(error.message,error.stack);}}return null;}function printer(val,config,indentation,depth,refs,hasCalledToJSON){const plugin=findPlugin(config.plugins,val);if(plugin!==null){return printPlugin(plugin,val,config,indentation,depth,refs);}const basicResult=printBasicValue(val,config.printFunctionName,config.escapeRegex,config.escapeString);if(basicResult!==null){return basicResult;}return printComplexValue(val,config,indentation,depth,refs,hasCalledToJSON);}const DEFAULT_THEME={comment:'gray',content:'reset',prop:'yellow',tag:'cyan',value:'green'};const DEFAULT_THEME_KEYS=Object.keys(DEFAULT_THEME);// could be replaced by \`satisfies\` operator in the future: https://github.com/microsoft/TypeScript/issues/47920
const toOptionsSubtype=options=>options;const DEFAULT_OPTIONS=toOptionsSubtype({callToJSON:true,compareKeys:undefined,escapeRegex:false,escapeString:true,highlight:false,indent:2,maxDepth:Infinity,maxWidth:Infinity,min:false,plugins:[],printBasicPrototype:true,printFunctionName:true,theme:DEFAULT_THEME});build$1.DEFAULT_OPTIONS=DEFAULT_OPTIONS;function validateOptions(options){Object.keys(options).forEach(key=>{if(!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS,key)){throw new Error(\`pretty-format: Unknown option "\${key}".\`);}});if(options.min&&options.indent!==undefined&&options.indent!==0){throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');}if(options.theme!==undefined){if(options.theme===null){throw new Error('pretty-format: Option "theme" must not be null.');}if(typeof options.theme!=='object'){throw new Error(\`pretty-format: Option "theme" must be of type "object" but instead received "\${typeof options.theme}".\`);}}}const getColorsHighlight=options=>DEFAULT_THEME_KEYS.reduce((colors,key)=>{const value=options.theme&&options.theme[key]!==undefined?options.theme[key]:DEFAULT_THEME[key];const color=value&&_ansiStyles.default[value];if(color&&typeof color.close==='string'&&typeof color.open==='string'){colors[key]=color;}else{throw new Error(\`pretty-format: Option "theme" has a key "\${key}" whose value "\${value}" is undefined in ansi-styles.\`);}return colors;},Object.create(null));const getColorsEmpty=()=>DEFAULT_THEME_KEYS.reduce((colors,key)=>{colors[key]={close:'',open:''};return colors;},Object.create(null));const getPrintFunctionName=options=>options?.printFunctionName??DEFAULT_OPTIONS.printFunctionName;const getEscapeRegex=options=>options?.escapeRegex??DEFAULT_OPTIONS.escapeRegex;const getEscapeString=options=>options?.escapeString??DEFAULT_OPTIONS.escapeString;const getConfig=options=>({callToJSON:options?.callToJSON??DEFAULT_OPTIONS.callToJSON,colors:options?.highlight?getColorsHighlight(options):getColorsEmpty(),compareKeys:typeof options?.compareKeys==='function'||options?.compareKeys===null?options.compareKeys:DEFAULT_OPTIONS.compareKeys,escapeRegex:getEscapeRegex(options),escapeString:getEscapeString(options),indent:options?.min?'':createIndent(options?.indent??DEFAULT_OPTIONS.indent),maxDepth:options?.maxDepth??DEFAULT_OPTIONS.maxDepth,maxWidth:options?.maxWidth??DEFAULT_OPTIONS.maxWidth,min:options?.min??DEFAULT_OPTIONS.min,plugins:options?.plugins??DEFAULT_OPTIONS.plugins,printBasicPrototype:options?.printBasicPrototype??true,printFunctionName:getPrintFunctionName(options),spacingInner:options?.min?' ':'\\n',spacingOuter:options?.min?'':'\\n'});function createIndent(indent){return new Array(indent+1).join(' ');}/**
 * Returns a presentation string of your \`val\` object
 * @param val any potential JavaScript object
 * @param options Custom settings
 */function format$1(val,options){if(options){validateOptions(options);if(options.plugins){const plugin=findPlugin(options.plugins,val);if(plugin!==null){return printPlugin(plugin,val,getConfig(options),'',0,[]);}}}const basicResult=printBasicValue(val,getPrintFunctionName(options),getEscapeRegex(options),getEscapeString(options));if(basicResult!==null){return basicResult;}return printComplexValue(val,getConfig(options),'',0,[]);}const plugins={AsymmetricMatcher:_AsymmetricMatcher.default,DOMCollection:_DOMCollection.default,DOMElement:_DOMElement.default,Immutable:_Immutable.default,ReactElement:_ReactElement.default,ReactTestComponent:_ReactTestComponent.default};plugins_1=build$1.plugins=plugins;var _default$1=format$1;build$1.default=_default$1;const ansiColors={bold:['1','22'],dim:['2','22'],italic:['3','23'],underline:['4','24'],// 5 & 6 are blinking
inverse:['7','27'],hidden:['8','28'],strike:['9','29'],// 10-20 are fonts
// 21-29 are resets for 1-9
black:['30','39'],red:['31','39'],green:['32','39'],yellow:['33','39'],blue:['34','39'],magenta:['35','39'],cyan:['36','39'],white:['37','39'],brightblack:['30;1','39'],brightred:['31;1','39'],brightgreen:['32;1','39'],brightyellow:['33;1','39'],brightblue:['34;1','39'],brightmagenta:['35;1','39'],brightcyan:['36;1','39'],brightwhite:['37;1','39'],grey:['90','39']};const styles={special:'cyan',number:'yellow',bigint:'yellow',boolean:'yellow',undefined:'grey',null:'bold',string:'green',symbol:'green',date:'magenta',regexp:'red'};const truncator='…';function colorise(value,styleType){const color=ansiColors[styles[styleType]]||ansiColors[styleType];if(!color){return String(value);}return\`\\u001b[\${color[0]}m\${String(value)}\\u001b[\${color[1]}m\`;}function normaliseOptions({showHidden=false,depth=2,colors=false,customInspect=true,showProxy=false,maxArrayLength=Infinity,breakLength=Infinity,seen=[],// eslint-disable-next-line no-shadow
truncate=Infinity,stylize=String}={}){const options={showHidden:Boolean(showHidden),depth:Number(depth),colors:Boolean(colors),customInspect:Boolean(customInspect),showProxy:Boolean(showProxy),maxArrayLength:Number(maxArrayLength),breakLength:Number(breakLength),truncate:Number(truncate),seen,stylize};if(options.colors){options.stylize=colorise;}return options;}function truncate(string,length,tail=truncator){string=String(string);const tailLength=tail.length;const stringLength=string.length;if(tailLength>length&&stringLength>tailLength){return tail;}if(stringLength>length&&stringLength>tailLength){return\`\${string.slice(0,length-tailLength)}\${tail}\`;}return string;}// eslint-disable-next-line complexity
function inspectList(list,options,inspectItem,separator=', '){inspectItem=inspectItem||options.inspect;const size=list.length;if(size===0)return'';const originalLength=options.truncate;let output='';let peek='';let truncated='';for(let i=0;i<size;i+=1){const last=i+1===list.length;const secondToLast=i+2===list.length;truncated=\`\${truncator}(\${list.length-i})\`;const value=list[i];// If there is more than one remaining we need to account for a separator of \`, \`
options.truncate=originalLength-output.length-(last?0:separator.length);const string=peek||inspectItem(value,options)+(last?'':separator);const nextLength=output.length+string.length;const truncatedLength=nextLength+truncated.length;// If this is the last element, and adding it would
// take us over length, but adding the truncator wouldn't - then break now
if(last&&nextLength>originalLength&&output.length+truncated.length<=originalLength){break;}// If this isn't the last or second to last element to scan,
// but the string is already over length then break here
if(!last&&!secondToLast&&truncatedLength>originalLength){break;}// Peek at the next string to determine if we should
// break early before adding this item to the output
peek=last?'':inspectItem(list[i+1],options)+(secondToLast?'':separator);// If we have one element left, but this element and
// the next takes over length, the break early
if(!last&&secondToLast&&truncatedLength>originalLength&&nextLength+peek.length>originalLength){break;}output+=string;// If the next element takes us to length -
// but there are more after that, then we should truncate now
if(!last&&!secondToLast&&nextLength+peek.length>=originalLength){truncated=\`\${truncator}(\${list.length-i-1})\`;break;}truncated='';}return\`\${output}\${truncated}\`;}function quoteComplexKey(key){if(key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)){return key;}return JSON.stringify(key).replace(/'/g,"\\\\'").replace(/\\\\"/g,'"').replace(/(^"|"$)/g,"'");}function inspectProperty([key,value],options){options.truncate-=2;if(typeof key==='string'){key=quoteComplexKey(key);}else if(typeof key!=='number'){key=\`[\${options.inspect(key,options)}]\`;}options.truncate-=key.length;value=options.inspect(value,options);return\`\${key}: \${value}\`;}function inspectArray(array,options){// Object.keys will always output the Array indices first, so we can slice by
// \`array.length\` to get non-index properties
const nonIndexProperties=Object.keys(array).slice(array.length);if(!array.length&&!nonIndexProperties.length)return'[]';options.truncate-=4;const listContents=inspectList(array,options);options.truncate-=listContents.length;let propertyContents='';if(nonIndexProperties.length){propertyContents=inspectList(nonIndexProperties.map(key=>[key,array[key]]),options,inspectProperty);}return\`[ \${listContents}\${propertyContents?\`, \${propertyContents}\`:''} ]\`;}/* !
 * Chai - getFuncName utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .getFuncName(constructorFn)
 *
 * Returns the name of a function.
 * When a non-function instance is passed, returns \`null\`.
 * This also includes a polyfill function if \`aFunc.name\` is not defined.
 *
 * @name getFuncName
 * @param {Function} funct
 * @namespace Utils
 * @api public
 */var toString$1=Function.prototype.toString;var functionNameMatch=/\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\s\\(\\/]+)/;var maxFunctionSourceLength=512;function getFuncName(aFunc){if(typeof aFunc!=='function'){return null;}var name='';if(typeof Function.prototype.name==='undefined'&&typeof aFunc.name==='undefined'){// eslint-disable-next-line prefer-reflect
var functionSource=toString$1.call(aFunc);// To avoid unconstrained resource consumption due to pathalogically large function names,
// we limit the available return value to be less than 512 characters.
if(functionSource.indexOf('(')>maxFunctionSourceLength){return name;}// Here we run a polyfill if Function does not support the \`name\` property and if aFunc.name is not defined
var match=functionSource.match(functionNameMatch);if(match){name=match[1];}}else{// If we've got a \`name\` property we just use it
name=aFunc.name;}return name;}var getFuncName_1=getFuncName;const getFuncName$1=/*@__PURE__*/getDefaultExportFromCjs$2(getFuncName_1);const getArrayName=array=>{// We need to special case Node.js' Buffers, which report to be Uint8Array
if(typeof Buffer==='function'&&array instanceof Buffer){return'Buffer';}if(array[Symbol.toStringTag]){return array[Symbol.toStringTag];}return getFuncName$1(array.constructor);};function inspectTypedArray(array,options){const name=getArrayName(array);options.truncate-=name.length+4;// Object.keys will always output the Array indices first, so we can slice by
// \`array.length\` to get non-index properties
const nonIndexProperties=Object.keys(array).slice(array.length);if(!array.length&&!nonIndexProperties.length)return\`\${name}[]\`;// As we know TypedArrays only contain Unsigned Integers, we can skip inspecting each one and simply
// stylise the toString() value of them
let output='';for(let i=0;i<array.length;i++){const string=\`\${options.stylize(truncate(array[i],options.truncate),'number')}\${i===array.length-1?'':', '}\`;options.truncate-=string.length;if(array[i]!==array.length&&options.truncate<=3){output+=\`\${truncator}(\${array.length-array[i]+1})\`;break;}output+=string;}let propertyContents='';if(nonIndexProperties.length){propertyContents=inspectList(nonIndexProperties.map(key=>[key,array[key]]),options,inspectProperty);}return\`\${name}[ \${output}\${propertyContents?\`, \${propertyContents}\`:''} ]\`;}function inspectDate(dateObject,options){const stringRepresentation=dateObject.toJSON();if(stringRepresentation===null){return'Invalid Date';}const split=stringRepresentation.split('T');const date=split[0];// If we need to - truncate the time portion, but never the date
return options.stylize(\`\${date}T\${truncate(split[1],options.truncate-date.length-1)}\`,'date');}function inspectFunction(func,options){const name=getFuncName$1(func);if(!name){return options.stylize('[Function]','special');}return options.stylize(\`[Function \${truncate(name,options.truncate-11)}]\`,'special');}function inspectMapEntry([key,value],options){options.truncate-=4;key=options.inspect(key,options);options.truncate-=key.length;value=options.inspect(value,options);return\`\${key} => \${value}\`;}// IE11 doesn't support \`map.entries()\`
function mapToEntries(map){const entries=[];map.forEach((value,key)=>{entries.push([key,value]);});return entries;}function inspectMap(map,options){const size=map.size-1;if(size<=0){return'Map{}';}options.truncate-=7;return\`Map{ \${inspectList(mapToEntries(map),options,inspectMapEntry)} }\`;}const isNaN$2=Number.isNaN||(i=>i!==i);// eslint-disable-line no-self-compare
function inspectNumber(number,options){if(isNaN$2(number)){return options.stylize('NaN','number');}if(number===Infinity){return options.stylize('Infinity','number');}if(number===-Infinity){return options.stylize('-Infinity','number');}if(number===0){return options.stylize(1/number===Infinity?'+0':'-0','number');}return options.stylize(truncate(number,options.truncate),'number');}function inspectBigInt(number,options){let nums=truncate(number.toString(),options.truncate-1);if(nums!==truncator)nums+='n';return options.stylize(nums,'bigint');}function inspectRegExp(value,options){const flags=value.toString().split('/')[2];const sourceLength=options.truncate-(2+flags.length);const source=value.source;return options.stylize(\`/\${truncate(source,sourceLength)}/\${flags}\`,'regexp');}// IE11 doesn't support \`Array.from(set)\`
function arrayFromSet(set){const values=[];set.forEach(value=>{values.push(value);});return values;}function inspectSet(set,options){if(set.size===0)return'Set{}';options.truncate-=7;return\`Set{ \${inspectList(arrayFromSet(set),options)} }\`;}const stringEscapeChars=new RegExp("['\\\\u0000-\\\\u001f\\\\u007f-\\\\u009f\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5"+'\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]','g');const escapeCharacters={'\\b':'\\\\b','\\t':'\\\\t','\\n':'\\\\n','\\f':'\\\\f','\\r':'\\\\r',"'":"\\\\'",'\\\\':'\\\\\\\\'};const hex=16;const unicodeLength=4;function escape(char){return escapeCharacters[char]||\`\\\\u\${\`0000\${char.charCodeAt(0).toString(hex)}\`.slice(-unicodeLength)}\`;}function inspectString(string,options){if(stringEscapeChars.test(string)){string=string.replace(stringEscapeChars,escape);}return options.stylize(\`'\${truncate(string,options.truncate-2)}'\`,'string');}function inspectSymbol(value){if('description'in Symbol.prototype){return value.description?\`Symbol(\${value.description})\`:'Symbol()';}return value.toString();}let getPromiseValue$1=()=>'Promise{…}';try{const _process$binding=process.binding('util'),getPromiseDetails=_process$binding.getPromiseDetails,kPending=_process$binding.kPending,kRejected=_process$binding.kRejected;if(Array.isArray(getPromiseDetails(Promise.resolve()))){getPromiseValue$1=(value,options)=>{const _getPromiseDetails=getPromiseDetails(value),_getPromiseDetails2=_slicedToArray(_getPromiseDetails,2),state=_getPromiseDetails2[0],innerValue=_getPromiseDetails2[1];if(state===kPending){return'Promise{<pending>}';}return\`Promise\${state===kRejected?'!':''}{\${options.inspect(innerValue,options)}}\`;};}}catch(notNode){/* ignore */}const inspectPromise=getPromiseValue$1;function inspectObject$1(object,options){const properties=Object.getOwnPropertyNames(object);const symbols=Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(object):[];if(properties.length===0&&symbols.length===0){return'{}';}options.truncate-=4;options.seen=options.seen||[];if(options.seen.indexOf(object)>=0){return'[Circular]';}options.seen.push(object);const propertyContents=inspectList(properties.map(key=>[key,object[key]]),options,inspectProperty);const symbolContents=inspectList(symbols.map(key=>[key,object[key]]),options,inspectProperty);options.seen.pop();let sep='';if(propertyContents&&symbolContents){sep=', ';}return\`{ \${propertyContents}\${sep}\${symbolContents} }\`;}const toStringTag=typeof Symbol!=='undefined'&&Symbol.toStringTag?Symbol.toStringTag:false;function inspectClass(value,options){let name='';if(toStringTag&&toStringTag in value){name=value[toStringTag];}name=name||getFuncName$1(value.constructor);// Babel transforms anonymous classes to the name \`_class\`
if(!name||name==='_class'){name='<Anonymous Class>';}options.truncate-=name.length;return\`\${name}\${inspectObject$1(value,options)}\`;}function inspectArguments(args,options){if(args.length===0)return'Arguments[]';options.truncate-=13;return\`Arguments[ \${inspectList(args,options)} ]\`;}const errorKeys=['stack','line','column','name','message','fileName','lineNumber','columnNumber','number','description'];function inspectObject(error,options){const properties=Object.getOwnPropertyNames(error).filter(key=>errorKeys.indexOf(key)===-1);const name=error.name;options.truncate-=name.length;let message='';if(typeof error.message==='string'){message=truncate(error.message,options.truncate);}else{properties.unshift('message');}message=message?\`: \${message}\`:'';options.truncate-=message.length+5;const propertyContents=inspectList(properties.map(key=>[key,error[key]]),options,inspectProperty);return\`\${name}\${message}\${propertyContents?\` { \${propertyContents} }\`:''}\`;}function inspectAttribute([key,value],options){options.truncate-=3;if(!value){return\`\${options.stylize(key,'yellow')}\`;}return\`\${options.stylize(key,'yellow')}=\${options.stylize(\`"\${value}"\`,'string')}\`;}function inspectHTMLCollection(collection,options){// eslint-disable-next-line no-use-before-define
return inspectList(collection,options,inspectHTML,'\\n');}function inspectHTML(element,options){const properties=element.getAttributeNames();const name=element.tagName.toLowerCase();const head=options.stylize(\`<\${name}\`,'special');const headClose=options.stylize(\`>\`,'special');const tail=options.stylize(\`</\${name}>\`,'special');options.truncate-=name.length*2+5;let propertyContents='';if(properties.length>0){propertyContents+=' ';propertyContents+=inspectList(properties.map(key=>[key,element.getAttribute(key)]),options,inspectAttribute,' ');}options.truncate-=propertyContents.length;const truncate=options.truncate;let children=inspectHTMLCollection(element.children,options);if(children&&children.length>truncate){children=\`\${truncator}(\${element.children.length})\`;}return\`\${head}\${propertyContents}\${headClose}\${children}\${tail}\`;}/* !
 * loupe
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */const symbolsSupported=typeof Symbol==='function'&&typeof Symbol.for==='function';const chaiInspect=symbolsSupported?Symbol.for('chai/inspect'):'@@chai/inspect';let nodeInspect$1=false;try{// eslint-disable-next-line global-require
const nodeUtil=require('util');nodeInspect$1=nodeUtil.inspect?nodeUtil.inspect.custom:false;}catch(noNodeInspect){nodeInspect$1=false;}function FakeMap$1(){// eslint-disable-next-line prefer-template
this.key='chai/loupe__'+Math.random()+Date.now();}FakeMap$1.prototype={// eslint-disable-next-line object-shorthand
get:function get(key){return key[this.key];},// eslint-disable-next-line object-shorthand
has:function has(key){return this.key in key;},// eslint-disable-next-line object-shorthand
set:function set(key,value){if(Object.isExtensible(key)){Object.defineProperty(key,this.key,{// eslint-disable-next-line object-shorthand
value:value,configurable:true});}}};const constructorMap=new(typeof WeakMap==='function'?WeakMap:FakeMap$1)();const stringTagMap={};const baseTypesMap={undefined:(value,options)=>options.stylize('undefined','undefined'),null:(value,options)=>options.stylize(null,'null'),boolean:(value,options)=>options.stylize(value,'boolean'),Boolean:(value,options)=>options.stylize(value,'boolean'),number:inspectNumber,Number:inspectNumber,bigint:inspectBigInt,BigInt:inspectBigInt,string:inspectString,String:inspectString,function:inspectFunction,Function:inspectFunction,symbol:inspectSymbol,// A Symbol polyfill will return \`Symbol\` not \`symbol\` from typedetect
Symbol:inspectSymbol,Array:inspectArray,Date:inspectDate,Map:inspectMap,Set:inspectSet,RegExp:inspectRegExp,Promise:inspectPromise,// WeakSet, WeakMap are totally opaque to us
WeakSet:(value,options)=>options.stylize('WeakSet{…}','special'),WeakMap:(value,options)=>options.stylize('WeakMap{…}','special'),Arguments:inspectArguments,Int8Array:inspectTypedArray,Uint8Array:inspectTypedArray,Uint8ClampedArray:inspectTypedArray,Int16Array:inspectTypedArray,Uint16Array:inspectTypedArray,Int32Array:inspectTypedArray,Uint32Array:inspectTypedArray,Float32Array:inspectTypedArray,Float64Array:inspectTypedArray,Generator:()=>'',DataView:()=>'',ArrayBuffer:()=>'',Error:inspectObject,HTMLCollection:inspectHTMLCollection,NodeList:inspectHTMLCollection};// eslint-disable-next-line complexity
const inspectCustom=(value,options,type)=>{if(chaiInspect in value&&typeof value[chaiInspect]==='function'){return value[chaiInspect](options);}if(nodeInspect$1&&nodeInspect$1 in value&&typeof value[nodeInspect$1]==='function'){return value[nodeInspect$1](options.depth,options);}if('inspect'in value&&typeof value.inspect==='function'){return value.inspect(options.depth,options);}if('constructor'in value&&constructorMap.has(value.constructor)){return constructorMap.get(value.constructor)(value,options);}if(stringTagMap[type]){return stringTagMap[type](value,options);}return'';};const toString=Object.prototype.toString;// eslint-disable-next-line complexity
function inspect$4(value,options){options=normaliseOptions(options);options.inspect=inspect$4;const _options2=options,customInspect=_options2.customInspect;let type=value===null?'null':typeof value;if(type==='object'){type=toString.call(value).slice(8,-1);}// If it is a base value that we already support, then use Loupe's inspector
if(baseTypesMap[type]){return baseTypesMap[type](value,options);}// If \`options.customInspect\` is set to true then try to use the custom inspector
if(customInspect&&value){const output=inspectCustom(value,options,type);if(output){if(typeof output==='string')return output;return inspect$4(output,options);}}const proto=value?Object.getPrototypeOf(value):false;// If it's a plain Object then use Loupe's inspector
if(proto===Object.prototype||proto===null){return inspectObject$1(value,options);}// Specifically account for HTMLElements
// eslint-disable-next-line no-undef
if(value&&typeof HTMLElement==='function'&&value instanceof HTMLElement){return inspectHTML(value,options);}if('constructor'in value){// If it is a class, inspect it like an object but add the constructor name
if(value.constructor!==Object){return inspectClass(value,options);}// If it is an object with an anonymous prototype, display it as an object.
return inspectObject$1(value,options);}// last chance to check if it's an object
if(value===Object(value)){return inspectObject$1(value,options);}// We have run out of options! Just stringify the value
return options.stylize(String(value),type);}function registerConstructor(constructor,inspector){if(constructorMap.has(constructor)){return false;}constructorMap.set(constructor,inspector);return true;}function registerStringTag(stringTag,inspector){if(stringTag in stringTagMap){return false;}stringTagMap[stringTag]=inspector;return true;}const custom=chaiInspect;const loupe$1=/*#__PURE__*/Object.freeze({__proto__:null,custom,default:inspect$4,inspect:inspect$4,registerConstructor,registerStringTag});const _plugins_=plugins_1,AsymmetricMatcher$3=_plugins_.AsymmetricMatcher,DOMCollection$2=_plugins_.DOMCollection,DOMElement$2=_plugins_.DOMElement,Immutable$2=_plugins_.Immutable,ReactElement$2=_plugins_.ReactElement,ReactTestComponent$2=_plugins_.ReactTestComponent;const PLUGINS$2=[ReactTestComponent$2,ReactElement$2,DOMElement$2,DOMCollection$2,Immutable$2,AsymmetricMatcher$3];function stringify(object,maxDepth=10,_ref5={}){let maxLength=_ref5.maxLength,options=_objectWithoutProperties(_ref5,_excluded);const MAX_LENGTH=maxLength??1e4;let result;try{result=format_1(object,_objectSpread({maxDepth,escapeString:false,// min: true,
plugins:PLUGINS$2},options));}catch{result=format_1(object,_objectSpread({callToJSON:false,maxDepth,escapeString:false,// min: true,
plugins:PLUGINS$2},options));}return result.length>=MAX_LENGTH&&maxDepth>1?stringify(object,Math.floor(maxDepth/2)):result;}const formatRegExp=/%[sdjifoOcj%]/g;function format(...args){if(typeof args[0]!=="string"){const objects=[];for(let i2=0;i2<args.length;i2++)objects.push(inspect$3(args[i2],{depth:0,colors:false,compact:3}));return objects.join(" ");}const len=args.length;let i=1;const template=args[0];let str=String(template).replace(formatRegExp,x=>{if(x==="%%")return"%";if(i>=len)return x;switch(x){case"%s":{const value=args[i++];if(typeof value==="bigint")return\`\${value.toString()}n\`;if(typeof value==="number"&&value===0&&1/value<0)return"-0";if(typeof value==="object"&&value!==null)return inspect$3(value,{depth:0,colors:false,compact:3});return String(value);}case"%d":{const value=args[i++];if(typeof value==="bigint")return\`\${value.toString()}n\`;return Number(value).toString();}case"%i":{const value=args[i++];if(typeof value==="bigint")return\`\${value.toString()}n\`;return Number.parseInt(String(value)).toString();}case"%f":return Number.parseFloat(String(args[i++])).toString();case"%o":return inspect$3(args[i++],{showHidden:true,showProxy:true});case"%O":return inspect$3(args[i++]);case"%c":{i++;return"";}case"%j":try{return JSON.stringify(args[i++]);}catch(err){const m=err.message;if(// chromium
m.includes("circular structure")||m.includes("cyclic structures")||m.includes("cyclic object"))return"[Circular]";throw err;}default:return x;}});for(let x=args[i];i<len;x=args[++i]){if(x===null||typeof x!=="object")str+=\` \${x}\`;else str+=\` \${inspect$3(x)}\`;}return str;}function inspect$3(obj,options={}){if(options.truncate===0)options.truncate=Number.POSITIVE_INFINITY;return inspect$4(obj,options);}function objDisplay$2(obj,options={}){if(typeof options.truncate==="undefined")options.truncate=40;const str=inspect$3(obj,options);const type=Object.prototype.toString.call(obj);if(options.truncate&&str.length>=options.truncate){if(type==="[object Function]"){const fn=obj;return!fn.name?"[Function]":\`[Function: \${fn.name}]\`;}else if(type==="[object Array]"){return\`[ Array(\${obj.length}) ]\`;}else if(type==="[object Object]"){const keys=Object.keys(obj);const kstr=keys.length>2?\`\${keys.splice(0,2).join(", ")}, ...\`:keys.join(", ");return\`{ Object (\${kstr}) }\`;}else{return str;}}return str;}const SAFE_TIMERS_SYMBOL=Symbol("vitest:SAFE_TIMERS");const SAFE_COLORS_SYMBOL=Symbol("vitest:SAFE_COLORS");const colorsMap={bold:["\\x1B[1m","\\x1B[22m","\\x1B[22m\\x1B[1m"],dim:["\\x1B[2m","\\x1B[22m","\\x1B[22m\\x1B[2m"],italic:["\\x1B[3m","\\x1B[23m"],underline:["\\x1B[4m","\\x1B[24m"],inverse:["\\x1B[7m","\\x1B[27m"],hidden:["\\x1B[8m","\\x1B[28m"],strikethrough:["\\x1B[9m","\\x1B[29m"],black:["\\x1B[30m","\\x1B[39m"],red:["\\x1B[31m","\\x1B[39m"],green:["\\x1B[32m","\\x1B[39m"],yellow:["\\x1B[33m","\\x1B[39m"],blue:["\\x1B[34m","\\x1B[39m"],magenta:["\\x1B[35m","\\x1B[39m"],cyan:["\\x1B[36m","\\x1B[39m"],white:["\\x1B[37m","\\x1B[39m"],gray:["\\x1B[90m","\\x1B[39m"],bgBlack:["\\x1B[40m","\\x1B[49m"],bgRed:["\\x1B[41m","\\x1B[49m"],bgGreen:["\\x1B[42m","\\x1B[49m"],bgYellow:["\\x1B[43m","\\x1B[49m"],bgBlue:["\\x1B[44m","\\x1B[49m"],bgMagenta:["\\x1B[45m","\\x1B[49m"],bgCyan:["\\x1B[46m","\\x1B[49m"],bgWhite:["\\x1B[47m","\\x1B[49m"]};const colorsEntries=Object.entries(colorsMap);function string$1(str){return String(str);}string$1.open="";string$1.close="";const defaultColors=/* @__PURE__ */colorsEntries.reduce((acc,[key])=>{acc[key]=string$1;return acc;},{isColorSupported:false});function getColors(){return globalThis[SAFE_COLORS_SYMBOL]||defaultColors;}function getSafeTimers(){const _ref6=globalThis[SAFE_TIMERS_SYMBOL]||globalThis,safeSetTimeout=_ref6.setTimeout,safeSetInterval=_ref6.setInterval,safeClearInterval=_ref6.clearInterval,safeClearTimeout=_ref6.clearTimeout,safeSetImmediate=_ref6.setImmediate,safeClearImmediate=_ref6.clearImmediate;const _ref7=globalThis[SAFE_TIMERS_SYMBOL]||globalThis.process||{nextTick:cb=>cb()},safeNextTick=_ref7.nextTick;return{nextTick:safeNextTick,setTimeout:safeSetTimeout,setInterval:safeSetInterval,clearInterval:safeClearInterval,clearTimeout:safeClearTimeout,setImmediate:safeSetImmediate,clearImmediate:safeClearImmediate};}function createSimpleStackTrace(options){const _ref8=options||{},_ref8$message=_ref8.message,message=_ref8$message===void 0?"error":_ref8$message,_ref8$stackTraceLimit=_ref8.stackTraceLimit,stackTraceLimit=_ref8$stackTraceLimit===void 0?1:_ref8$stackTraceLimit;const limit=Error.stackTraceLimit;const prepareStackTrace=Error.prepareStackTrace;Error.stackTraceLimit=stackTraceLimit;Error.prepareStackTrace=e=>e.stack;const err=new Error(message);const stackTrace=err.stack||"";Error.prepareStackTrace=prepareStackTrace;Error.stackTraceLimit=limit;return stackTrace;}// Copyright 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023 Simon Lydell
// License: MIT.
var LineTerminatorSequence$1;LineTerminatorSequence$1=/\\r?\\n|[\\r\\u2028\\u2029]/y;RegExp(LineTerminatorSequence$1.source);// src/index.ts
var reservedWords$1={keyword:["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"],strict:["implements","interface","let","package","private","protected","public","static","yield"]};new Set(reservedWords$1.keyword);new Set(reservedWords$1.strict);var build={};Object.defineProperty(build,'__esModule',{value:true});var _default=build.default=diffSequence;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ // This diff-sequences package implements the linear space variation in
// An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers
// Relationship in notation between Myers paper and this package:
// A is a
// N is aLength, aEnd - aStart, and so on
// x is aIndex, aFirst, aLast, and so on
// B is b
// M is bLength, bEnd - bStart, and so on
// y is bIndex, bFirst, bLast, and so on
// Δ = N - M is negative of baDeltaLength = bLength - aLength
// D is d
// k is kF
// k + Δ is kF = kR - baDeltaLength
// V is aIndexesF or aIndexesR (see comment below about Indexes type)
// index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)
// starting point in forward direction (0, 0) is (-1, -1)
// starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)
// The “edit graph” for sequences a and b corresponds to items:
// in a on the horizontal axis
// in b on the vertical axis
//
// Given a-coordinate of a point in a diagonal, you can compute b-coordinate.
//
// Forward diagonals kF:
// zero diagonal intersects top left corner
// positive diagonals intersect top edge
// negative diagonals insersect left edge
//
// Reverse diagonals kR:
// zero diagonal intersects bottom right corner
// positive diagonals intersect right edge
// negative diagonals intersect bottom edge
// The graph contains a directed acyclic graph of edges:
// horizontal: delete an item from a
// vertical: insert an item from b
// diagonal: common item in a and b
//
// The algorithm solves dual problems in the graph analogy:
// Find longest common subsequence: path with maximum number of diagonal edges
// Find shortest edit script: path with minimum number of non-diagonal edges
// Input callback function compares items at indexes in the sequences.
// Output callback function receives the number of adjacent items
// and starting indexes of each common subsequence.
// Either original functions or wrapped to swap indexes if graph is transposed.
// Indexes in sequence a of last point of forward or reverse paths in graph.
// Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.
// This package indexes by iF and iR which are greater than or equal to zero.
// and also updates the index arrays in place to cut memory in half.
// kF = 2 * iF - d
// kR = d - 2 * iR
// Division of index intervals in sequences a and b at the middle change.
// Invariant: intervals do not have common items at the start or end.
const pkg='diff-sequences';// for error messages
const NOT_YET_SET=0;// small int instead of undefined to avoid deopt in V8
// Return the number of common items that follow in forward direction.
// The length of what Myers paper calls a “snake” in a forward path.
const countCommonItemsF=(aIndex,aEnd,bIndex,bEnd,isCommon)=>{let nCommon=0;while(aIndex<aEnd&&bIndex<bEnd&&isCommon(aIndex,bIndex)){aIndex+=1;bIndex+=1;nCommon+=1;}return nCommon;};// Return the number of common items that precede in reverse direction.
// The length of what Myers paper calls a “snake” in a reverse path.
const countCommonItemsR=(aStart,aIndex,bStart,bIndex,isCommon)=>{let nCommon=0;while(aStart<=aIndex&&bStart<=bIndex&&isCommon(aIndex,bIndex)){aIndex-=1;bIndex-=1;nCommon+=1;}return nCommon;};// A simple function to extend forward paths from (d - 1) to d changes
// when forward and reverse paths cannot yet overlap.
const extendPathsF=(d,aEnd,bEnd,bF,isCommon,aIndexesF,iMaxF// return the value because optimization might decrease it
)=>{// Unroll the first iteration.
let iF=0;let kF=-d;// kF = 2 * iF - d
let aFirst=aIndexesF[iF];// in first iteration always insert
let aIndexPrev1=aFirst;// prev value of [iF - 1] in next iteration
aIndexesF[iF]+=countCommonItemsF(aFirst+1,aEnd,bF+aFirst-kF+1,bEnd,isCommon);// Optimization: skip diagonals in which paths cannot ever overlap.
const nF=d<iMaxF?d:iMaxF;// The diagonals kF are odd when d is odd and even when d is even.
for(iF+=1,kF+=2;iF<=nF;iF+=1,kF+=2){// To get first point of path segment, move one change in forward direction
// from last point of previous path segment in an adjacent diagonal.
// In last possible iteration when iF === d and kF === d always delete.
if(iF!==d&&aIndexPrev1<aIndexesF[iF]){aFirst=aIndexesF[iF];// vertical to insert from b
}else{aFirst=aIndexPrev1+1;// horizontal to delete from a
if(aEnd<=aFirst){// Optimization: delete moved past right of graph.
return iF-1;}}// To get last point of path segment, move along diagonal of common items.
aIndexPrev1=aIndexesF[iF];aIndexesF[iF]=aFirst+countCommonItemsF(aFirst+1,aEnd,bF+aFirst-kF+1,bEnd,isCommon);}return iMaxF;};// A simple function to extend reverse paths from (d - 1) to d changes
// when reverse and forward paths cannot yet overlap.
const extendPathsR=(d,aStart,bStart,bR,isCommon,aIndexesR,iMaxR// return the value because optimization might decrease it
)=>{// Unroll the first iteration.
let iR=0;let kR=d;// kR = d - 2 * iR
let aFirst=aIndexesR[iR];// in first iteration always insert
let aIndexPrev1=aFirst;// prev value of [iR - 1] in next iteration
aIndexesR[iR]-=countCommonItemsR(aStart,aFirst-1,bStart,bR+aFirst-kR-1,isCommon);// Optimization: skip diagonals in which paths cannot ever overlap.
const nR=d<iMaxR?d:iMaxR;// The diagonals kR are odd when d is odd and even when d is even.
for(iR+=1,kR-=2;iR<=nR;iR+=1,kR-=2){// To get first point of path segment, move one change in reverse direction
// from last point of previous path segment in an adjacent diagonal.
// In last possible iteration when iR === d and kR === -d always delete.
if(iR!==d&&aIndexesR[iR]<aIndexPrev1){aFirst=aIndexesR[iR];// vertical to insert from b
}else{aFirst=aIndexPrev1-1;// horizontal to delete from a
if(aFirst<aStart){// Optimization: delete moved past left of graph.
return iR-1;}}// To get last point of path segment, move along diagonal of common items.
aIndexPrev1=aIndexesR[iR];aIndexesR[iR]=aFirst-countCommonItemsR(aStart,aFirst-1,bStart,bR+aFirst-kR-1,isCommon);}return iMaxR;};// A complete function to extend forward paths from (d - 1) to d changes.
// Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.
const extendOverlappablePathsF=(d,aStart,aEnd,bStart,bEnd,isCommon,aIndexesF,iMaxF,aIndexesR,iMaxR,division// update prop values if return true
)=>{const bF=bStart-aStart;// bIndex = bF + aIndex - kF
const aLength=aEnd-aStart;const bLength=bEnd-bStart;const baDeltaLength=bLength-aLength;// kF = kR - baDeltaLength
// Range of diagonals in which forward and reverse paths might overlap.
const kMinOverlapF=-baDeltaLength-(d-1);// -(d - 1) <= kR
const kMaxOverlapF=-baDeltaLength+(d-1);// kR <= (d - 1)
let aIndexPrev1=NOT_YET_SET;// prev value of [iF - 1] in next iteration
// Optimization: skip diagonals in which paths cannot ever overlap.
const nF=d<iMaxF?d:iMaxF;// The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.
for(let iF=0,kF=-d;iF<=nF;iF+=1,kF+=2){// To get first point of path segment, move one change in forward direction
// from last point of previous path segment in an adjacent diagonal.
// In first iteration when iF === 0 and kF === -d always insert.
// In last possible iteration when iF === d and kF === d always delete.
const insert=iF===0||iF!==d&&aIndexPrev1<aIndexesF[iF];const aLastPrev=insert?aIndexesF[iF]:aIndexPrev1;const aFirst=insert?aLastPrev// vertical to insert from b
:aLastPrev+1;// horizontal to delete from a
// To get last point of path segment, move along diagonal of common items.
const bFirst=bF+aFirst-kF;const nCommonF=countCommonItemsF(aFirst+1,aEnd,bFirst+1,bEnd,isCommon);const aLast=aFirst+nCommonF;aIndexPrev1=aIndexesF[iF];aIndexesF[iF]=aLast;if(kMinOverlapF<=kF&&kF<=kMaxOverlapF){// Solve for iR of reverse path with (d - 1) changes in diagonal kF:
// kR = kF + baDeltaLength
// kR = (d - 1) - 2 * iR
const iR=(d-1-(kF+baDeltaLength))/2;// If this forward path overlaps the reverse path in this diagonal,
// then this is the middle change of the index intervals.
if(iR<=iMaxR&&aIndexesR[iR]-1<=aLast){// Unlike the Myers algorithm which finds only the middle “snake”
// this package can find two common subsequences per division.
// Last point of previous path segment is on an adjacent diagonal.
const bLastPrev=bF+aLastPrev-(insert?kF+1:kF-1);// Because of invariant that intervals preceding the middle change
// cannot have common items at the end,
// move in reverse direction along a diagonal of common items.
const nCommonR=countCommonItemsR(aStart,aLastPrev,bStart,bLastPrev,isCommon);const aIndexPrevFirst=aLastPrev-nCommonR;const bIndexPrevFirst=bLastPrev-nCommonR;const aEndPreceding=aIndexPrevFirst+1;const bEndPreceding=bIndexPrevFirst+1;division.nChangePreceding=d-1;if(d-1===aEndPreceding+bEndPreceding-aStart-bStart){// Optimization: number of preceding changes in forward direction
// is equal to number of items in preceding interval,
// therefore it cannot contain any common items.
division.aEndPreceding=aStart;division.bEndPreceding=bStart;}else{division.aEndPreceding=aEndPreceding;division.bEndPreceding=bEndPreceding;}division.nCommonPreceding=nCommonR;if(nCommonR!==0){division.aCommonPreceding=aEndPreceding;division.bCommonPreceding=bEndPreceding;}division.nCommonFollowing=nCommonF;if(nCommonF!==0){division.aCommonFollowing=aFirst+1;division.bCommonFollowing=bFirst+1;}const aStartFollowing=aLast+1;const bStartFollowing=bFirst+nCommonF+1;division.nChangeFollowing=d-1;if(d-1===aEnd+bEnd-aStartFollowing-bStartFollowing){// Optimization: number of changes in reverse direction
// is equal to number of items in following interval,
// therefore it cannot contain any common items.
division.aStartFollowing=aEnd;division.bStartFollowing=bEnd;}else{division.aStartFollowing=aStartFollowing;division.bStartFollowing=bStartFollowing;}return true;}}}return false;};// A complete function to extend reverse paths from (d - 1) to d changes.
// Return true if a path overlaps forward path of d changes in its diagonal.
const extendOverlappablePathsR=(d,aStart,aEnd,bStart,bEnd,isCommon,aIndexesF,iMaxF,aIndexesR,iMaxR,division// update prop values if return true
)=>{const bR=bEnd-aEnd;// bIndex = bR + aIndex - kR
const aLength=aEnd-aStart;const bLength=bEnd-bStart;const baDeltaLength=bLength-aLength;// kR = kF + baDeltaLength
// Range of diagonals in which forward and reverse paths might overlap.
const kMinOverlapR=baDeltaLength-d;// -d <= kF
const kMaxOverlapR=baDeltaLength+d;// kF <= d
let aIndexPrev1=NOT_YET_SET;// prev value of [iR - 1] in next iteration
// Optimization: skip diagonals in which paths cannot ever overlap.
const nR=d<iMaxR?d:iMaxR;// The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.
for(let iR=0,kR=d;iR<=nR;iR+=1,kR-=2){// To get first point of path segment, move one change in reverse direction
// from last point of previous path segment in an adjacent diagonal.
// In first iteration when iR === 0 and kR === d always insert.
// In last possible iteration when iR === d and kR === -d always delete.
const insert=iR===0||iR!==d&&aIndexesR[iR]<aIndexPrev1;const aLastPrev=insert?aIndexesR[iR]:aIndexPrev1;const aFirst=insert?aLastPrev// vertical to insert from b
:aLastPrev-1;// horizontal to delete from a
// To get last point of path segment, move along diagonal of common items.
const bFirst=bR+aFirst-kR;const nCommonR=countCommonItemsR(aStart,aFirst-1,bStart,bFirst-1,isCommon);const aLast=aFirst-nCommonR;aIndexPrev1=aIndexesR[iR];aIndexesR[iR]=aLast;if(kMinOverlapR<=kR&&kR<=kMaxOverlapR){// Solve for iF of forward path with d changes in diagonal kR:
// kF = kR - baDeltaLength
// kF = 2 * iF - d
const iF=(d+(kR-baDeltaLength))/2;// If this reverse path overlaps the forward path in this diagonal,
// then this is a middle change of the index intervals.
if(iF<=iMaxF&&aLast-1<=aIndexesF[iF]){const bLast=bFirst-nCommonR;division.nChangePreceding=d;if(d===aLast+bLast-aStart-bStart){// Optimization: number of changes in reverse direction
// is equal to number of items in preceding interval,
// therefore it cannot contain any common items.
division.aEndPreceding=aStart;division.bEndPreceding=bStart;}else{division.aEndPreceding=aLast;division.bEndPreceding=bLast;}division.nCommonPreceding=nCommonR;if(nCommonR!==0){// The last point of reverse path segment is start of common subsequence.
division.aCommonPreceding=aLast;division.bCommonPreceding=bLast;}division.nChangeFollowing=d-1;if(d===1){// There is no previous path segment.
division.nCommonFollowing=0;division.aStartFollowing=aEnd;division.bStartFollowing=bEnd;}else{// Unlike the Myers algorithm which finds only the middle “snake”
// this package can find two common subsequences per division.
// Last point of previous path segment is on an adjacent diagonal.
const bLastPrev=bR+aLastPrev-(insert?kR-1:kR+1);// Because of invariant that intervals following the middle change
// cannot have common items at the start,
// move in forward direction along a diagonal of common items.
const nCommonF=countCommonItemsF(aLastPrev,aEnd,bLastPrev,bEnd,isCommon);division.nCommonFollowing=nCommonF;if(nCommonF!==0){// The last point of reverse path segment is start of common subsequence.
division.aCommonFollowing=aLastPrev;division.bCommonFollowing=bLastPrev;}const aStartFollowing=aLastPrev+nCommonF;// aFirstPrev
const bStartFollowing=bLastPrev+nCommonF;// bFirstPrev
if(d-1===aEnd+bEnd-aStartFollowing-bStartFollowing){// Optimization: number of changes in forward direction
// is equal to number of items in following interval,
// therefore it cannot contain any common items.
division.aStartFollowing=aEnd;division.bStartFollowing=bEnd;}else{division.aStartFollowing=aStartFollowing;division.bStartFollowing=bStartFollowing;}}return true;}}}return false;};// Given index intervals and input function to compare items at indexes,
// divide at the middle change.
//
// DO NOT CALL if start === end, because interval cannot contain common items
// and because this function will throw the “no overlap” error.
const divide=(nChange,aStart,aEnd,bStart,bEnd,isCommon,aIndexesF,aIndexesR,division// output
)=>{const bF=bStart-aStart;// bIndex = bF + aIndex - kF
const bR=bEnd-aEnd;// bIndex = bR + aIndex - kR
const aLength=aEnd-aStart;const bLength=bEnd-bStart;// Because graph has square or portrait orientation,
// length difference is minimum number of items to insert from b.
// Corresponding forward and reverse diagonals in graph
// depend on length difference of the sequences:
// kF = kR - baDeltaLength
// kR = kF + baDeltaLength
const baDeltaLength=bLength-aLength;// Optimization: max diagonal in graph intersects corner of shorter side.
let iMaxF=aLength;let iMaxR=aLength;// Initialize no changes yet in forward or reverse direction:
aIndexesF[0]=aStart-1;// at open start of interval, outside closed start
aIndexesR[0]=aEnd;// at open end of interval
if(baDeltaLength%2===0){// The number of changes in paths is 2 * d if length difference is even.
const dMin=(nChange||baDeltaLength)/2;const dMax=(aLength+bLength)/2;for(let d=1;d<=dMax;d+=1){iMaxF=extendPathsF(d,aEnd,bEnd,bF,isCommon,aIndexesF,iMaxF);if(d<dMin){iMaxR=extendPathsR(d,aStart,bStart,bR,isCommon,aIndexesR,iMaxR);}else if(// If a reverse path overlaps a forward path in the same diagonal,
// return a division of the index intervals at the middle change.
extendOverlappablePathsR(d,aStart,aEnd,bStart,bEnd,isCommon,aIndexesF,iMaxF,aIndexesR,iMaxR,division)){return;}}}else{// The number of changes in paths is 2 * d - 1 if length difference is odd.
const dMin=((nChange||baDeltaLength)+1)/2;const dMax=(aLength+bLength+1)/2;// Unroll first half iteration so loop extends the relevant pairs of paths.
// Because of invariant that intervals have no common items at start or end,
// and limitation not to call divide with empty intervals,
// therefore it cannot be called if a forward path with one change
// would overlap a reverse path with no changes, even if dMin === 1.
let d=1;iMaxF=extendPathsF(d,aEnd,bEnd,bF,isCommon,aIndexesF,iMaxF);for(d+=1;d<=dMax;d+=1){iMaxR=extendPathsR(d-1,aStart,bStart,bR,isCommon,aIndexesR,iMaxR);if(d<dMin){iMaxF=extendPathsF(d,aEnd,bEnd,bF,isCommon,aIndexesF,iMaxF);}else if(// If a forward path overlaps a reverse path in the same diagonal,
// return a division of the index intervals at the middle change.
extendOverlappablePathsF(d,aStart,aEnd,bStart,bEnd,isCommon,aIndexesF,iMaxF,aIndexesR,iMaxR,division)){return;}}}/* istanbul ignore next */throw new Error(\`\${pkg}: no overlap aStart=\${aStart} aEnd=\${aEnd} bStart=\${bStart} bEnd=\${bEnd}\`);};// Given index intervals and input function to compare items at indexes,
// return by output function the number of adjacent items and starting indexes
// of each common subsequence. Divide and conquer with only linear space.
//
// The index intervals are half open [start, end) like array slice method.
// DO NOT CALL if start === end, because interval cannot contain common items
// and because divide function will throw the “no overlap” error.
const findSubsequences=(nChange,aStart,aEnd,bStart,bEnd,transposed,callbacks,aIndexesF,aIndexesR,division// temporary memory, not input nor output
)=>{if(bEnd-bStart<aEnd-aStart){// Transpose graph so it has portrait instead of landscape orientation.
// Always compare shorter to longer sequence for consistency and optimization.
transposed=!transposed;if(transposed&&callbacks.length===1){// Lazily wrap callback functions to swap args if graph is transposed.
const _callbacks$=callbacks[0],foundSubsequence=_callbacks$.foundSubsequence,isCommon=_callbacks$.isCommon;callbacks[1]={foundSubsequence:(nCommon,bCommon,aCommon)=>{foundSubsequence(nCommon,aCommon,bCommon);},isCommon:(bIndex,aIndex)=>isCommon(aIndex,bIndex)};}const tStart=aStart;const tEnd=aEnd;aStart=bStart;aEnd=bEnd;bStart=tStart;bEnd=tEnd;}const _callbacks=callbacks[transposed?1:0],foundSubsequence=_callbacks.foundSubsequence,isCommon=_callbacks.isCommon;// Divide the index intervals at the middle change.
divide(nChange,aStart,aEnd,bStart,bEnd,isCommon,aIndexesF,aIndexesR,division);const nChangePreceding=division.nChangePreceding,aEndPreceding=division.aEndPreceding,bEndPreceding=division.bEndPreceding,nCommonPreceding=division.nCommonPreceding,aCommonPreceding=division.aCommonPreceding,bCommonPreceding=division.bCommonPreceding,nCommonFollowing=division.nCommonFollowing,aCommonFollowing=division.aCommonFollowing,bCommonFollowing=division.bCommonFollowing,nChangeFollowing=division.nChangeFollowing,aStartFollowing=division.aStartFollowing,bStartFollowing=division.bStartFollowing;// Unless either index interval is empty, they might contain common items.
if(aStart<aEndPreceding&&bStart<bEndPreceding){// Recursely find and return common subsequences preceding the division.
findSubsequences(nChangePreceding,aStart,aEndPreceding,bStart,bEndPreceding,transposed,callbacks,aIndexesF,aIndexesR,division);}// Return common subsequences that are adjacent to the middle change.
if(nCommonPreceding!==0){foundSubsequence(nCommonPreceding,aCommonPreceding,bCommonPreceding);}if(nCommonFollowing!==0){foundSubsequence(nCommonFollowing,aCommonFollowing,bCommonFollowing);}// Unless either index interval is empty, they might contain common items.
if(aStartFollowing<aEnd&&bStartFollowing<bEnd){// Recursely find and return common subsequences following the division.
findSubsequences(nChangeFollowing,aStartFollowing,aEnd,bStartFollowing,bEnd,transposed,callbacks,aIndexesF,aIndexesR,division);}};const validateLength=(name,arg)=>{if(typeof arg!=='number'){throw new TypeError(\`\${pkg}: \${name} typeof \${typeof arg} is not a number\`);}if(!Number.isSafeInteger(arg)){throw new RangeError(\`\${pkg}: \${name} value \${arg} is not a safe integer\`);}if(arg<0){throw new RangeError(\`\${pkg}: \${name} value \${arg} is a negative integer\`);}};const validateCallback=(name,arg)=>{const type=typeof arg;if(type!=='function'){throw new TypeError(\`\${pkg}: \${name} typeof \${type} is not a function\`);}};// Compare items in two sequences to find a longest common subsequence.
// Given lengths of sequences and input function to compare items at indexes,
// return by output function the number of adjacent items and starting indexes
// of each common subsequence.
function diffSequence(aLength,bLength,isCommon,foundSubsequence){validateLength('aLength',aLength);validateLength('bLength',bLength);validateCallback('isCommon',isCommon);validateCallback('foundSubsequence',foundSubsequence);// Count common items from the start in the forward direction.
const nCommonF=countCommonItemsF(0,aLength,0,bLength,isCommon);if(nCommonF!==0){foundSubsequence(nCommonF,0,0);}// Unless both sequences consist of common items only,
// find common items in the half-trimmed index intervals.
if(aLength!==nCommonF||bLength!==nCommonF){// Invariant: intervals do not have common items at the start.
// The start of an index interval is closed like array slice method.
const aStart=nCommonF;const bStart=nCommonF;// Count common items from the end in the reverse direction.
const nCommonR=countCommonItemsR(aStart,aLength-1,bStart,bLength-1,isCommon);// Invariant: intervals do not have common items at the end.
// The end of an index interval is open like array slice method.
const aEnd=aLength-nCommonR;const bEnd=bLength-nCommonR;// Unless one sequence consists of common items only,
// therefore the other trimmed index interval consists of changes only,
// find common items in the trimmed index intervals.
const nCommonFR=nCommonF+nCommonR;if(aLength!==nCommonFR&&bLength!==nCommonFR){const nChange=0;// number of change items is not yet known
const transposed=false;// call the original unwrapped functions
const callbacks=[{foundSubsequence,isCommon}];// Indexes in sequence a of last points in furthest reaching paths
// from outside the start at top left in the forward direction:
const aIndexesF=[NOT_YET_SET];// from the end at bottom right in the reverse direction:
const aIndexesR=[NOT_YET_SET];// Initialize one object as output of all calls to divide function.
const division={aCommonFollowing:NOT_YET_SET,aCommonPreceding:NOT_YET_SET,aEndPreceding:NOT_YET_SET,aStartFollowing:NOT_YET_SET,bCommonFollowing:NOT_YET_SET,bCommonPreceding:NOT_YET_SET,bEndPreceding:NOT_YET_SET,bStartFollowing:NOT_YET_SET,nChangeFollowing:NOT_YET_SET,nChangePreceding:NOT_YET_SET,nCommonFollowing:NOT_YET_SET,nCommonPreceding:NOT_YET_SET};// Find and return common subsequences in the trimmed index intervals.
findSubsequences(nChange,aStart,aEnd,bStart,bEnd,transposed,callbacks,aIndexesF,aIndexesR,division);}if(nCommonR!==0){foundSubsequence(nCommonR,aEnd,bEnd);}}}function getType(value){if(value===void 0){return"undefined";}else if(value===null){return"null";}else if(Array.isArray(value)){return"array";}else if(typeof value==="boolean"){return"boolean";}else if(typeof value==="function"){return"function";}else if(typeof value==="number"){return"number";}else if(typeof value==="string"){return"string";}else if(typeof value==="bigint"){return"bigint";}else if(typeof value==="object"){if(value!=null){if(value.constructor===RegExp)return"regexp";else if(value.constructor===Map)return"map";else if(value.constructor===Set)return"set";else if(value.constructor===Date)return"date";}return"object";}else if(typeof value==="symbol"){return"symbol";}throw new Error(\`value of unknown type: \${value}\`);}const DIFF_DELETE=-1;const DIFF_INSERT=1;const DIFF_EQUAL=0;class Diff{0;1;constructor(op,text){this[0]=op;this[1]=text;}}const NO_DIFF_MESSAGE="Compared values have no visual difference.";const SIMILAR_MESSAGE="Compared values serialize to the same structure.\\nPrinting internal object structure without calling \`toJSON\` instead.";function formatTrailingSpaces(line,trailingSpaceFormatter){return line.replace(/\\s+$/,match=>trailingSpaceFormatter(match));}function printDiffLine(line,isFirstOrLast,color,indicator,trailingSpaceFormatter,emptyFirstOrLastLinePlaceholder){return line.length!==0?color(\`\${indicator} \${formatTrailingSpaces(line,trailingSpaceFormatter)}\`):indicator!==" "?color(indicator):isFirstOrLast&&emptyFirstOrLastLinePlaceholder.length!==0?color(\`\${indicator} \${emptyFirstOrLastLinePlaceholder}\`):"";}function printDeleteLine(line,isFirstOrLast,{aColor,aIndicator,changeLineTrailingSpaceColor,emptyFirstOrLastLinePlaceholder}){return printDiffLine(line,isFirstOrLast,aColor,aIndicator,changeLineTrailingSpaceColor,emptyFirstOrLastLinePlaceholder);}function printInsertLine(line,isFirstOrLast,{bColor,bIndicator,changeLineTrailingSpaceColor,emptyFirstOrLastLinePlaceholder}){return printDiffLine(line,isFirstOrLast,bColor,bIndicator,changeLineTrailingSpaceColor,emptyFirstOrLastLinePlaceholder);}function printCommonLine(line,isFirstOrLast,{commonColor,commonIndicator,commonLineTrailingSpaceColor,emptyFirstOrLastLinePlaceholder}){return printDiffLine(line,isFirstOrLast,commonColor,commonIndicator,commonLineTrailingSpaceColor,emptyFirstOrLastLinePlaceholder);}function createPatchMark(aStart,aEnd,bStart,bEnd,{patchColor}){return patchColor(\`@@ -\${aStart+1},\${aEnd-aStart} +\${bStart+1},\${bEnd-bStart} @@\`);}function joinAlignedDiffsNoExpand(diffs,options){const iLength=diffs.length;const nContextLines=options.contextLines;const nContextLines2=nContextLines+nContextLines;let jLength=iLength;let hasExcessAtStartOrEnd=false;let nExcessesBetweenChanges=0;let i=0;while(i!==iLength){const iStart=i;while(i!==iLength&&diffs[i][0]===DIFF_EQUAL)i+=1;if(iStart!==i){if(iStart===0){if(i>nContextLines){jLength-=i-nContextLines;hasExcessAtStartOrEnd=true;}}else if(i===iLength){const n=i-iStart;if(n>nContextLines){jLength-=n-nContextLines;hasExcessAtStartOrEnd=true;}}else{const n=i-iStart;if(n>nContextLines2){jLength-=n-nContextLines2;nExcessesBetweenChanges+=1;}}}while(i!==iLength&&diffs[i][0]!==DIFF_EQUAL)i+=1;}const hasPatch=nExcessesBetweenChanges!==0||hasExcessAtStartOrEnd;if(nExcessesBetweenChanges!==0)jLength+=nExcessesBetweenChanges+1;else if(hasExcessAtStartOrEnd)jLength+=1;const jLast=jLength-1;const lines=[];let jPatchMark=0;if(hasPatch)lines.push("");let aStart=0;let bStart=0;let aEnd=0;let bEnd=0;const pushCommonLine=line=>{const j=lines.length;lines.push(printCommonLine(line,j===0||j===jLast,options));aEnd+=1;bEnd+=1;};const pushDeleteLine=line=>{const j=lines.length;lines.push(printDeleteLine(line,j===0||j===jLast,options));aEnd+=1;};const pushInsertLine=line=>{const j=lines.length;lines.push(printInsertLine(line,j===0||j===jLast,options));bEnd+=1;};i=0;while(i!==iLength){let iStart=i;while(i!==iLength&&diffs[i][0]===DIFF_EQUAL)i+=1;if(iStart!==i){if(iStart===0){if(i>nContextLines){iStart=i-nContextLines;aStart=iStart;bStart=iStart;aEnd=aStart;bEnd=bStart;}for(let iCommon=iStart;iCommon!==i;iCommon+=1)pushCommonLine(diffs[iCommon][1]);}else if(i===iLength){const iEnd=i-iStart>nContextLines?iStart+nContextLines:i;for(let iCommon=iStart;iCommon!==iEnd;iCommon+=1)pushCommonLine(diffs[iCommon][1]);}else{const nCommon=i-iStart;if(nCommon>nContextLines2){const iEnd=iStart+nContextLines;for(let iCommon=iStart;iCommon!==iEnd;iCommon+=1)pushCommonLine(diffs[iCommon][1]);lines[jPatchMark]=createPatchMark(aStart,aEnd,bStart,bEnd,options);jPatchMark=lines.length;lines.push("");const nOmit=nCommon-nContextLines2;aStart=aEnd+nOmit;bStart=bEnd+nOmit;aEnd=aStart;bEnd=bStart;for(let iCommon=i-nContextLines;iCommon!==i;iCommon+=1)pushCommonLine(diffs[iCommon][1]);}else{for(let iCommon=iStart;iCommon!==i;iCommon+=1)pushCommonLine(diffs[iCommon][1]);}}}while(i!==iLength&&diffs[i][0]===DIFF_DELETE){pushDeleteLine(diffs[i][1]);i+=1;}while(i!==iLength&&diffs[i][0]===DIFF_INSERT){pushInsertLine(diffs[i][1]);i+=1;}}if(hasPatch)lines[jPatchMark]=createPatchMark(aStart,aEnd,bStart,bEnd,options);return lines.join("\\n");}function joinAlignedDiffsExpand(diffs,options){return diffs.map((diff,i,diffs2)=>{const line=diff[1];const isFirstOrLast=i===0||i===diffs2.length-1;switch(diff[0]){case DIFF_DELETE:return printDeleteLine(line,isFirstOrLast,options);case DIFF_INSERT:return printInsertLine(line,isFirstOrLast,options);default:return printCommonLine(line,isFirstOrLast,options);}}).join("\\n");}const noColor=string=>string;const DIFF_CONTEXT_DEFAULT=5;const DIFF_TRUNCATE_THRESHOLD_DEFAULT=0;function getDefaultOptions(){const c=getColors();return{aAnnotation:"Expected",aColor:c.green,aIndicator:"-",bAnnotation:"Received",bColor:c.red,bIndicator:"+",changeColor:c.inverse,changeLineTrailingSpaceColor:noColor,commonColor:c.dim,commonIndicator:" ",commonLineTrailingSpaceColor:noColor,compareKeys:void 0,contextLines:DIFF_CONTEXT_DEFAULT,emptyFirstOrLastLinePlaceholder:"",expand:true,includeChangeCounts:false,omitAnnotationLines:false,patchColor:c.yellow,truncateThreshold:DIFF_TRUNCATE_THRESHOLD_DEFAULT,truncateAnnotation:"... Diff result is truncated",truncateAnnotationColor:noColor};}function getCompareKeys(compareKeys){return compareKeys&&typeof compareKeys==="function"?compareKeys:void 0;}function getContextLines(contextLines){return typeof contextLines==="number"&&Number.isSafeInteger(contextLines)&&contextLines>=0?contextLines:DIFF_CONTEXT_DEFAULT;}function normalizeDiffOptions(options={}){return _objectSpread(_objectSpread(_objectSpread({},getDefaultOptions()),options),{},{compareKeys:getCompareKeys(options.compareKeys),contextLines:getContextLines(options.contextLines)});}function isEmptyString(lines){return lines.length===1&&lines[0].length===0;}function countChanges(diffs){let a=0;let b=0;diffs.forEach(diff2=>{switch(diff2[0]){case DIFF_DELETE:a+=1;break;case DIFF_INSERT:b+=1;break;}});return{a,b};}function printAnnotation({aAnnotation,aColor,aIndicator,bAnnotation,bColor,bIndicator,includeChangeCounts,omitAnnotationLines},changeCounts){if(omitAnnotationLines)return"";let aRest="";let bRest="";if(includeChangeCounts){const aCount=String(changeCounts.a);const bCount=String(changeCounts.b);const baAnnotationLengthDiff=bAnnotation.length-aAnnotation.length;const aAnnotationPadding=" ".repeat(Math.max(0,baAnnotationLengthDiff));const bAnnotationPadding=" ".repeat(Math.max(0,-baAnnotationLengthDiff));const baCountLengthDiff=bCount.length-aCount.length;const aCountPadding=" ".repeat(Math.max(0,baCountLengthDiff));const bCountPadding=" ".repeat(Math.max(0,-baCountLengthDiff));aRest=\`\${aAnnotationPadding}  \${aIndicator} \${aCountPadding}\${aCount}\`;bRest=\`\${bAnnotationPadding}  \${bIndicator} \${bCountPadding}\${bCount}\`;}const a=\`\${aIndicator} \${aAnnotation}\${aRest}\`;const b=\`\${bIndicator} \${bAnnotation}\${bRest}\`;return\`\${aColor(a)}
\${bColor(b)}

\`;}function printDiffLines(diffs,truncated,options){return printAnnotation(options,countChanges(diffs))+(options.expand?joinAlignedDiffsExpand(diffs,options):joinAlignedDiffsNoExpand(diffs,options))+(truncated?options.truncateAnnotationColor(\`
\${options.truncateAnnotation}\`):"");}function diffLinesUnified(aLines,bLines,options){const normalizedOptions=normalizeDiffOptions(options);const _diffLinesRaw=diffLinesRaw(isEmptyString(aLines)?[]:aLines,isEmptyString(bLines)?[]:bLines,normalizedOptions),_diffLinesRaw2=_slicedToArray(_diffLinesRaw,2),diffs=_diffLinesRaw2[0],truncated=_diffLinesRaw2[1];return printDiffLines(diffs,truncated,normalizedOptions);}function diffLinesUnified2(aLinesDisplay,bLinesDisplay,aLinesCompare,bLinesCompare,options){if(isEmptyString(aLinesDisplay)&&isEmptyString(aLinesCompare)){aLinesDisplay=[];aLinesCompare=[];}if(isEmptyString(bLinesDisplay)&&isEmptyString(bLinesCompare)){bLinesDisplay=[];bLinesCompare=[];}if(aLinesDisplay.length!==aLinesCompare.length||bLinesDisplay.length!==bLinesCompare.length){return diffLinesUnified(aLinesDisplay,bLinesDisplay,options);}const _diffLinesRaw3=diffLinesRaw(aLinesCompare,bLinesCompare,options),_diffLinesRaw4=_slicedToArray(_diffLinesRaw3,2),diffs=_diffLinesRaw4[0],truncated=_diffLinesRaw4[1];let aIndex=0;let bIndex=0;diffs.forEach(diff2=>{switch(diff2[0]){case DIFF_DELETE:diff2[1]=aLinesDisplay[aIndex];aIndex+=1;break;case DIFF_INSERT:diff2[1]=bLinesDisplay[bIndex];bIndex+=1;break;default:diff2[1]=bLinesDisplay[bIndex];aIndex+=1;bIndex+=1;}});return printDiffLines(diffs,truncated,normalizeDiffOptions(options));}function diffLinesRaw(aLines,bLines,options){const truncate=(options==null?void 0:options.truncateThreshold)??false;const truncateThreshold=Math.max(Math.floor((options==null?void 0:options.truncateThreshold)??0),0);const aLength=truncate?Math.min(aLines.length,truncateThreshold):aLines.length;const bLength=truncate?Math.min(bLines.length,truncateThreshold):bLines.length;const truncated=aLength!==aLines.length||bLength!==bLines.length;const isCommon=(aIndex2,bIndex2)=>aLines[aIndex2]===bLines[bIndex2];const diffs=[];let aIndex=0;let bIndex=0;const foundSubsequence=(nCommon,aCommon,bCommon)=>{for(;aIndex!==aCommon;aIndex+=1)diffs.push(new Diff(DIFF_DELETE,aLines[aIndex]));for(;bIndex!==bCommon;bIndex+=1)diffs.push(new Diff(DIFF_INSERT,bLines[bIndex]));for(;nCommon!==0;nCommon-=1,aIndex+=1,bIndex+=1)diffs.push(new Diff(DIFF_EQUAL,bLines[bIndex]));};const diffSequences=_default.default||_default;diffSequences(aLength,bLength,isCommon,foundSubsequence);for(;aIndex!==aLength;aIndex+=1)diffs.push(new Diff(DIFF_DELETE,aLines[aIndex]));for(;bIndex!==bLength;bIndex+=1)diffs.push(new Diff(DIFF_INSERT,bLines[bIndex]));return[diffs,truncated];}function getCommonMessage(message,options){const _normalizeDiffOptions=normalizeDiffOptions(options),commonColor=_normalizeDiffOptions.commonColor;return commonColor(message);}const _plugins_2=plugins_1,AsymmetricMatcher$2=_plugins_2.AsymmetricMatcher,DOMCollection$1=_plugins_2.DOMCollection,DOMElement$1=_plugins_2.DOMElement,Immutable$1=_plugins_2.Immutable,ReactElement$1=_plugins_2.ReactElement,ReactTestComponent$1=_plugins_2.ReactTestComponent;const PLUGINS$1=[ReactTestComponent$1,ReactElement$1,DOMElement$1,DOMCollection$1,Immutable$1,AsymmetricMatcher$2];const FORMAT_OPTIONS={plugins:PLUGINS$1};const FALLBACK_FORMAT_OPTIONS={callToJSON:false,maxDepth:10,plugins:PLUGINS$1};function diff(a,b,options){if(Object.is(a,b))return"";const aType=getType(a);let expectedType=aType;let omitDifference=false;if(aType==="object"&&typeof a.asymmetricMatch==="function"){if(a.$$typeof!==Symbol.for("jest.asymmetricMatcher")){return null;}if(typeof a.getExpectedType!=="function"){return null;}expectedType=a.getExpectedType();omitDifference=expectedType==="string";}if(expectedType!==getType(b)){const _normalizeDiffOptions2=normalizeDiffOptions(options),aAnnotation=_normalizeDiffOptions2.aAnnotation,aColor=_normalizeDiffOptions2.aColor,aIndicator=_normalizeDiffOptions2.aIndicator,bAnnotation=_normalizeDiffOptions2.bAnnotation,bColor=_normalizeDiffOptions2.bColor,bIndicator=_normalizeDiffOptions2.bIndicator;const formatOptions=getFormatOptions(FALLBACK_FORMAT_OPTIONS,options);const aDisplay=format_1(a,formatOptions);const bDisplay=format_1(b,formatOptions);const aDiff=\`\${aColor(\`\${aIndicator} \${aAnnotation}:\`)} 
\${aDisplay}\`;const bDiff=\`\${bColor(\`\${bIndicator} \${bAnnotation}:\`)} 
\${bDisplay}\`;return\`\${aDiff}

\${bDiff}\`;}if(omitDifference)return null;switch(aType){case"string":return diffLinesUnified(a.split("\\n"),b.split("\\n"),options);case"boolean":case"number":return comparePrimitive(a,b,options);case"map":return compareObjects(sortMap(a),sortMap(b),options);case"set":return compareObjects(sortSet(a),sortSet(b),options);default:return compareObjects(a,b,options);}}function comparePrimitive(a,b,options){const aFormat=format_1(a,FORMAT_OPTIONS);const bFormat=format_1(b,FORMAT_OPTIONS);return aFormat===bFormat?"":diffLinesUnified(aFormat.split("\\n"),bFormat.split("\\n"),options);}function sortMap(map){return new Map(Array.from(map.entries()).sort());}function sortSet(set){return new Set(Array.from(set.values()).sort());}function compareObjects(a,b,options){let difference;let hasThrown=false;try{const formatOptions=getFormatOptions(FORMAT_OPTIONS,options);difference=getObjectsDifference(a,b,formatOptions,options);}catch{hasThrown=true;}const noDiffMessage=getCommonMessage(NO_DIFF_MESSAGE,options);if(difference===void 0||difference===noDiffMessage){const formatOptions=getFormatOptions(FALLBACK_FORMAT_OPTIONS,options);difference=getObjectsDifference(a,b,formatOptions,options);if(difference!==noDiffMessage&&!hasThrown){difference=\`\${getCommonMessage(SIMILAR_MESSAGE,options)}

\${difference}\`;}}return difference;}function getFormatOptions(formatOptions,options){const _normalizeDiffOptions3=normalizeDiffOptions(options),compareKeys=_normalizeDiffOptions3.compareKeys;return _objectSpread(_objectSpread({},formatOptions),{},{compareKeys});}function getObjectsDifference(a,b,formatOptions,options){const formatOptionsZeroIndent=_objectSpread(_objectSpread({},formatOptions),{},{indent:0});const aCompare=format_1(a,formatOptionsZeroIndent);const bCompare=format_1(b,formatOptionsZeroIndent);if(aCompare===bCompare){return getCommonMessage(NO_DIFF_MESSAGE,options);}else{const aDisplay=format_1(a,formatOptions);const bDisplay=format_1(b,formatOptions);return diffLinesUnified2(aDisplay.split("\\n"),bDisplay.split("\\n"),aCompare.split("\\n"),bCompare.split("\\n"),options);}}const IS_RECORD_SYMBOL="@@__IMMUTABLE_RECORD__@@";const IS_COLLECTION_SYMBOL="@@__IMMUTABLE_ITERABLE__@@";function isImmutable(v){return v&&(v[IS_COLLECTION_SYMBOL]||v[IS_RECORD_SYMBOL]);}const OBJECT_PROTO=Object.getPrototypeOf({});function getUnserializableMessage(err){if(err instanceof Error)return\`<unserializable>: \${err.message}\`;if(typeof err==="string")return\`<unserializable>: \${err}\`;return"<unserializable>";}function serializeError(val,seen=/* @__PURE__ */new WeakMap()){if(!val||typeof val==="string")return val;if(typeof val==="function")return\`Function<\${val.name||"anonymous"}>\`;if(typeof val==="symbol")return val.toString();if(typeof val!=="object")return val;if(isImmutable(val))return serializeError(val.toJSON(),seen);if(val instanceof Promise||val.constructor&&val.constructor.prototype==="AsyncFunction")return"Promise";if(typeof Element!=="undefined"&&val instanceof Element)return val.tagName;if(typeof val.asymmetricMatch==="function")return\`\${val.toString()} \${format(val.sample)}\`;if(typeof val.toJSON==="function")return val.toJSON();if(seen.has(val))return seen.get(val);if(Array.isArray(val)){const clone=new Array(val.length);seen.set(val,clone);val.forEach((e,i)=>{try{clone[i]=serializeError(e,seen);}catch(err){clone[i]=getUnserializableMessage(err);}});return clone;}else{const clone=/* @__PURE__ */Object.create(null);seen.set(val,clone);let obj=val;while(obj&&obj!==OBJECT_PROTO){Object.getOwnPropertyNames(obj).forEach(key=>{if(key in clone)return;try{clone[key]=serializeError(val[key],seen);}catch(err){delete clone[key];clone[key]=getUnserializableMessage(err);}});obj=Object.getPrototypeOf(obj);}return clone;}}function normalizeErrorMessage(message){return message.replace(/__(vite_ssr_import|vi_import)_\\d+__\\./g,"");}function processError(err,diffOptions){if(!err||typeof err!=="object")return{message:err};if(err.stack)err.stackStr=String(err.stack);if(err.name)err.nameStr=String(err.name);if(err.showDiff||err.showDiff===void 0&&err.expected!==void 0&&err.actual!==void 0){const clonedActual=deepClone(err.actual,{forceWritable:true});const clonedExpected=deepClone(err.expected,{forceWritable:true});const _replaceAsymmetricMat=replaceAsymmetricMatcher(clonedActual,clonedExpected),replacedActual=_replaceAsymmetricMat.replacedActual,replacedExpected=_replaceAsymmetricMat.replacedExpected;err.diff=diff(replacedExpected,replacedActual,_objectSpread(_objectSpread({},diffOptions),err.diffOptions));}if(typeof err.expected!=="string")err.expected=stringify(err.expected,10);if(typeof err.actual!=="string")err.actual=stringify(err.actual,10);try{if(typeof err.message==="string")err.message=normalizeErrorMessage(err.message);if(typeof err.cause==="object"&&typeof err.cause.message==="string")err.cause.message=normalizeErrorMessage(err.cause.message);}catch{}try{return serializeError(err);}catch(e){return serializeError(new Error(\`Failed to fully serialize error: \${e==null?void 0:e.message}
Inner error message: \${err==null?void 0:err.message}\`));}}function isAsymmetricMatcher(data){const type=getType$2(data);return type==="Object"&&typeof data.asymmetricMatch==="function";}function isReplaceable(obj1,obj2){const obj1Type=getType$2(obj1);const obj2Type=getType$2(obj2);return obj1Type===obj2Type&&(obj1Type==="Object"||obj1Type==="Array");}function replaceAsymmetricMatcher(actual,expected,actualReplaced=/* @__PURE__ */new WeakSet(),expectedReplaced=/* @__PURE__ */new WeakSet()){if(!isReplaceable(actual,expected))return{replacedActual:actual,replacedExpected:expected};if(actualReplaced.has(actual)||expectedReplaced.has(expected))return{replacedActual:actual,replacedExpected:expected};actualReplaced.add(actual);expectedReplaced.add(expected);getOwnProperties(expected).forEach(key=>{const expectedValue=expected[key];const actualValue=actual[key];if(isAsymmetricMatcher(expectedValue)){if(expectedValue.asymmetricMatch(actualValue))actual[key]=expectedValue;}else if(isAsymmetricMatcher(actualValue)){if(actualValue.asymmetricMatch(expectedValue))expected[key]=actualValue;}else if(isReplaceable(actualValue,expectedValue)){const replaced=replaceAsymmetricMatcher(actualValue,expectedValue,actualReplaced,expectedReplaced);actual[key]=replaced.replacedActual;expected[key]=replaced.replacedExpected;}});return{replacedActual:actual,replacedExpected:expected};}function createChainable(keys,fn){function create(context){const chain2=function(...args){return fn.apply(context,args);};Object.assign(chain2,fn);chain2.withContext=()=>chain2.bind(context);chain2.setContext=(key,value)=>{context[key]=value;};chain2.mergeContext=ctx=>{Object.assign(context,ctx);};for(const key of keys){Object.defineProperty(chain2,key,{get(){return create(_objectSpread(_objectSpread({},context),{},{[key]:true}));}});}return chain2;}const chain=create({});chain.fn=fn;return chain;}function getNames(task){const names=[task.name];let current=task;while((current==null?void 0:current.suite)||(current==null?void 0:current.file)){current=current.suite||current.file;if(current==null?void 0:current.name)names.unshift(current.name);}return names;}const _DRIVE_LETTER_START_RE=/^[A-Za-z]:\\//;function normalizeWindowsPath$1(input=""){if(!input){return input;}return input.replace(/\\\\/g,"/").replace(_DRIVE_LETTER_START_RE,r=>r.toUpperCase());}const _IS_ABSOLUTE_RE$1=/^[/\\\\](?![/\\\\])|^[/\\\\]{2}(?!\\.)|^[A-Za-z]:[/\\\\]/;function cwd$1(){if(typeof process!=="undefined"&&typeof process.cwd==="function"){return process.cwd().replace(/\\\\/g,"/");}return"/";}const resolve$3=function(...arguments_){arguments_=arguments_.map(argument=>normalizeWindowsPath$1(argument));let resolvedPath="";let resolvedAbsolute=false;for(let index=arguments_.length-1;index>=-1&&!resolvedAbsolute;index--){const path=index>=0?arguments_[index]:cwd$1();if(!path||path.length===0){continue;}resolvedPath=\`\${path}/\${resolvedPath}\`;resolvedAbsolute=isAbsolute$1(path);}resolvedPath=normalizeString$1(resolvedPath,!resolvedAbsolute);if(resolvedAbsolute&&!isAbsolute$1(resolvedPath)){return\`/\${resolvedPath}\`;}return resolvedPath.length>0?resolvedPath:".";};function normalizeString$1(path,allowAboveRoot){let res="";let lastSegmentLength=0;let lastSlash=-1;let dots=0;let char=null;for(let index=0;index<=path.length;++index){if(index<path.length){char=path[index];}else if(char==="/"){break;}else{char="/";}if(char==="/"){if(lastSlash===index-1||dots===1);else if(dots===2){if(res.length<2||lastSegmentLength!==2||res[res.length-1]!=="."||res[res.length-2]!=="."){if(res.length>2){const lastSlashIndex=res.lastIndexOf("/");if(lastSlashIndex===-1){res="";lastSegmentLength=0;}else{res=res.slice(0,lastSlashIndex);lastSegmentLength=res.length-1-res.lastIndexOf("/");}lastSlash=index;dots=0;continue;}else if(res.length>0){res="";lastSegmentLength=0;lastSlash=index;dots=0;continue;}}if(allowAboveRoot){res+=res.length>0?"/..":"..";lastSegmentLength=2;}}else{if(res.length>0){res+=\`/\${path.slice(lastSlash+1,index)}\`;}else{res=path.slice(lastSlash+1,index);}lastSegmentLength=index-lastSlash-1;}lastSlash=index;dots=0;}else if(char==="."&&dots!==-1){++dots;}else{dots=-1;}}return res;}const isAbsolute$1=function(p){return _IS_ABSOLUTE_RE$1.test(p);};function normalizeWindowsPath(input=""){if(!input||!input.includes("\\\\")){return input;}return input.replace(/\\\\/g,"/");}const _IS_ABSOLUTE_RE=/^[/\\\\](?![/\\\\])|^[/\\\\]{2}(?!\\.)|^[A-Za-z]:[/\\\\]/;function cwd(){if(typeof process!=="undefined"){return process.cwd().replace(/\\\\/g,"/");}return"/";}const resolve$2=function(...arguments_){arguments_=arguments_.map(argument=>normalizeWindowsPath(argument));let resolvedPath="";let resolvedAbsolute=false;for(let index=arguments_.length-1;index>=-1&&!resolvedAbsolute;index--){const path=index>=0?arguments_[index]:cwd();if(!path||path.length===0){continue;}resolvedPath=\`\${path}/\${resolvedPath}\`;resolvedAbsolute=isAbsolute(path);}resolvedPath=normalizeString(resolvedPath,!resolvedAbsolute);if(resolvedAbsolute&&!isAbsolute(resolvedPath)){return\`/\${resolvedPath}\`;}return resolvedPath.length>0?resolvedPath:".";};function normalizeString(path,allowAboveRoot){let res="";let lastSegmentLength=0;let lastSlash=-1;let dots=0;let char=null;for(let index=0;index<=path.length;++index){if(index<path.length){char=path[index];}else if(char==="/"){break;}else{char="/";}if(char==="/"){if(lastSlash===index-1||dots===1);else if(dots===2){if(res.length<2||lastSegmentLength!==2||res[res.length-1]!=="."||res[res.length-2]!=="."){if(res.length>2){const lastSlashIndex=res.lastIndexOf("/");if(lastSlashIndex===-1){res="";lastSegmentLength=0;}else{res=res.slice(0,lastSlashIndex);lastSegmentLength=res.length-1-res.lastIndexOf("/");}lastSlash=index;dots=0;continue;}else if(res.length>0){res="";lastSegmentLength=0;lastSlash=index;dots=0;continue;}}if(allowAboveRoot){res+=res.length>0?"/..":"..";lastSegmentLength=2;}}else{if(res.length>0){res+=\`/\${path.slice(lastSlash+1,index)}\`;}else{res=path.slice(lastSlash+1,index);}lastSegmentLength=index-lastSlash-1;}lastSlash=index;dots=0;}else if(char==="."&&dots!==-1){++dots;}else{dots=-1;}}return res;}const isAbsolute=function(p){return _IS_ABSOLUTE_RE.test(p);};const chars$1='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';const intToChar$1=new Uint8Array(64);// 64 possible chars.
const charToInt$1=new Uint8Array(128);// z is 122 in ASCII
for(let i=0;i<chars$1.length;i++){const c=chars$1.charCodeAt(i);intToChar$1[i]=c;charToInt$1[c]=i;}var UrlType$1;(function(UrlType){UrlType[UrlType["Empty"]=1]="Empty";UrlType[UrlType["Hash"]=2]="Hash";UrlType[UrlType["Query"]=3]="Query";UrlType[UrlType["RelativePath"]=4]="RelativePath";UrlType[UrlType["AbsolutePath"]=5]="AbsolutePath";UrlType[UrlType["SchemeRelative"]=6]="SchemeRelative";UrlType[UrlType["Absolute"]=7]="Absolute";})(UrlType$1||(UrlType$1={}));const CHROME_IE_STACK_REGEXP$1=/^\\s*at .*(\\S+:\\d+|\\(native\\))/m;const SAFARI_NATIVE_CODE_REGEXP$1=/^(eval@)?(\\[native code])?$/;function extractLocation$1(urlLike){if(!urlLike.includes(":"))return[urlLike];const regExp=/(.+?)(?::(\\d+))?(?::(\\d+))?$/;const parts=regExp.exec(urlLike.replace(/^\\(|\\)$/g,""));if(!parts)return[urlLike];let url=parts[1];if(url.startsWith("http:")||url.startsWith("https:")){const urlObj=new URL(url);url=urlObj.pathname;}if(url.startsWith("/@fs/")){url=url.slice(typeof process!=="undefined"&&process.platform==="win32"?5:4);}return[url,parts[2]||void 0,parts[3]||void 0];}function parseSingleFFOrSafariStack$1(raw){let line=raw.trim();if(SAFARI_NATIVE_CODE_REGEXP$1.test(line))return null;if(line.includes(" > eval"))line=line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,":$1");if(!line.includes("@")&&!line.includes(":"))return null;const functionNameRegex=/((.*".+"[^@]*)?[^@]*)(?:@)/;const matches=line.match(functionNameRegex);const functionName=matches&&matches[1]?matches[1]:void 0;const _extractLocation$=extractLocation$1(line.replace(functionNameRegex,"")),_extractLocation$2=_slicedToArray(_extractLocation$,3),url=_extractLocation$2[0],lineNumber=_extractLocation$2[1],columnNumber=_extractLocation$2[2];if(!url||!lineNumber||!columnNumber)return null;return{file:url,method:functionName||"",line:Number.parseInt(lineNumber),column:Number.parseInt(columnNumber)};}function parseSingleStack(raw){const line=raw.trim();if(!CHROME_IE_STACK_REGEXP$1.test(line))return parseSingleFFOrSafariStack$1(line);return parseSingleV8Stack$1(line);}function parseSingleV8Stack$1(raw){let line=raw.trim();if(!CHROME_IE_STACK_REGEXP$1.test(line))return null;if(line.includes("(eval "))line=line.replace(/eval code/g,"eval").replace(/(\\(eval at [^()]*)|(,.*$)/g,"");let sanitizedLine=line.replace(/^\\s+/,"").replace(/\\(eval code/g,"(").replace(/^.*?\\s+/,"");const location=sanitizedLine.match(/ (\\(.+\\)$)/);sanitizedLine=location?sanitizedLine.replace(location[0],""):sanitizedLine;const _extractLocation$3=extractLocation$1(location?location[1]:sanitizedLine),_extractLocation$4=_slicedToArray(_extractLocation$3,3),url=_extractLocation$4[0],lineNumber=_extractLocation$4[1],columnNumber=_extractLocation$4[2];let method=location&&sanitizedLine||"";let file=url&&["eval","<anonymous>"].includes(url)?void 0:url;if(!file||!lineNumber||!columnNumber)return null;if(method.startsWith("async "))method=method.slice(6);if(file.startsWith("file://"))file=file.slice(7);file=resolve$2(file);if(method)method=method.replace(/__vite_ssr_import_\\d+__\\./g,"");return{method,file,line:Number.parseInt(lineNumber),column:Number.parseInt(columnNumber)};}const fnMap=/* @__PURE__ */new WeakMap();const fixtureMap=/* @__PURE__ */new WeakMap();const hooksMap=/* @__PURE__ */new WeakMap();function setFn(key,fn){fnMap.set(key,fn);}function setFixture(key,fixture){fixtureMap.set(key,fixture);}function getFixture(key){return fixtureMap.get(key);}function setHooks(key,hooks){hooksMap.set(key,hooks);}function getHooks(key){return hooksMap.get(key);}class PendingError extends Error{constructor(message,task){super(message);this.message=message;this.taskId=task.id;}code="VITEST_PENDING";taskId;}const collectorContext={tasks:[],currentSuite:null};function collectTask(task){var _a;(_a=collectorContext.currentSuite)==null?void 0:_a.tasks.push(task);}async function runWithSuite(suite,fn){const prev=collectorContext.currentSuite;collectorContext.currentSuite=suite;await fn();collectorContext.currentSuite=prev;}function withTimeout(fn,timeout,isHook=false){if(timeout<=0||timeout===Number.POSITIVE_INFINITY)return fn;const _getSafeTimers=getSafeTimers(),setTimeout=_getSafeTimers.setTimeout,clearTimeout=_getSafeTimers.clearTimeout;return(...args)=>{return Promise.race([fn(...args),new Promise((resolve,reject)=>{var _a;const timer=setTimeout(()=>{clearTimeout(timer);reject(new Error(makeTimeoutMsg(isHook,timeout)));},timeout);(_a=timer.unref)==null?void 0:_a.call(timer);})]);};}function createTestContext(test,runner){var _a;const context=function(){throw new Error("done() callback is deprecated, use promise instead");};context.task=test;context.skip=()=>{test.pending=true;throw new PendingError("test is skipped; abort execution",test);};context.onTestFailed=fn=>{test.onFailed||(test.onFailed=[]);test.onFailed.push(fn);};context.onTestFinished=fn=>{test.onFinished||(test.onFinished=[]);test.onFinished.push(fn);};return((_a=runner.extendTaskContext)==null?void 0:_a.call(runner,context))||context;}function makeTimeoutMsg(isHook,timeout){return\`\${isHook?"Hook":"Test"} timed out in \${timeout}ms.
If this is a long-running \${isHook?"hook":"test"}, pass a timeout value as the last argument or configure it globally with "\${isHook?"hookTimeout":"testTimeout"}".\`;}function mergeContextFixtures(fixtures,context={}){const fixtureOptionKeys=["auto"];const fixtureArray=Object.entries(fixtures).map(([prop,value])=>{const fixtureItem={value};if(Array.isArray(value)&&value.length>=2&&isObject$1(value[1])&&Object.keys(value[1]).some(key=>fixtureOptionKeys.includes(key))){Object.assign(fixtureItem,value[1]);fixtureItem.value=value[0];}fixtureItem.prop=prop;fixtureItem.isFn=typeof fixtureItem.value==="function";return fixtureItem;});if(Array.isArray(context.fixtures))context.fixtures=context.fixtures.concat(fixtureArray);else context.fixtures=fixtureArray;fixtureArray.forEach(fixture=>{if(fixture.isFn){const usedProps=getUsedProps(fixture.value);if(usedProps.length)fixture.deps=context.fixtures.filter(({prop})=>prop!==fixture.prop&&usedProps.includes(prop));}});return context;}const fixtureValueMaps=/* @__PURE__ */new Map();const cleanupFnArrayMap=/* @__PURE__ */new Map();function withFixtures(fn,testContext){return hookContext=>{const context=hookContext||testContext;if(!context)return fn({});const fixtures=getFixture(context);if(!(fixtures==null?void 0:fixtures.length))return fn(context);const usedProps=getUsedProps(fn);const hasAutoFixture=fixtures.some(({auto})=>auto);if(!usedProps.length&&!hasAutoFixture)return fn(context);if(!fixtureValueMaps.get(context))fixtureValueMaps.set(context,/* @__PURE__ */new Map());const fixtureValueMap=fixtureValueMaps.get(context);if(!cleanupFnArrayMap.has(context))cleanupFnArrayMap.set(context,[]);const cleanupFnArray=cleanupFnArrayMap.get(context);const usedFixtures=fixtures.filter(({prop,auto})=>auto||usedProps.includes(prop));const pendingFixtures=resolveDeps(usedFixtures);if(!pendingFixtures.length)return fn(context);async function resolveFixtures(){for(const fixture of pendingFixtures){if(fixtureValueMap.has(fixture))continue;const resolvedValue=fixture.isFn?await resolveFixtureFunction(fixture.value,context,cleanupFnArray):fixture.value;context[fixture.prop]=resolvedValue;fixtureValueMap.set(fixture,resolvedValue);cleanupFnArray.unshift(()=>{fixtureValueMap.delete(fixture);});}}return resolveFixtures().then(()=>fn(context));};}async function resolveFixtureFunction(fixtureFn,context,cleanupFnArray){const useFnArgPromise=createDefer();let isUseFnArgResolved=false;const fixtureReturn=fixtureFn(context,async useFnArg=>{isUseFnArgResolved=true;useFnArgPromise.resolve(useFnArg);const useReturnPromise=createDefer();cleanupFnArray.push(async()=>{useReturnPromise.resolve();await fixtureReturn;});await useReturnPromise;}).catch(e=>{if(!isUseFnArgResolved){useFnArgPromise.reject(e);return;}throw e;});return useFnArgPromise;}function resolveDeps(fixtures,depSet=/* @__PURE__ */new Set(),pendingFixtures=[]){fixtures.forEach(fixture=>{if(pendingFixtures.includes(fixture))return;if(!fixture.isFn||!fixture.deps){pendingFixtures.push(fixture);return;}if(depSet.has(fixture))throw new Error(\`Circular fixture dependency detected: \${fixture.prop} <- \${[...depSet].reverse().map(d=>d.prop).join(" <- ")}\`);depSet.add(fixture);resolveDeps(fixture.deps,depSet,pendingFixtures);pendingFixtures.push(fixture);depSet.clear();});return pendingFixtures;}function getUsedProps(fn){const match=fn.toString().match(/[^(]*\\(([^)]*)/);if(!match)return[];const args=splitByComma(match[1]);if(!args.length)return[];const first=args[0];if(!(first.startsWith("{")&&first.endsWith("}")))throw new Error(\`The first argument inside a fixture must use object destructuring pattern, e.g. ({ test } => {}). Instead, received "\${first}".\`);const _first=first.slice(1,-1).replace(/\\s/g,"");const props=splitByComma(_first).map(prop=>{return prop.replace(/\\:.*|\\=.*/g,"");});const last=props.at(-1);if(last&&last.startsWith("..."))throw new Error(\`Rest parameters are not supported in fixtures, received "\${last}".\`);return props;}function splitByComma(s){const result=[];const stack=[];let start=0;for(let i=0;i<s.length;i++){if(s[i]==="{"||s[i]==="["){stack.push(s[i]==="{"?"}":"]");}else if(s[i]===stack[stack.length-1]){stack.pop();}else if(!stack.length&&s[i]===","){const token=s.substring(start,i).trim();if(token)result.push(token);start=i+1;}}const lastToken=s.substring(start).trim();if(lastToken)result.push(lastToken);return result;}let _test;function getCurrentTest(){return _test;}const suite=createSuite();createTest(function(name,optionsOrFn,optionsOrTest){getCurrentSuite().test.fn.call(this,formatName(name),optionsOrFn,optionsOrTest);});let runner;let defaultSuite;function getCurrentSuite(){return collectorContext.currentSuite||defaultSuite;}function createSuiteHooks(){return{beforeAll:[],afterAll:[],beforeEach:[],afterEach:[]};}function parseArguments(optionsOrFn,optionsOrTest){let options={};let fn=()=>{};if(typeof optionsOrTest==="object"){if(typeof optionsOrFn==="object")throw new TypeError("Cannot use two objects as arguments. Please provide options and a function callback in that order.");options=optionsOrTest;}else if(typeof optionsOrTest==="number"){options={timeout:optionsOrTest};}else if(typeof optionsOrFn==="object"){options=optionsOrFn;}if(typeof optionsOrFn==="function"){if(typeof optionsOrTest==="function")throw new TypeError("Cannot use two functions as arguments. Please use the second argument for options.");fn=optionsOrFn;}else if(typeof optionsOrTest==="function"){fn=optionsOrTest;}return{options,handler:fn};}function createSuiteCollector(name,factory=()=>{},mode,shuffle,each,suiteOptions){const tasks=[];const factoryQueue=[];let suite2;initSuite();const task=function(name2="",options={}){const task2={id:"",name:name2,suite:void 0,each:options.each,fails:options.fails,context:void 0,type:"custom",retry:options.retry??runner.config.retry,repeats:options.repeats,mode:options.only?"only":options.skip?"skip":options.todo?"todo":"run",meta:options.meta??/* @__PURE__ */Object.create(null)};const handler=options.handler;if(options.concurrent||!options.sequential&&runner.config.sequence.concurrent)task2.concurrent=true;if(shuffle)task2.shuffle=true;const context=createTestContext(task2,runner);Object.defineProperty(task2,"context",{value:context,enumerable:false});setFixture(context,options.fixtures);if(handler){setFn(task2,withTimeout(withFixtures(handler,context),(options==null?void 0:options.timeout)??runner.config.testTimeout));}if(runner.config.includeTaskLocation);tasks.push(task2);return task2;};const test2=createTest(function(name2,optionsOrFn,optionsOrTest){let _parseArguments=parseArguments(optionsOrFn,optionsOrTest),options=_parseArguments.options,handler=_parseArguments.handler;if(typeof suiteOptions==="object")options=Object.assign({},suiteOptions,options);options.concurrent=this.concurrent||!this.sequential&&(options==null?void 0:options.concurrent);options.sequential=this.sequential||!this.concurrent&&(options==null?void 0:options.sequential);const test3=task(formatName(name2),_objectSpread(_objectSpread(_objectSpread({},this),options),{},{handler}));test3.type="test";});const collector={type:"collector",name,mode,options:suiteOptions,test:test2,tasks,collect,task,clear,on:addHook};function addHook(name2,...fn){getHooks(suite2)[name2].push(...fn);}function initSuite(includeLocation){if(typeof suiteOptions==="number")suiteOptions={timeout:suiteOptions};suite2={id:"",type:"suite",name,mode,each,shuffle,tasks:[],meta:/* @__PURE__ */Object.create(null),projectName:""};setHooks(suite2,createSuiteHooks());}function clear(){tasks.length=0;factoryQueue.length=0;initSuite();}async function collect(file){factoryQueue.length=0;if(factory)await runWithSuite(collector,()=>factory(test2));const allChildren=[];for(const i of[...factoryQueue,...tasks])allChildren.push(i.type==="collector"?await i.collect(file):i);suite2.file=file;suite2.tasks=allChildren;allChildren.forEach(task2=>{task2.suite=suite2;if(file)task2.file=file;});return suite2;}collectTask(collector);return collector;}function createSuite(){function suiteFn(name,factoryOrOptions,optionsOrFactory={}){const mode=this.only?"only":this.skip?"skip":this.todo?"todo":"run";const currentSuite=getCurrentSuite();let _parseArguments2=parseArguments(factoryOrOptions,optionsOrFactory),options=_parseArguments2.options,factory=_parseArguments2.handler;if(currentSuite==null?void 0:currentSuite.options)options=_objectSpread(_objectSpread({},currentSuite.options),options);options.concurrent=this.concurrent||!this.sequential&&(options==null?void 0:options.concurrent);options.sequential=this.sequential||!this.concurrent&&(options==null?void 0:options.sequential);return createSuiteCollector(formatName(name),factory,mode,this.shuffle,this.each,options);}suiteFn.each=function(cases,...args){const suite2=this.withContext();this.setContext("each",true);if(Array.isArray(cases)&&args.length)cases=formatTemplateString(cases,args);return(name,optionsOrFn,fnOrOptions)=>{const _name=formatName(name);const arrayOnlyCases=cases.every(Array.isArray);const _parseArguments3=parseArguments(optionsOrFn,fnOrOptions),options=_parseArguments3.options,handler=_parseArguments3.handler;const fnFirst=typeof optionsOrFn==="function";cases.forEach((i,idx)=>{const items=Array.isArray(i)?i:[i];if(fnFirst){arrayOnlyCases?suite2(formatTitle(_name,items,idx),()=>handler(...items),options):suite2(formatTitle(_name,items,idx),()=>handler(i),options);}else{arrayOnlyCases?suite2(formatTitle(_name,items,idx),options,()=>handler(...items)):suite2(formatTitle(_name,items,idx),options,()=>handler(i));}});this.setContext("each",void 0);};};suiteFn.skipIf=condition=>condition?suite.skip:suite;suiteFn.runIf=condition=>condition?suite:suite.skip;return createChainable(["concurrent","sequential","shuffle","skip","only","todo"],suiteFn);}function createTaskCollector(fn,context){const taskFn=fn;taskFn.each=function(cases,...args){const test2=this.withContext();this.setContext("each",true);if(Array.isArray(cases)&&args.length)cases=formatTemplateString(cases,args);return(name,optionsOrFn,fnOrOptions)=>{const _name=formatName(name);const arrayOnlyCases=cases.every(Array.isArray);const _parseArguments4=parseArguments(optionsOrFn,fnOrOptions),options=_parseArguments4.options,handler=_parseArguments4.handler;const fnFirst=typeof optionsOrFn==="function";cases.forEach((i,idx)=>{const items=Array.isArray(i)?i:[i];if(fnFirst){arrayOnlyCases?test2(formatTitle(_name,items,idx),()=>handler(...items),options):test2(formatTitle(_name,items,idx),()=>handler(i),options);}else{arrayOnlyCases?test2(formatTitle(_name,items,idx),options,()=>handler(...items)):test2(formatTitle(_name,items,idx),options,()=>handler(i));}});this.setContext("each",void 0);};};taskFn.skipIf=function(condition){return condition?this.skip:this;};taskFn.runIf=function(condition){return condition?this:this.skip;};taskFn.extend=function(fixtures){const _context=mergeContextFixtures(fixtures,context);return createTest(function fn2(name,optionsOrFn,optionsOrTest){getCurrentSuite().test.fn.call(this,formatName(name),optionsOrFn,optionsOrTest);},_context);};const _test=createChainable(["concurrent","sequential","skip","only","todo","fails"],taskFn);if(context)_test.mergeContext(context);return _test;}function createTest(fn,context){return createTaskCollector(fn,context);}function formatName(name){return typeof name==="string"?name:name instanceof Function?name.name||"<anonymous>":String(name);}function formatTitle(template,items,idx){if(template.includes("%#")){template=template.replace(/%%/g,"__vitest_escaped_%__").replace(/%#/g,\`\${idx}\`).replace(/__vitest_escaped_%__/g,"%%");}const count=template.split("%").length-1;let formatted=format(template,...items.slice(0,count));if(isObject$1(items[0])){formatted=formatted.replace(/\\$([$\\w_.]+)/g,// https://github.com/chaijs/chai/pull/1490
(_,key)=>{var _a,_b;return objDisplay$2(objectAttr(items[0],key),{truncate:(_b=(_a=void 0)==null?void 0:_a.chaiConfig)==null?void 0:_b.truncateThreshold});});}return formatted;}function formatTemplateString(cases,args){const header=cases.join("").trim().replace(/ /g,"").split("\\n").map(i=>i.split("|"))[0];const res=[];for(let i=0;i<Math.floor(args.length/header.length);i++){const oneCase={};for(let j=0;j<header.length;j++)oneCase[header[j]]=args[i*header.length+j];res.push(oneCase);}return res;}function getWorkerState(){const workerState=globalThis.__vitest_worker__;if(!workerState){const errorMsg='Vitest failed to access its internal state.\\n\\nOne of the following is possible:\\n- "vitest" is imported directly without running "vitest" command\\n- "vitest" is imported inside "globalSetup" (to fix this, use "setupFiles" instead, because "globalSetup" runs in a different context)\\n- Otherwise, it might be a Vitest bug. Please report it to https://github.com/vitest-dev/vitest/issues\\n';throw new Error(errorMsg);}return workerState;}function getCurrentEnvironment(){const state=getWorkerState();return state==null?void 0:state.environment.name;}var chai$3={};/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */ /*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new \`{}\`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */function exclude(){var excludes=[].slice.call(arguments);function excludeProps(res,obj){Object.keys(obj).forEach(function(key){if(!~excludes.indexOf(key))res[key]=obj[key];});}return function extendExclude(){var args=[].slice.call(arguments),i=0,res={};for(;i<args.length;i++){excludeProps(res,args[i]);}return res;};}/*!
 * Primary Exports
 */var assertionError=AssertionError$1;/**
 * ### AssertionError
 *
 * An extension of the JavaScript \`Error\` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */function AssertionError$1(message,_props,ssf){var extend=exclude('name','message','stack','constructor','toJSON'),props=extend(_props||{});// default values
this.message=message||'Unspecified AssertionError';this.showDiff=false;// copy from properties
for(var key in props){this[key]=props[key];}// capture stack trace
ssf=ssf||AssertionError$1;if(Error.captureStackTrace){Error.captureStackTrace(this,ssf);}else{try{throw new Error();}catch(e){this.stack=e.stack;}}}/*!
 * Inherit from Error.prototype
 */AssertionError$1.prototype=Object.create(Error.prototype);/*!
 * Statically set name
 */AssertionError$1.prototype.name='AssertionError';/*!
 * Ensure correct constructor
 */AssertionError$1.prototype.constructor=AssertionError$1;/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: \`true\`)
 * @return {Object} object that can be \`JSON.stringify\`
 */AssertionError$1.prototype.toJSON=function(stack){var extend=exclude('constructor','toJSON','stack'),props=extend({name:this.name},this);// include stack if exists and not turned off
if(false!==stack&&this.stack){props.stack=this.stack;}return props;};var utils={};/* !
 * Chai - pathval utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */ /**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has own
 * or inherited from prototype chain named property.
 *
 * Basically does the same thing as the \`in\`
 * operator but works properly with null/undefined values
 * and other primitives.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty(obj, 'str');  // true
 *     hasProperty(obj, 'constructor');  // true
 *     hasProperty(obj, 'bar');  // false
 *
 *     hasProperty(obj.str, 'length'); // true
 *     hasProperty(obj.str, 1);  // true
 *     hasProperty(obj.str, 5);  // false
 *
 *     hasProperty(obj.arr, 'length');  // true
 *     hasProperty(obj.arr, 2);  // true
 *     hasProperty(obj.arr, 3);  // false
 *
 * @param {Object} object
 * @param {String|Symbol} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name hasProperty
 * @api public
 */function hasProperty(obj,name){if(typeof obj==='undefined'||obj===null){return false;}// The \`in\` operator does not work with primitives.
return name in Object(obj);}/* !
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with \`internalGetPathValue\`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be infinitely deep and nested.
 * * Arrays are also valid using the formal \`myobject.document[3].property\`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */function parsePath(path){var str=path.replace(/([^\\\\])\\[/g,'$1.[');var parts=str.match(/(\\\\\\.|[^.]+?)+/g);return parts.map(function mapMatches(value){if(value==='constructor'||value==='__proto__'||value==='prototype'){return{};}var regexp=/^\\[(\\d+)\\]$/;var mArr=regexp.exec(value);var parsed=null;if(mArr){parsed={i:parseFloat(mArr[1])};}else{parsed={p:value.replace(/\\\\([.[\\]])/g,'$1')};}return parsed;});}/* !
 * ## internalGetPathValue(obj, parsed[, pathDepth])
 *
 * Helper companion function for \`.parsePath\` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(obj, parsed);
 *
 * @param {Object} object to search against
 * @param {Object} parsed definition from \`parsePath\`.
 * @param {Number} depth (nesting level) of the property we want to retrieve
 * @returns {Object|Undefined} value
 * @api private
 */function internalGetPathValue(obj,parsed,pathDepth){var temporaryValue=obj;var res=null;pathDepth=typeof pathDepth==='undefined'?parsed.length:pathDepth;for(var i=0;i<pathDepth;i++){var part=parsed[i];if(temporaryValue){if(typeof part.p==='undefined'){temporaryValue=temporaryValue[part.i];}else{temporaryValue=temporaryValue[part.p];}if(i===pathDepth-1){res=temporaryValue;}}}return res;}/* !
 * ## internalSetPathValue(obj, value, parsed)
 *
 * Companion function for \`parsePath\` that sets
 * the value located at a parsed address.
 *
 *  internalSetPathValue(obj, 'value', parsed);
 *
 * @param {Object} object to search and define on
 * @param {*} value to use upon set
 * @param {Object} parsed definition from \`parsePath\`
 * @api private
 */function internalSetPathValue(obj,val,parsed){var tempObj=obj;var pathDepth=parsed.length;var part=null;// Here we iterate through every part of the path
for(var i=0;i<pathDepth;i++){var propName=null;var propVal=null;part=parsed[i];// If it's the last part of the path, we set the 'propName' value with the property name
if(i===pathDepth-1){propName=typeof part.p==='undefined'?part.i:part.p;// Now we set the property with the name held by 'propName' on object with the desired val
tempObj[propName]=val;}else if(typeof part.p!=='undefined'&&tempObj[part.p]){tempObj=tempObj[part.p];}else if(typeof part.i!=='undefined'&&tempObj[part.i]){tempObj=tempObj[part.i];}else{// If the obj doesn't have the property we create one with that name to define it
var next=parsed[i+1];// Here we set the name of the property which will be defined
propName=typeof part.p==='undefined'?part.i:part.p;// Here we decide if this property will be an array or a new object
propVal=typeof next.p==='undefined'?[]:{};tempObj[propName]=propVal;tempObj=tempObj[propName];}}}/**
 * ### .getPathInfo(object, path)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by \`path\`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise \`undefined\`
 * * exists - Whether the property exists or not
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */function getPathInfo(obj,path){var parsed=parsePath(path);var last=parsed[parsed.length-1];var info={parent:parsed.length>1?internalGetPathValue(obj,parsed,parsed.length-1):obj,name:last.p||last.i,value:internalGetPathValue(obj,parsed)};info.exists=hasProperty(info.parent,info.name);return info;}/**
 * ### .getPathValue(object, path)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue(obj, 'prop1.str'); // Hello
 *     getPathValue(obj, 'prop1.att[2]'); // b
 *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} value or \`undefined\`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */function getPathValue(obj,path){var info=getPathInfo(obj,path);return info.value;}/**
 * ### .setPathValue(object, path, value)
 *
 * Define the value in an object at a given string path.
 *
 * \`\`\`js
 * var obj = {
 *     prop1: {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *   , prop2: {
 *         arr: [ { nested: 'Universe' } ]
 *       , str: 'Hello again!'
 *     }
 * };
 * \`\`\`
 *
 * The following would be acceptable.
 *
 * \`\`\`js
 * var properties = require('tea-properties');
 * properties.set(obj, 'prop1.str', 'Hello Universe!');
 * properties.set(obj, 'prop1.arr[2]', 'B');
 * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
 * \`\`\`
 *
 * @param {Object} object
 * @param {String} path
 * @param {Mixed} value
 * @api private
 */function setPathValue(obj,path,val){var parsed=parsePath(path);internalSetPathValue(obj,val,parsed);return obj;}var pathval={hasProperty:hasProperty,getPathInfo:getPathInfo,getPathValue:getPathValue,setPathValue:setPathValue};/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or \`undefined\` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns \`bar\`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */var flag$5=function flag(obj,key,value){var flags=obj.__flags||(obj.__flags=Object.create(null));if(arguments.length===3){flags[key]=value;}else{return flags[key];}};/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Module dependencies
 */var flag$4=flag$5;/**
 * ### .test(object, expression)
 *
 * Test an object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */var test$1=function test(obj,args){var negate=flag$4(obj,'negate'),expr=args[0];return negate?!expr:expr;};var typeDetect$1={exports:{}};(function(module,exports){(function(global,factory){module.exports=factory();})(commonjsGlobal$1,function(){/* !
     * type-detect
     * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
     * MIT Licensed
     */var promiseExists=typeof Promise==='function';/* eslint-disable no-undef */var globalObject=typeof self==='object'?self:commonjsGlobal$1;// eslint-disable-line id-blacklist
var symbolExists=typeof Symbol!=='undefined';var mapExists=typeof Map!=='undefined';var setExists=typeof Set!=='undefined';var weakMapExists=typeof WeakMap!=='undefined';var weakSetExists=typeof WeakSet!=='undefined';var dataViewExists=typeof DataView!=='undefined';var symbolIteratorExists=symbolExists&&typeof Symbol.iterator!=='undefined';var symbolToStringTagExists=symbolExists&&typeof Symbol.toStringTag!=='undefined';var setEntriesExists=setExists&&typeof Set.prototype.entries==='function';var mapEntriesExists=mapExists&&typeof Map.prototype.entries==='function';var setIteratorPrototype=setEntriesExists&&Object.getPrototypeOf(new Set().entries());var mapIteratorPrototype=mapEntriesExists&&Object.getPrototypeOf(new Map().entries());var arrayIteratorExists=symbolIteratorExists&&typeof Array.prototype[Symbol.iterator]==='function';var arrayIteratorPrototype=arrayIteratorExists&&Object.getPrototypeOf([][Symbol.iterator]());var stringIteratorExists=symbolIteratorExists&&typeof String.prototype[Symbol.iterator]==='function';var stringIteratorPrototype=stringIteratorExists&&Object.getPrototypeOf(''[Symbol.iterator]());var toStringLeftSliceLength=8;var toStringRightSliceLength=-1;/**
     * ### typeOf (obj)
     *
     * Uses \`Object.prototype.toString\` to determine the type of an object,
     * normalising behaviour across engine versions & well optimised.
     *
     * @param {Mixed} object
     * @return {String} object type
     * @api public
     */function typeDetect(obj){/* ! Speed optimisation
       * Pre:
       *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
       *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
       *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
       *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
       *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
       * Post:
       *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
       *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
       *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
       *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
       *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
       */var typeofObj=typeof obj;if(typeofObj!=='object'){return typeofObj;}/* ! Speed optimisation
       * Pre:
       *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
       * Post:
       *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
       */if(obj===null){return'null';}/* ! Spec Conformance
       * Test: \`Object.prototype.toString.call(window)\`\`
       *  - Node === "[object global]"
       *  - Chrome === "[object global]"
       *  - Firefox === "[object Window]"
       *  - PhantomJS === "[object Window]"
       *  - Safari === "[object Window]"
       *  - IE 11 === "[object Window]"
       *  - IE Edge === "[object Window]"
       * Test: \`Object.prototype.toString.call(this)\`\`
       *  - Chrome Worker === "[object global]"
       *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
       *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
       *  - IE 11 Worker === "[object WorkerGlobalScope]"
       *  - IE Edge Worker === "[object WorkerGlobalScope]"
       */if(obj===globalObject){return'global';}/* ! Speed optimisation
       * Pre:
       *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
       * Post:
       *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
       */if(Array.isArray(obj)&&(symbolToStringTagExists===false||!(Symbol.toStringTag in obj))){return'Array';}// Not caching existence of \`window\` and related properties due to potential
// for \`window\` to be unset before tests in quasi-browser environments.
if(typeof window==='object'&&window!==null){/* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/browsers.html#location)
         * WhatWG HTML$7.7.3 - The \`Location\` interface
         * Test: \`Object.prototype.toString.call(window.location)\`\`
         *  - IE <=11 === "[object Object]"
         *  - IE Edge <=13 === "[object Object]"
         */if(typeof window.location==='object'&&obj===window.location){return'Location';}/* ! Spec Conformance
         * (https://html.spec.whatwg.org/#document)
         * WhatWG HTML$3.1.1 - The \`Document\` object
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         *       WhatWG HTML states:
         *         > For historical reasons, Window objects must also have a
         *         > writable, configurable, non-enumerable property named
         *         > HTMLDocument whose value is the Document interface object.
         * Test: \`Object.prototype.toString.call(document)\`\`
         *  - Chrome === "[object HTMLDocument]"
         *  - Firefox === "[object HTMLDocument]"
         *  - Safari === "[object HTMLDocument]"
         *  - IE <=10 === "[object Document]"
         *  - IE 11 === "[object HTMLDocument]"
         *  - IE Edge <=13 === "[object HTMLDocument]"
         */if(typeof window.document==='object'&&obj===window.document){return'Document';}if(typeof window.navigator==='object'){/* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
           * Test: \`Object.prototype.toString.call(navigator.mimeTypes)\`\`
           *  - IE <=10 === "[object MSMimeTypesCollection]"
           */if(typeof window.navigator.mimeTypes==='object'&&obj===window.navigator.mimeTypes){return'MimeTypeArray';}/* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
           * Test: \`Object.prototype.toString.call(navigator.plugins)\`\`
           *  - IE <=10 === "[object MSPluginsCollection]"
           */if(typeof window.navigator.plugins==='object'&&obj===window.navigator.plugins){return'PluginArray';}}if((typeof window.HTMLElement==='function'||typeof window.HTMLElement==='object')&&obj instanceof window.HTMLElement){/* ! Spec Conformance
          * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
          * WhatWG HTML$4.4.4 - The \`blockquote\` element - Interface \`HTMLQuoteElement\`
          * Test: \`Object.prototype.toString.call(document.createElement('blockquote'))\`\`
          *  - IE <=10 === "[object HTMLBlockElement]"
          */if(obj.tagName==='BLOCKQUOTE'){return'HTMLQuoteElement';}/* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltabledatacellelement)
           * WhatWG HTML$4.9.9 - The \`td\` element - Interface \`HTMLTableDataCellElement\`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('td'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */if(obj.tagName==='TD'){return'HTMLTableDataCellElement';}/* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltableheadercellelement)
           * WhatWG HTML$4.9.9 - The \`td\` element - Interface \`HTMLTableHeaderCellElement\`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('th'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */if(obj.tagName==='TH'){return'HTMLTableHeaderCellElement';}}}/* ! Speed optimisation
      * Pre:
      *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
      *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
      *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
      *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
      *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
      *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
      *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
      *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
      *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
      * Post:
      *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
      *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
      *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
      *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
      *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
      *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
      *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
      *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
      *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
      */var stringTag=symbolToStringTagExists&&obj[Symbol.toStringTag];if(typeof stringTag==='string'){return stringTag;}var objPrototype=Object.getPrototypeOf(obj);/* ! Speed optimisation
      * Pre:
      *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
      *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
      * Post:
      *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
      *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
      */if(objPrototype===RegExp.prototype){return'RegExp';}/* ! Speed optimisation
      * Pre:
      *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
      * Post:
      *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
      */if(objPrototype===Date.prototype){return'Date';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
       * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
       * Test: \`Object.prototype.toString.call(Promise.resolve())\`\`
       *  - Chrome <=47 === "[object Object]"
       *  - Edge <=20 === "[object Object]"
       *  - Firefox 29-Latest === "[object Promise]"
       *  - Safari 7.1-Latest === "[object Promise]"
       */if(promiseExists&&objPrototype===Promise.prototype){return'Promise';}/* ! Speed optimisation
      * Pre:
      *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
      * Post:
      *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
      */if(setExists&&objPrototype===Set.prototype){return'Set';}/* ! Speed optimisation
      * Pre:
      *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
      * Post:
      *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
      */if(mapExists&&objPrototype===Map.prototype){return'Map';}/* ! Speed optimisation
      * Pre:
      *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
      * Post:
      *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
      */if(weakSetExists&&objPrototype===WeakSet.prototype){return'WeakSet';}/* ! Speed optimisation
      * Pre:
      *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
      * Post:
      *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
      */if(weakMapExists&&objPrototype===WeakMap.prototype){return'WeakMap';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
       * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
       * Test: \`Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))\`\`
       *  - Edge <=13 === "[object Object]"
       */if(dataViewExists&&objPrototype===DataView.prototype){return'DataView';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
       * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
       * Test: \`Object.prototype.toString.call(new Map().entries())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(mapExists&&objPrototype===mapIteratorPrototype){return'Map Iterator';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
       * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
       * Test: \`Object.prototype.toString.call(new Set().entries())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(setExists&&objPrototype===setIteratorPrototype){return'Set Iterator';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
       * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
       * Test: \`Object.prototype.toString.call([][Symbol.iterator]())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(arrayIteratorExists&&objPrototype===arrayIteratorPrototype){return'Array Iterator';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
       * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
       * Test: \`Object.prototype.toString.call(''[Symbol.iterator]())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(stringIteratorExists&&objPrototype===stringIteratorPrototype){return'String Iterator';}/* ! Speed optimisation
      * Pre:
      *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
      * Post:
      *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
      */if(objPrototype===null){return'Object';}return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength,toStringRightSliceLength);}return typeDetect;});})(typeDetect$1);var typeDetectExports$1=typeDetect$1.exports;/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */var AssertionError=assertionError;var flag$3=flag$5;var type$3=typeDetectExports$1;var expectTypes=function expectTypes(obj,types){var flagMsg=flag$3(obj,'message');var ssfi=flag$3(obj,'ssfi');flagMsg=flagMsg?flagMsg+': ':'';obj=flag$3(obj,'object');types=types.map(function(t){return t.toLowerCase();});types.sort();// Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'
var str=types.map(function(t,index){var art=~['a','e','i','o','u'].indexOf(t.charAt(0))?'an':'a';var or=types.length>1&&index===types.length-1?'or ':'';return or+art+' '+t;}).join(', ');var objType=type$3(obj).toLowerCase();if(!types.some(function(expected){return objType===expected;})){throw new AssertionError(flagMsg+'object tested must be '+str+', but '+objType+' given',undefined,ssfi);}};/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .getActual(object, [actual])
 *
 * Returns the \`actual\` value for an Assertion.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */var getActual$1=function getActual(obj,args){return args.length>4?args[4]:obj._obj;};const require$$1=/*@__PURE__*/getAugmentedNamespace(loupe$1);var config$5={/**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */includeStack:false,/**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the \`showDiff\` flag should be included in the thrown
   * AssertionErrors. \`false\` will always be \`false\`; \`true\`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */showDiff:true,/**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like \`[ Array(3) ]\` or \`{ Object (prop1, prop2) }\`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */truncateThreshold:40,/**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {Boolean}
   * @api public
   */useProxy:true,/**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the \`useProxy\` configuration setting is enabled.
   * By default, \`then\` and \`inspect\` will not throw an error if they do not exist on the
   * assertion object because the \`.inspect\` property is read by \`util.inspect\` (for example, when
   * using \`console.log\` on the assertion object) and \`.then\` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @api public
   */proxyExcludedKeys:['then','catch','inspect','toJSON'],/**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the \`deep-eql\` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *        return chai.util.eql(expected, actual, {
   *           comparator: (expected, actual) => {
   *              // for non number comparison, use the default behavior
   *              if(typeof expected !== 'number') return null;
   *              // allow a difference of 10 between compared numbers
   *              return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *           }
   *        })
   *     };
   *
   * @param {Function}
   * @api public
   */deepEqual:null};var loupe=require$$1;var config$4=config$5;var inspect_1=inspect$2;/**
 * ### .inspect(obj, [showHidden], [depth], [colors])
 *
 * Echoes the value of a value. Tries to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects. Default is false.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 * @namespace Utils
 * @name inspect
 */function inspect$2(obj,showHidden,depth,colors){var options={colors:colors,depth:typeof depth==='undefined'?2:depth,showHidden:showHidden,truncate:config$4.truncateThreshold?config$4.truncateThreshold:Infinity};return loupe.inspect(obj,options);}/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Module dependencies
 */var inspect$1=inspect_1;var config$3=config$5;/**
 * ### .objDisplay(object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @returns {string} stringified object
 * @name objDisplay
 * @namespace Utils
 * @api public
 */var objDisplay$1=function objDisplay(obj){var str=inspect$1(obj),type=Object.prototype.toString.call(obj);if(config$3.truncateThreshold&&str.length>=config$3.truncateThreshold){if(type==='[object Function]'){return!obj.name||obj.name===''?'[Function]':'[Function: '+obj.name+']';}else if(type==='[object Array]'){return'[ Array('+obj.length+') ]';}else if(type==='[object Object]'){var keys=Object.keys(obj),kstr=keys.length>2?keys.splice(0,2).join(', ')+', ...':keys.join(', ');return'{ Object ('+kstr+') }';}else{return str;}}else{return str;}};/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Module dependencies
 */var flag$2=flag$5,getActual=getActual$1,objDisplay=objDisplay$1;/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - \`#{this}\` current asserted object
 * - \`#{act}\` actual value
 * - \`#{exp}\` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */var getMessage$1=function getMessage(obj,args){var negate=flag$2(obj,'negate'),val=flag$2(obj,'object'),expected=args[3],actual=getActual(obj,args),msg=negate?args[2]:args[1],flagMsg=flag$2(obj,'message');if(typeof msg==="function")msg=msg();msg=msg||'';msg=msg.replace(/#\\{this\\}/g,function(){return objDisplay(val);}).replace(/#\\{act\\}/g,function(){return objDisplay(actual);}).replace(/#\\{exp\\}/g,function(){return objDisplay(expected);});return flagMsg?flagMsg+': '+msg:msg;};/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for \`assertion\` to \`object\`. If
 * \`includeAll\` is set to \`false\`, then the base Chai
 * assertion flags (namely \`object\`, \`ssfi\`, \`lockSsfi\`,
 * and \`message\`) will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAssertion = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */var transferFlags=function transferFlags(assertion,object,includeAll){var flags=assertion.__flags||(assertion.__flags=Object.create(null));if(!object.__flags){object.__flags=Object.create(null);}includeAll=arguments.length===3?includeAll:true;for(var flag in flags){if(includeAll||flag!=='object'&&flag!=='ssfi'&&flag!=='lockSsfi'&&flag!='message'){object.__flags[flag]=flags[flag];}}};var deepEql={exports:{}};/* globals Symbol: false, Uint8Array: false, WeakMap: false */ /*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var type$2=typeDetectExports$1;function FakeMap(){this._key='chai/deep-eql__'+Math.random()+Date.now();}FakeMap.prototype={get:function get(key){return key[this._key];},set:function set(key,value){if(Object.isExtensible(key)){Object.defineProperty(key,this._key,{value:value,configurable:true});}}};var MemoizeMap=typeof WeakMap==='function'?WeakMap:FakeMap;/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/function memoizeCompare(leftHandOperand,rightHandOperand,memoizeMap){// Technically, WeakMap keys can *only* be objects, not primitives.
if(!memoizeMap||isPrimitive$1(leftHandOperand)||isPrimitive$1(rightHandOperand)){return null;}var leftHandMap=memoizeMap.get(leftHandOperand);if(leftHandMap){var result=leftHandMap.get(rightHandOperand);if(typeof result==='boolean'){return result;}}return null;}/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/function memoizeSet(leftHandOperand,rightHandOperand,memoizeMap,result){// Technically, WeakMap keys can *only* be objects, not primitives.
if(!memoizeMap||isPrimitive$1(leftHandOperand)||isPrimitive$1(rightHandOperand)){return;}var leftHandMap=memoizeMap.get(leftHandOperand);if(leftHandMap){leftHandMap.set(rightHandOperand,result);}else{leftHandMap=new MemoizeMap();leftHandMap.set(rightHandOperand,result);memoizeMap.set(leftHandOperand,leftHandMap);}}/*!
 * Primary Export
 */deepEql.exports=deepEqual;deepEql.exports.MemoizeMap=MemoizeMap;/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing \`false\` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */function deepEqual(leftHandOperand,rightHandOperand,options){// If we have a comparator, we can't assume anything; so bail to its check first.
if(options&&options.comparator){return extensiveDeepEqual(leftHandOperand,rightHandOperand,options);}var simpleResult=simpleEqual(leftHandOperand,rightHandOperand);if(simpleResult!==null){return simpleResult;}// Deeper comparisons are pushed through to a larger function
return extensiveDeepEqual(leftHandOperand,rightHandOperand,options);}/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */function simpleEqual(leftHandOperand,rightHandOperand){// Equal references (except for Numbers) can be returned early
if(leftHandOperand===rightHandOperand){// Handle +-0 cases
return leftHandOperand!==0||1/leftHandOperand===1/rightHandOperand;}// handle NaN cases
if(leftHandOperand!==leftHandOperand&&// eslint-disable-line no-self-compare
rightHandOperand!==rightHandOperand// eslint-disable-line no-self-compare
){return true;}// Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
// strings, and undefined, can be compared by reference.
if(isPrimitive$1(leftHandOperand)||isPrimitive$1(rightHandOperand)){// Easy out b/c it would have passed the first equality check
return false;}return null;}/*!
 * The main logic of the \`deepEqual\` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing \`false\` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/function extensiveDeepEqual(leftHandOperand,rightHandOperand,options){options=options||{};options.memoize=options.memoize===false?false:options.memoize||new MemoizeMap();var comparator=options&&options.comparator;// Check if a memoized result exists.
var memoizeResultLeft=memoizeCompare(leftHandOperand,rightHandOperand,options.memoize);if(memoizeResultLeft!==null){return memoizeResultLeft;}var memoizeResultRight=memoizeCompare(rightHandOperand,leftHandOperand,options.memoize);if(memoizeResultRight!==null){return memoizeResultRight;}// If a comparator is present, use it.
if(comparator){var comparatorResult=comparator(leftHandOperand,rightHandOperand);// Comparators may return null, in which case we want to go back to default behavior.
if(comparatorResult===false||comparatorResult===true){memoizeSet(leftHandOperand,rightHandOperand,options.memoize,comparatorResult);return comparatorResult;}// To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
// what to do, we need to make sure to return the basic tests first before we move on.
var simpleResult=simpleEqual(leftHandOperand,rightHandOperand);if(simpleResult!==null){// Don't memoize this, it takes longer to set/retrieve than to just compare.
return simpleResult;}}var leftHandType=type$2(leftHandOperand);if(leftHandType!==type$2(rightHandOperand)){memoizeSet(leftHandOperand,rightHandOperand,options.memoize,false);return false;}// Temporarily set the operands in the memoize object to prevent blowing the stack
memoizeSet(leftHandOperand,rightHandOperand,options.memoize,true);var result=extensiveDeepEqualByType(leftHandOperand,rightHandOperand,leftHandType,options);memoizeSet(leftHandOperand,rightHandOperand,options.memoize,result);return result;}function extensiveDeepEqualByType(leftHandOperand,rightHandOperand,leftHandType,options){switch(leftHandType){case'String':case'Number':case'Boolean':case'Date':// If these types are their instance types (e.g. \`new Number\`) then re-deepEqual against their values
return deepEqual(leftHandOperand.valueOf(),rightHandOperand.valueOf());case'Promise':case'Symbol':case'function':case'WeakMap':case'WeakSet':return leftHandOperand===rightHandOperand;case'Error':return keysEqual(leftHandOperand,rightHandOperand,['name','message','code'],options);case'Arguments':case'Int8Array':case'Uint8Array':case'Uint8ClampedArray':case'Int16Array':case'Uint16Array':case'Int32Array':case'Uint32Array':case'Float32Array':case'Float64Array':case'Array':return iterableEqual(leftHandOperand,rightHandOperand,options);case'RegExp':return regexpEqual(leftHandOperand,rightHandOperand);case'Generator':return generatorEqual(leftHandOperand,rightHandOperand,options);case'DataView':return iterableEqual(new Uint8Array(leftHandOperand.buffer),new Uint8Array(rightHandOperand.buffer),options);case'ArrayBuffer':return iterableEqual(new Uint8Array(leftHandOperand),new Uint8Array(rightHandOperand),options);case'Set':return entriesEqual(leftHandOperand,rightHandOperand,options);case'Map':return entriesEqual(leftHandOperand,rightHandOperand,options);case'Temporal.PlainDate':case'Temporal.PlainTime':case'Temporal.PlainDateTime':case'Temporal.Instant':case'Temporal.ZonedDateTime':case'Temporal.PlainYearMonth':case'Temporal.PlainMonthDay':return leftHandOperand.equals(rightHandOperand);case'Temporal.Duration':return leftHandOperand.total('nanoseconds')===rightHandOperand.total('nanoseconds');case'Temporal.TimeZone':case'Temporal.Calendar':return leftHandOperand.toString()===rightHandOperand.toString();default:return objectEqual(leftHandOperand,rightHandOperand,options);}}/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */function regexpEqual(leftHandOperand,rightHandOperand){return leftHandOperand.toString()===rightHandOperand.toString();}/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function entriesEqual(leftHandOperand,rightHandOperand,options){// IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
if(leftHandOperand.size!==rightHandOperand.size){return false;}if(leftHandOperand.size===0){return true;}var leftHandItems=[];var rightHandItems=[];leftHandOperand.forEach(function gatherEntries(key,value){leftHandItems.push([key,value]);});rightHandOperand.forEach(function gatherEntries(key,value){rightHandItems.push([key,value]);});return iterableEqual(leftHandItems.sort(),rightHandItems.sort(),options);}/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function iterableEqual(leftHandOperand,rightHandOperand,options){var length=leftHandOperand.length;if(length!==rightHandOperand.length){return false;}if(length===0){return true;}var index=-1;while(++index<length){if(deepEqual(leftHandOperand[index],rightHandOperand[index],options)===false){return false;}}return true;}/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function generatorEqual(leftHandOperand,rightHandOperand,options){return iterableEqual(getGeneratorEntries(leftHandOperand),getGeneratorEntries(rightHandOperand),options);}/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} \`true\` if the object has an @@iterator function.
 */function hasIteratorFunction(target){return typeof Symbol!=='undefined'&&typeof target==='object'&&typeof Symbol.iterator!=='undefined'&&typeof target[Symbol.iterator]==='function';}/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */function getIteratorEntries(target){if(hasIteratorFunction(target)){try{return getGeneratorEntries(target[Symbol.iterator]());}catch(iteratorError){return[];}}return[];}/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */function getGeneratorEntries(generator){var generatorResult=generator.next();var accumulator=[generatorResult.value];while(generatorResult.done===false){generatorResult=generator.next();accumulator.push(generatorResult.value);}return accumulator;}/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */function getEnumerableKeys(target){var keys=[];for(var key in target){keys.push(key);}return keys;}function getEnumerableSymbols(target){var keys=[];var allKeys=Object.getOwnPropertySymbols(target);for(var i=0;i<allKeys.length;i+=1){var key=allKeys[i];if(Object.getOwnPropertyDescriptor(target,key).enumerable){keys.push(key);}}return keys;}/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function keysEqual(leftHandOperand,rightHandOperand,keys,options){var length=keys.length;if(length===0){return true;}for(var i=0;i<length;i+=1){if(deepEqual(leftHandOperand[keys[i]],rightHandOperand[keys[i]],options)===false){return false;}}return true;}/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to \`deepEqual\`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function objectEqual(leftHandOperand,rightHandOperand,options){var leftHandKeys=getEnumerableKeys(leftHandOperand);var rightHandKeys=getEnumerableKeys(rightHandOperand);var leftHandSymbols=getEnumerableSymbols(leftHandOperand);var rightHandSymbols=getEnumerableSymbols(rightHandOperand);leftHandKeys=leftHandKeys.concat(leftHandSymbols);rightHandKeys=rightHandKeys.concat(rightHandSymbols);if(leftHandKeys.length&&leftHandKeys.length===rightHandKeys.length){if(iterableEqual(mapSymbols(leftHandKeys).sort(),mapSymbols(rightHandKeys).sort())===false){return false;}return keysEqual(leftHandOperand,rightHandOperand,leftHandKeys,options);}var leftHandEntries=getIteratorEntries(leftHandOperand);var rightHandEntries=getIteratorEntries(rightHandOperand);if(leftHandEntries.length&&leftHandEntries.length===rightHandEntries.length){leftHandEntries.sort();rightHandEntries.sort();return iterableEqual(leftHandEntries,rightHandEntries,options);}if(leftHandKeys.length===0&&leftHandEntries.length===0&&rightHandKeys.length===0&&rightHandEntries.length===0){return true;}return false;}/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */function isPrimitive$1(value){return value===null||typeof value!=='object';}function mapSymbols(arr){return arr.map(function mapSymbol(entry){if(typeof entry==='symbol'){return entry.toString();}return entry;});}var deepEqlExports=deepEql.exports;var config$2=config$5;/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .isProxyEnabled()
 *
 * Helper function to check if Chai's proxy protection feature is enabled. If
 * proxies are unsupported or disabled via the user's Chai config, then return
 * false. Otherwise, return true.
 *
 * @namespace Utils
 * @name isProxyEnabled
 */var isProxyEnabled$1=function isProxyEnabled(){return config$2.useProxy&&typeof Proxy!=='undefined'&&typeof Reflect!=='undefined';};/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var addProperty;var hasRequiredAddProperty;function requireAddProperty(){if(hasRequiredAddProperty)return addProperty;hasRequiredAddProperty=1;var chai=requireChai();var flag=flag$5;var isProxyEnabled=isProxyEnabled$1;var transferFlags$1=transferFlags;/**
   * ### .addProperty(ctx, name, getter)
   *
   * Adds a property to the prototype of an object.
   *
   *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
   *       var obj = utils.flag(this, 'object');
   *       new chai.Assertion(obj).to.be.instanceof(Foo);
   *     });
   *
   * Can also be accessed directly from \`chai.Assertion\`.
   *
   *     chai.Assertion.addProperty('foo', fn);
   *
   * Then can be used as any other assertion.
   *
   *     expect(myFoo).to.be.foo;
   *
   * @param {Object} ctx object to which the property is added
   * @param {String} name of property to add
   * @param {Function} getter function to be used for name
   * @namespace Utils
   * @name addProperty
   * @api public
   */addProperty=function addProperty(ctx,name,getter){getter=getter===undefined?function(){}:getter;Object.defineProperty(ctx,name,{get:function propertyGetter(){// Setting the \`ssfi\` flag to \`propertyGetter\` causes this function to
// be the starting point for removing implementation frames from the
// stack trace of a failed assertion.
//
// However, we only want to use this function as the starting point if
// the \`lockSsfi\` flag isn't set and proxy protection is disabled.
//
// If the \`lockSsfi\` flag is set, then either this assertion has been
// overwritten by another assertion, or this assertion is being invoked
// from inside of another assertion. In the first case, the \`ssfi\` flag
// has already been set by the overwriting assertion. In the second
// case, the \`ssfi\` flag has already been set by the outer assertion.
//
// If proxy protection is enabled, then the \`ssfi\` flag has already been
// set by the proxy getter.
if(!isProxyEnabled()&&!flag(this,'lockSsfi')){flag(this,'ssfi',propertyGetter);}var result=getter.call(this);if(result!==undefined)return result;var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;},configurable:true});};return addProperty;}var fnLengthDesc=Object.getOwnPropertyDescriptor(function(){},'length');/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .addLengthGuard(fn, assertionName, isChainable)
 *
 * Define \`length\` as a getter on the given uninvoked method assertion. The
 * getter acts as a guard against chaining \`length\` directly off of an uninvoked
 * method assertion, which is a problem because it references \`function\`'s
 * built-in \`length\` property instead of Chai's \`length\` assertion. When the
 * getter catches the user making this mistake, it throws an error with a
 * helpful message.
 *
 * There are two ways in which this mistake can be made. The first way is by
 * chaining the \`length\` assertion directly off of an uninvoked chainable
 * method. In this case, Chai suggests that the user use \`lengthOf\` instead. The
 * second way is by chaining the \`length\` assertion directly off of an uninvoked
 * non-chainable method. Non-chainable methods must be invoked prior to
 * chaining. In this case, Chai suggests that the user consult the docs for the
 * given assertion.
 *
 * If the \`length\` property of functions is unconfigurable, then return \`fn\`
 * without modification.
 *
 * Note that in ES6, the function's \`length\` property is configurable, so once
 * support for legacy environments is dropped, Chai's \`length\` property can
 * replace the built-in function's \`length\` property, and this length guard will
 * no longer be necessary. In the mean time, maintaining consistency across all
 * environments is the priority.
 *
 * @param {Function} fn
 * @param {String} assertionName
 * @param {Boolean} isChainable
 * @namespace Utils
 * @name addLengthGuard
 */var addLengthGuard=function addLengthGuard(fn,assertionName,isChainable){if(!fnLengthDesc.configurable)return fn;Object.defineProperty(fn,'length',{get:function(){if(isChainable){throw Error('Invalid Chai property: '+assertionName+'.length. Due'+' to a compatibility issue, "length" cannot directly follow "'+assertionName+'". Use "'+assertionName+'.lengthOf" instead.');}throw Error('Invalid Chai property: '+assertionName+'.length. See'+' docs for proper usage of "'+assertionName+'".');}});return fn;};/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */var getProperties$1=function getProperties(object){var result=Object.getOwnPropertyNames(object);function addProperty(property){if(result.indexOf(property)===-1){result.push(property);}}var proto=Object.getPrototypeOf(object);while(proto!==null){Object.getOwnPropertyNames(proto).forEach(addProperty);proto=Object.getPrototypeOf(proto);}return result;};var config$1=config$5;var flag$1=flag$5;var getProperties=getProperties$1;var isProxyEnabled=isProxyEnabled$1;/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .proxify(object)
 *
 * Return a proxy of given object that throws an error when a non-existent
 * property is read. By default, the root cause is assumed to be a misspelled
 * property, and thus an attempt is made to offer a reasonable suggestion from
 * the list of existing properties. However, if a nonChainableMethodName is
 * provided, then the root cause is instead a failure to invoke a non-chainable
 * method prior to reading the non-existent property.
 *
 * If proxies are unsupported or disabled via the user's Chai config, then
 * return object without modification.
 *
 * @param {Object} obj
 * @param {String} nonChainableMethodName
 * @namespace Utils
 * @name proxify
 */var builtins=['__flags','__methods','_obj','assert'];var proxify=function proxify(obj,nonChainableMethodName){if(!isProxyEnabled())return obj;return new Proxy(obj,{get:function proxyGetter(target,property){// This check is here because we should not throw errors on Symbol properties
// such as \`Symbol.toStringTag\`.
// The values for which an error should be thrown can be configured using
// the \`config.proxyExcludedKeys\` setting.
if(typeof property==='string'&&config$1.proxyExcludedKeys.indexOf(property)===-1&&!Reflect.has(target,property)){// Special message for invalid property access of non-chainable methods.
if(nonChainableMethodName){throw Error('Invalid Chai property: '+nonChainableMethodName+'.'+property+'. See docs for proper usage of "'+nonChainableMethodName+'".');}// If the property is reasonably close to an existing Chai property,
// suggest that property to the user. Only suggest properties with a
// distance less than 4.
var suggestion=null;var suggestionDistance=4;getProperties(target).forEach(function(prop){if(!Object.prototype.hasOwnProperty(prop)&&builtins.indexOf(prop)===-1){var dist=stringDistanceCapped(property,prop,suggestionDistance);if(dist<suggestionDistance){suggestion=prop;suggestionDistance=dist;}}});if(suggestion!==null){throw Error('Invalid Chai property: '+property+'. Did you mean "'+suggestion+'"?');}else{throw Error('Invalid Chai property: '+property);}}// Use this proxy getter as the starting point for removing implementation
// frames from the stack trace of a failed assertion. For property
// assertions, this prevents the proxy getter from showing up in the stack
// trace since it's invoked before the property getter. For method and
// chainable method assertions, this flag will end up getting changed to
// the method wrapper, which is good since this frame will no longer be in
// the stack once the method is invoked. Note that Chai builtin assertion
// properties such as \`__flags\` are skipped since this is only meant to
// capture the starting point of an assertion. This step is also skipped
// if the \`lockSsfi\` flag is set, thus indicating that this assertion is
// being called from within another assertion. In that case, the \`ssfi\`
// flag is already set to the outer assertion's starting point.
if(builtins.indexOf(property)===-1&&!flag$1(target,'lockSsfi')){flag$1(target,'ssfi',proxyGetter);}return Reflect.get(target,property);}});};/**
 * # stringDistanceCapped(strA, strB, cap)
 * Return the Levenshtein distance between two strings, but no more than cap.
 * @param {string} strA
 * @param {string} strB
 * @param {number} number
 * @return {number} min(string distance between strA and strB, cap)
 * @api private
 */function stringDistanceCapped(strA,strB,cap){if(Math.abs(strA.length-strB.length)>=cap){return cap;}var memo=[];// \`memo\` is a two-dimensional array containing distances.
// memo[i][j] is the distance between strA.slice(0, i) and
// strB.slice(0, j).
for(var i=0;i<=strA.length;i++){memo[i]=Array(strB.length+1).fill(0);memo[i][0]=i;}for(var j=0;j<strB.length;j++){memo[0][j]=j;}for(var i=1;i<=strA.length;i++){var ch=strA.charCodeAt(i-1);for(var j=1;j<=strB.length;j++){if(Math.abs(i-j)>=cap){memo[i][j]=cap;continue;}memo[i][j]=Math.min(memo[i-1][j]+1,memo[i][j-1]+1,memo[i-1][j-1]+(ch===strB.charCodeAt(j-1)?0:1));}}return memo[strA.length][strB.length];}/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var addMethod;var hasRequiredAddMethod;function requireAddMethod(){if(hasRequiredAddMethod)return addMethod;hasRequiredAddMethod=1;var addLengthGuard$1=addLengthGuard;var chai=requireChai();var flag=flag$5;var proxify$1=proxify;var transferFlags$1=transferFlags;/**
   * ### .addMethod(ctx, name, method)
   *
   * Adds a method to the prototype of an object.
   *
   *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
   *       var obj = utils.flag(this, 'object');
   *       new chai.Assertion(obj).to.be.equal(str);
   *     });
   *
   * Can also be accessed directly from \`chai.Assertion\`.
   *
   *     chai.Assertion.addMethod('foo', fn);
   *
   * Then can be used as any other assertion.
   *
   *     expect(fooStr).to.be.foo('bar');
   *
   * @param {Object} ctx object to which the method is added
   * @param {String} name of method to add
   * @param {Function} method function to be used for name
   * @namespace Utils
   * @name addMethod
   * @api public
   */addMethod=function addMethod(ctx,name,method){var methodWrapper=function(){// Setting the \`ssfi\` flag to \`methodWrapper\` causes this function to be the
// starting point for removing implementation frames from the stack trace of
// a failed assertion.
//
// However, we only want to use this function as the starting point if the
// \`lockSsfi\` flag isn't set.
//
// If the \`lockSsfi\` flag is set, then either this assertion has been
// overwritten by another assertion, or this assertion is being invoked from
// inside of another assertion. In the first case, the \`ssfi\` flag has
// already been set by the overwriting assertion. In the second case, the
// \`ssfi\` flag has already been set by the outer assertion.
if(!flag(this,'lockSsfi')){flag(this,'ssfi',methodWrapper);}var result=method.apply(this,arguments);if(result!==undefined)return result;var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;};addLengthGuard$1(methodWrapper,name,false);ctx[name]=proxify$1(methodWrapper,name);};return addMethod;}/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var overwriteProperty;var hasRequiredOverwriteProperty;function requireOverwriteProperty(){if(hasRequiredOverwriteProperty)return overwriteProperty;hasRequiredOverwriteProperty=1;var chai=requireChai();var flag=flag$5;var isProxyEnabled=isProxyEnabled$1;var transferFlags$1=transferFlags;/**
   * ### .overwriteProperty(ctx, name, fn)
   *
   * Overwrites an already existing property getter and provides
   * access to previous value. Must return function to use as getter.
   *
   *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
   *       return function () {
   *         var obj = utils.flag(this, 'object');
   *         if (obj instanceof Foo) {
   *           new chai.Assertion(obj.name).to.equal('bar');
   *         } else {
   *           _super.call(this);
   *         }
   *       }
   *     });
   *
   *
   * Can also be accessed directly from \`chai.Assertion\`.
   *
   *     chai.Assertion.overwriteProperty('foo', fn);
   *
   * Then can be used as any other assertion.
   *
   *     expect(myFoo).to.be.ok;
   *
   * @param {Object} ctx object whose property is to be overwritten
   * @param {String} name of property to overwrite
   * @param {Function} getter function that returns a getter function to be used for name
   * @namespace Utils
   * @name overwriteProperty
   * @api public
   */overwriteProperty=function overwriteProperty(ctx,name,getter){var _get=Object.getOwnPropertyDescriptor(ctx,name),_super=function(){};if(_get&&'function'===typeof _get.get)_super=_get.get;Object.defineProperty(ctx,name,{get:function overwritingPropertyGetter(){// Setting the \`ssfi\` flag to \`overwritingPropertyGetter\` causes this
// function to be the starting point for removing implementation frames
// from the stack trace of a failed assertion.
//
// However, we only want to use this function as the starting point if
// the \`lockSsfi\` flag isn't set and proxy protection is disabled.
//
// If the \`lockSsfi\` flag is set, then either this assertion has been
// overwritten by another assertion, or this assertion is being invoked
// from inside of another assertion. In the first case, the \`ssfi\` flag
// has already been set by the overwriting assertion. In the second
// case, the \`ssfi\` flag has already been set by the outer assertion.
//
// If proxy protection is enabled, then the \`ssfi\` flag has already been
// set by the proxy getter.
if(!isProxyEnabled()&&!flag(this,'lockSsfi')){flag(this,'ssfi',overwritingPropertyGetter);}// Setting the \`lockSsfi\` flag to \`true\` prevents the overwritten
// assertion from changing the \`ssfi\` flag. By this point, the \`ssfi\`
// flag is already set to the correct starting point for this assertion.
var origLockSsfi=flag(this,'lockSsfi');flag(this,'lockSsfi',true);var result=getter(_super).call(this);flag(this,'lockSsfi',origLockSsfi);if(result!==undefined){return result;}var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;},configurable:true});};return overwriteProperty;}/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var overwriteMethod;var hasRequiredOverwriteMethod;function requireOverwriteMethod(){if(hasRequiredOverwriteMethod)return overwriteMethod;hasRequiredOverwriteMethod=1;var addLengthGuard$1=addLengthGuard;var chai=requireChai();var flag=flag$5;var proxify$1=proxify;var transferFlags$1=transferFlags;/**
   * ### .overwriteMethod(ctx, name, fn)
   *
   * Overwrites an already existing method and provides
   * access to previous function. Must return function
   * to be used for name.
   *
   *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
   *       return function (str) {
   *         var obj = utils.flag(this, 'object');
   *         if (obj instanceof Foo) {
   *           new chai.Assertion(obj.value).to.equal(str);
   *         } else {
   *           _super.apply(this, arguments);
   *         }
   *       }
   *     });
   *
   * Can also be accessed directly from \`chai.Assertion\`.
   *
   *     chai.Assertion.overwriteMethod('foo', fn);
   *
   * Then can be used as any other assertion.
   *
   *     expect(myFoo).to.equal('bar');
   *
   * @param {Object} ctx object whose method is to be overwritten
   * @param {String} name of method to overwrite
   * @param {Function} method function that returns a function to be used for name
   * @namespace Utils
   * @name overwriteMethod
   * @api public
   */overwriteMethod=function overwriteMethod(ctx,name,method){var _method=ctx[name],_super=function(){throw new Error(name+' is not a function');};if(_method&&'function'===typeof _method)_super=_method;var overwritingMethodWrapper=function(){// Setting the \`ssfi\` flag to \`overwritingMethodWrapper\` causes this
// function to be the starting point for removing implementation frames from
// the stack trace of a failed assertion.
//
// However, we only want to use this function as the starting point if the
// \`lockSsfi\` flag isn't set.
//
// If the \`lockSsfi\` flag is set, then either this assertion has been
// overwritten by another assertion, or this assertion is being invoked from
// inside of another assertion. In the first case, the \`ssfi\` flag has
// already been set by the overwriting assertion. In the second case, the
// \`ssfi\` flag has already been set by the outer assertion.
if(!flag(this,'lockSsfi')){flag(this,'ssfi',overwritingMethodWrapper);}// Setting the \`lockSsfi\` flag to \`true\` prevents the overwritten assertion
// from changing the \`ssfi\` flag. By this point, the \`ssfi\` flag is already
// set to the correct starting point for this assertion.
var origLockSsfi=flag(this,'lockSsfi');flag(this,'lockSsfi',true);var result=method(_super).apply(this,arguments);flag(this,'lockSsfi',origLockSsfi);if(result!==undefined){return result;}var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;};addLengthGuard$1(overwritingMethodWrapper,name,false);ctx[name]=proxify$1(overwritingMethodWrapper,name);};return overwriteMethod;}/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var addChainableMethod;var hasRequiredAddChainableMethod;function requireAddChainableMethod(){if(hasRequiredAddChainableMethod)return addChainableMethod;hasRequiredAddChainableMethod=1;/*!
   * Module dependencies
   */var addLengthGuard$1=addLengthGuard;var chai=requireChai();var flag=flag$5;var proxify$1=proxify;var transferFlags$1=transferFlags;/*!
   * Module variables
   */ // Check whether \`Object.setPrototypeOf\` is supported
var canSetPrototype=typeof Object.setPrototypeOf==='function';// Without \`Object.setPrototypeOf\` support, this module will need to add properties to a function.
// However, some of functions' own props are not configurable and should be skipped.
var testFn=function(){};var excludeNames=Object.getOwnPropertyNames(testFn).filter(function(name){var propDesc=Object.getOwnPropertyDescriptor(testFn,name);// Note: PhantomJS 1.x includes \`callee\` as one of \`testFn\`'s own properties,
// but then returns \`undefined\` as the property descriptor for \`callee\`. As a
// workaround, we perform an otherwise unnecessary type-check for \`propDesc\`,
// and then filter it out if it's not an object as it should be.
if(typeof propDesc!=='object')return true;return!propDesc.configurable;});// Cache \`Function\` properties
var call=Function.prototype.call,apply=Function.prototype.apply;/**
   * ### .addChainableMethod(ctx, name, method, chainingBehavior)
   *
   * Adds a method to an object, such that the method can also be chained.
   *
   *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
   *       var obj = utils.flag(this, 'object');
   *       new chai.Assertion(obj).to.be.equal(str);
   *     });
   *
   * Can also be accessed directly from \`chai.Assertion\`.
   *
   *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
   *
   * The result can then be used as both a method assertion, executing both \`method\` and
   * \`chainingBehavior\`, or as a language chain, which only executes \`chainingBehavior\`.
   *
   *     expect(fooStr).to.be.foo('bar');
   *     expect(fooStr).to.be.foo.equal('foo');
   *
   * @param {Object} ctx object to which the method is added
   * @param {String} name of method to add
   * @param {Function} method function to be used for \`name\`, when called
   * @param {Function} chainingBehavior function to be called every time the property is accessed
   * @namespace Utils
   * @name addChainableMethod
   * @api public
   */addChainableMethod=function addChainableMethod(ctx,name,method,chainingBehavior){if(typeof chainingBehavior!=='function'){chainingBehavior=function(){};}var chainableBehavior={method:method,chainingBehavior:chainingBehavior};// save the methods so we can overwrite them later, if we need to.
if(!ctx.__methods){ctx.__methods={};}ctx.__methods[name]=chainableBehavior;Object.defineProperty(ctx,name,{get:function chainableMethodGetter(){chainableBehavior.chainingBehavior.call(this);var chainableMethodWrapper=function(){// Setting the \`ssfi\` flag to \`chainableMethodWrapper\` causes this
// function to be the starting point for removing implementation
// frames from the stack trace of a failed assertion.
//
// However, we only want to use this function as the starting point if
// the \`lockSsfi\` flag isn't set.
//
// If the \`lockSsfi\` flag is set, then this assertion is being
// invoked from inside of another assertion. In this case, the \`ssfi\`
// flag has already been set by the outer assertion.
//
// Note that overwriting a chainable method merely replaces the saved
// methods in \`ctx.__methods\` instead of completely replacing the
// overwritten assertion. Therefore, an overwriting assertion won't
// set the \`ssfi\` or \`lockSsfi\` flags.
if(!flag(this,'lockSsfi')){flag(this,'ssfi',chainableMethodWrapper);}var result=chainableBehavior.method.apply(this,arguments);if(result!==undefined){return result;}var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;};addLengthGuard$1(chainableMethodWrapper,name,true);// Use \`Object.setPrototypeOf\` if available
if(canSetPrototype){// Inherit all properties from the object by replacing the \`Function\` prototype
var prototype=Object.create(this);// Restore the \`call\` and \`apply\` methods from \`Function\`
prototype.call=call;prototype.apply=apply;Object.setPrototypeOf(chainableMethodWrapper,prototype);}// Otherwise, redefine all properties (slow!)
else{var asserterNames=Object.getOwnPropertyNames(ctx);asserterNames.forEach(function(asserterName){if(excludeNames.indexOf(asserterName)!==-1){return;}var pd=Object.getOwnPropertyDescriptor(ctx,asserterName);Object.defineProperty(chainableMethodWrapper,asserterName,pd);});}transferFlags$1(this,chainableMethodWrapper);return proxify$1(chainableMethodWrapper);},configurable:true});};return addChainableMethod;}/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var overwriteChainableMethod;var hasRequiredOverwriteChainableMethod;function requireOverwriteChainableMethod(){if(hasRequiredOverwriteChainableMethod)return overwriteChainableMethod;hasRequiredOverwriteChainableMethod=1;var chai=requireChai();var transferFlags$1=transferFlags;/**
   * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)
   *
   * Overwrites an already existing chainable method
   * and provides access to the previous function or
   * property.  Must return functions to be used for
   * name.
   *
   *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
   *       function (_super) {
   *       }
   *     , function (_super) {
   *       }
   *     );
   *
   * Can also be accessed directly from \`chai.Assertion\`.
   *
   *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
   *
   * Then can be used as any other assertion.
   *
   *     expect(myFoo).to.have.lengthOf(3);
   *     expect(myFoo).to.have.lengthOf.above(3);
   *
   * @param {Object} ctx object whose method / property is to be overwritten
   * @param {String} name of method / property to overwrite
   * @param {Function} method function that returns a function to be used for name
   * @param {Function} chainingBehavior function that returns a function to be used for property
   * @namespace Utils
   * @name overwriteChainableMethod
   * @api public
   */overwriteChainableMethod=function overwriteChainableMethod(ctx,name,method,chainingBehavior){var chainableBehavior=ctx.__methods[name];var _chainingBehavior=chainableBehavior.chainingBehavior;chainableBehavior.chainingBehavior=function overwritingChainableMethodGetter(){var result=chainingBehavior(_chainingBehavior).call(this);if(result!==undefined){return result;}var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;};var _method=chainableBehavior.method;chainableBehavior.method=function overwritingChainableMethodWrapper(){var result=method(_method).apply(this,arguments);if(result!==undefined){return result;}var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;};};return overwriteChainableMethod;}/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Module dependencies
 */var inspect=inspect_1;/**
 * ### .compareByInspect(mixed, mixed)
 *
 * To be used as a compareFunction with Array.prototype.sort. Compares elements
 * using inspect instead of default behavior of using toString so that Symbols
 * and objects with irregular/missing toString can still be sorted without a
 * TypeError.
 *
 * @param {Mixed} first element to compare
 * @param {Mixed} second element to compare
 * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1
 * @name compareByInspect
 * @namespace Utils
 * @api public
 */var compareByInspect=function compareByInspect(a,b){return inspect(a)<inspect(b)?-1:1;};/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .getOwnEnumerablePropertySymbols(object)
 *
 * This allows the retrieval of directly-owned enumerable property symbols of an
 * object. This function is necessary because Object.getOwnPropertySymbols
 * returns both enumerable and non-enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerablePropertySymbols
 * @api public
 */var getOwnEnumerablePropertySymbols$1=function getOwnEnumerablePropertySymbols(obj){if(typeof Object.getOwnPropertySymbols!=='function')return[];return Object.getOwnPropertySymbols(obj).filter(function(sym){return Object.getOwnPropertyDescriptor(obj,sym).enumerable;});};/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Module dependencies
 */var getOwnEnumerablePropertySymbols=getOwnEnumerablePropertySymbols$1;/**
 * ### .getOwnEnumerableProperties(object)
 *
 * This allows the retrieval of directly-owned enumerable property names and
 * symbols of an object. This function is necessary because Object.keys only
 * returns enumerable property names, not enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerableProperties
 * @api public
 */var getOwnEnumerableProperties=function getOwnEnumerableProperties(obj){return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));};/* !
 * Chai - checkError utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var getFunctionName=getFuncName_1;/**
 * ### .checkError
 *
 * Checks that an error conforms to a given set of criteria and/or retrieves information about it.
 *
 * @api public
 */ /**
 * ### .compatibleInstance(thrown, errorLike)
 *
 * Checks if two instances are compatible (strict equal).
 * Returns false if errorLike is not an instance of Error, because instances
 * can only be compatible if they're both error instances.
 *
 * @name compatibleInstance
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */function compatibleInstance(thrown,errorLike){return errorLike instanceof Error&&thrown===errorLike;}/**
 * ### .compatibleConstructor(thrown, errorLike)
 *
 * Checks if two constructors are compatible.
 * This function can receive either an error constructor or
 * an error instance as the \`errorLike\` argument.
 * Constructors are compatible if they're the same or if one is
 * an instance of another.
 *
 * @name compatibleConstructor
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */function compatibleConstructor(thrown,errorLike){if(errorLike instanceof Error){// If \`errorLike\` is an instance of any error we compare their constructors
return thrown.constructor===errorLike.constructor||thrown instanceof errorLike.constructor;}else if(errorLike.prototype instanceof Error||errorLike===Error){// If \`errorLike\` is a constructor that inherits from Error, we compare \`thrown\` to \`errorLike\` directly
return thrown.constructor===errorLike||thrown instanceof errorLike;}return false;}/**
 * ### .compatibleMessage(thrown, errMatcher)
 *
 * Checks if an error's message is compatible with a matcher (String or RegExp).
 * If the message contains the String or passes the RegExp test,
 * it is considered compatible.
 *
 * @name compatibleMessage
 * @param {Error} thrown error
 * @param {String|RegExp} errMatcher to look for into the message
 * @namespace Utils
 * @api public
 */function compatibleMessage(thrown,errMatcher){var comparisonString=typeof thrown==='string'?thrown:thrown.message;if(errMatcher instanceof RegExp){return errMatcher.test(comparisonString);}else if(typeof errMatcher==='string'){return comparisonString.indexOf(errMatcher)!==-1;// eslint-disable-line no-magic-numbers
}return false;}/**
 * ### .getConstructorName(errorLike)
 *
 * Gets the constructor name for an Error instance or constructor itself.
 *
 * @name getConstructorName
 * @param {Error|ErrorConstructor} errorLike
 * @namespace Utils
 * @api public
 */function getConstructorName(errorLike){var constructorName=errorLike;if(errorLike instanceof Error){constructorName=getFunctionName(errorLike.constructor);}else if(typeof errorLike==='function'){// If \`err\` is not an instance of Error it is an error constructor itself or another function.
// If we've got a common function we get its name, otherwise we may need to create a new instance
// of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.
constructorName=getFunctionName(errorLike);if(constructorName===''){var newConstructorName=getFunctionName(new errorLike());// eslint-disable-line new-cap
constructorName=newConstructorName||constructorName;}}return constructorName;}/**
 * ### .getMessage(errorLike)
 *
 * Gets the error message from an error.
 * If \`err\` is a String itself, we return it.
 * If the error has no message, we return an empty string.
 *
 * @name getMessage
 * @param {Error|String} errorLike
 * @namespace Utils
 * @api public
 */function getMessage(errorLike){var msg='';if(errorLike&&errorLike.message){msg=errorLike.message;}else if(typeof errorLike==='string'){msg=errorLike;}return msg;}var checkError={compatibleInstance:compatibleInstance,compatibleConstructor:compatibleConstructor,compatibleMessage:compatibleMessage,getMessage:getMessage,getConstructorName:getConstructorName};/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */ /**
 * ### .isNaN(value)
 *
 * Checks if the given value is NaN or not.
 *
 *     utils.isNaN(NaN); // true
 *
 * @param {Value} The value which has to be checked if it is NaN
 * @name isNaN
 * @api private
 */function isNaN$1(value){// Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number
// section's NOTE.
return value!==value;}// If ECMAScript 6's Number.isNaN is present, prefer that.
var _isNaN=Number.isNaN||isNaN$1;var type$1=typeDetectExports$1;var flag=flag$5;function isObjectType(obj){var objectType=type$1(obj);var objectTypes=['Array','Object','function'];return objectTypes.indexOf(objectType)!==-1;}/**
 * ### .getOperator(message)
 *
 * Extract the operator from error message.
 * Operator defined is based on below link
 * https://nodejs.org/api/assert.html#assert_assert.
 *
 * Returns the \`operator\` or \`undefined\` value for an Assertion.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getOperator
 * @api public
 */var getOperator=function getOperator(obj,args){var operator=flag(obj,'operator');var negate=flag(obj,'negate');var expected=args[3];var msg=negate?args[2]:args[1];if(operator){return operator;}if(typeof msg==='function')msg=msg();msg=msg||'';if(!msg){return undefined;}if(/\\shave\\s/.test(msg)){return undefined;}var isObject=isObjectType(expected);if(/\\snot\\s/.test(msg)){return isObject?'notDeepStrictEqual':'notStrictEqual';}return isObject?'deepStrictEqual':'strictEqual';};/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var hasRequiredUtils;function requireUtils(){if(hasRequiredUtils)return utils;hasRequiredUtils=1;/*!
   * Dependencies that are used for multiple exports are required here only once
   */var pathval$1=pathval;/*!
   * test utility
   */utils.test=test$1;/*!
   * type utility
   */utils.type=typeDetectExports$1;/*!
   * expectTypes utility
   */utils.expectTypes=expectTypes;/*!
   * message utility
   */utils.getMessage=getMessage$1;/*!
   * actual utility
   */utils.getActual=getActual$1;/*!
   * Inspect util
   */utils.inspect=inspect_1;/*!
   * Object Display util
   */utils.objDisplay=objDisplay$1;/*!
   * Flag utility
   */utils.flag=flag$5;/*!
   * Flag transferring utility
   */utils.transferFlags=transferFlags;/*!
   * Deep equal utility
   */utils.eql=deepEqlExports;/*!
   * Deep path info
   */utils.getPathInfo=pathval$1.getPathInfo;/*!
   * Check if a property exists
   */utils.hasProperty=pathval$1.hasProperty;/*!
   * Function name
   */utils.getName=getFuncName_1;/*!
   * add Property
   */utils.addProperty=requireAddProperty();/*!
   * add Method
   */utils.addMethod=requireAddMethod();/*!
   * overwrite Property
   */utils.overwriteProperty=requireOverwriteProperty();/*!
   * overwrite Method
   */utils.overwriteMethod=requireOverwriteMethod();/*!
   * Add a chainable method
   */utils.addChainableMethod=requireAddChainableMethod();/*!
   * Overwrite chainable method
   */utils.overwriteChainableMethod=requireOverwriteChainableMethod();/*!
   * Compare by inspect method
   */utils.compareByInspect=compareByInspect;/*!
   * Get own enumerable property symbols method
   */utils.getOwnEnumerablePropertySymbols=getOwnEnumerablePropertySymbols$1;/*!
   * Get own enumerable properties method
   */utils.getOwnEnumerableProperties=getOwnEnumerableProperties;/*!
   * Checks error against a given set of criteria
   */utils.checkError=checkError;/*!
   * Proxify util
   */utils.proxify=proxify;/*!
   * addLengthGuard util
   */utils.addLengthGuard=addLengthGuard;/*!
   * isProxyEnabled helper
   */utils.isProxyEnabled=isProxyEnabled$1;/*!
   * isNaN method
   */utils.isNaN=_isNaN;/*!
   * getOperator method
   */utils.getOperator=getOperator;return utils;}/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var config=config$5;var assertion=function(_chai,util){/*!
   * Module dependencies.
   */var AssertionError=_chai.AssertionError,flag=util.flag;/*!
   * Module export.
   */_chai.Assertion=Assertion;/*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * \`Assertion\` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - \`object\`: This flag contains the target of the assertion. For example, in
   *   the assertion \`expect(numKittens).to.equal(7);\`, the \`object\` flag will
   *   contain \`numKittens\` so that the \`equal\` assertion can reference it when
   *   needed.
   *
   * - \`message\`: This flag contains an optional custom error message to be
   *   prepended to the error message that's generated by the assertion when it
   *   fails.
   *
   * - \`ssfi\`: This flag stands for "start stack function indicator". It
   *   contains a function reference that serves as the starting point for
   *   removing frames from the stack trace of the error that's created by the
   *   assertion when it fails. The goal is to provide a cleaner stack trace to
   *   end users by removing Chai's internal functions. Note that it only works
   *   in environments that support \`Error.captureStackTrace\`, and only when
   *   \`Chai.config.includeStack\` hasn't been set to \`false\`.
   *
   * - \`lockSsfi\`: This flag controls whether or not the given \`ssfi\` flag
   *   should retain its current value, even as assertions are chained off of
   *   this object. This is usually set to \`true\` when creating a new assertion
   *   from within another assertion. It's also temporarily set to \`true\` before
   *   an overwritten assertion gets called by the overwriting assertion.
   *
   * - \`eql\`: This flag contains the deepEqual function to be used by the assertion.
   *
   * @param {Mixed} obj target of the assertion
   * @param {String} msg (optional) custom error message
   * @param {Function} ssfi (optional) starting point for removing stack frames
   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
   * @api private
   */function Assertion(obj,msg,ssfi,lockSsfi){flag(this,'ssfi',ssfi||Assertion);flag(this,'lockSsfi',lockSsfi);flag(this,'object',obj);flag(this,'message',msg);flag(this,'eql',config.deepEqual||util.eql);return util.proxify(this);}Object.defineProperty(Assertion,'includeStack',{get:function(){console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');return config.includeStack;},set:function(value){console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');config.includeStack=value;}});Object.defineProperty(Assertion,'showDiff',{get:function(){console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');return config.showDiff;},set:function(value){console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');config.showDiff=value;}});Assertion.addProperty=function(name,fn){util.addProperty(this.prototype,name,fn);};Assertion.addMethod=function(name,fn){util.addMethod(this.prototype,name,fn);};Assertion.addChainableMethod=function(name,fn,chainingBehavior){util.addChainableMethod(this.prototype,name,fn,chainingBehavior);};Assertion.overwriteProperty=function(name,fn){util.overwriteProperty(this.prototype,name,fn);};Assertion.overwriteMethod=function(name,fn){util.overwriteMethod(this.prototype,name,fn);};Assertion.overwriteChainableMethod=function(name,fn,chainingBehavior){util.overwriteChainableMethod(this.prototype,name,fn,chainingBehavior);};/**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to \`this.obj\`
   * @param {Boolean} showDiff (optional) when set to \`true\`, assert will display a diff in addition to the message if expression fails
   * @api private
   */Assertion.prototype.assert=function(expr,msg,negateMsg,expected,_actual,showDiff){var ok=util.test(this,arguments);if(false!==showDiff)showDiff=true;if(undefined===expected&&undefined===_actual)showDiff=false;if(true!==config.showDiff)showDiff=false;if(!ok){msg=util.getMessage(this,arguments);var actual=util.getActual(this,arguments);var assertionErrorObjectProperties={actual:actual,expected:expected,showDiff:showDiff};var operator=util.getOperator(this,arguments);if(operator){assertionErrorObjectProperties.operator=operator;}throw new AssertionError(msg,assertionErrorObjectProperties,config.includeStack?this.assert:flag(this,'ssfi'));}};/*!
   * ### ._obj
   *
   * Quick reference to stored \`actual\` value for plugin developers.
   *
   * @api private
   */Object.defineProperty(Assertion.prototype,'_obj',{get:function(){return flag(this,'object');},set:function(val){flag(this,'object',val);}});};/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var assertions=function(chai,_){var Assertion=chai.Assertion,AssertionError=chai.AssertionError,flag=_.flag;/**
   * ### Language Chains
   *
   * The following are provided as chainable getters to improve the readability
   * of your assertions.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   * - but
   * - does
   * - still
   * - also
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */['to','be','been','is','and','has','have','with','that','which','at','of','same','but','does','still',"also"].forEach(function(chain){Assertion.addProperty(chain);});/**
   * ### .not
   *
   * Negates all assertions that follow in the chain.
   *
   *     expect(function () {}).to.not.throw();
   *     expect({a: 1}).to.not.have.property('b');
   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);
   *
   * Just because you can negate any assertion with \`.not\` doesn't mean you
   * should. With great power comes great responsibility. It's often best to
   * assert that the one expected output was produced, rather than asserting
   * that one of countless unexpected outputs wasn't produced. See individual
   * assertions for specific guidance.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.equal(1); // Not recommended
   *
   * @name not
   * @namespace BDD
   * @api public
   */Assertion.addProperty('not',function(){flag(this,'negate',true);});/**
   * ### .deep
   *
   * Causes all \`.equal\`, \`.include\`, \`.members\`, \`.keys\`, and \`.property\`
   * assertions that follow in the chain to use deep equality instead of strict
   * (\`===\`) equality. See the \`deep-eql\` project page for info on the deep
   * equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals \`{a: 1}\`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) includes \`{a: 1}\`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes \`x: {a: 1}\`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   *     // Target array deeply (but not strictly) has member \`{a: 1}\`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   *     // Target set deeply (but not strictly) has key \`{a: 1}\`
   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);
   *
   *     // Target object deeply (but not strictly) has property \`x: {a: 1}\`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * @name deep
   * @namespace BDD
   * @api public
   */Assertion.addProperty('deep',function(){flag(this,'deep',true);});/**
   * ### .nested
   *
   * Enables dot- and bracket-notation in all \`.property\` and \`.include\`
   * assertions that follow in the chain.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If \`.\` or \`[]\` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');
   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 'x'});
   *
   * \`.nested\` cannot be combined with \`.own\`.
   *
   * @name nested
   * @namespace BDD
   * @api public
   */Assertion.addProperty('nested',function(){flag(this,'nested',true);});/**
   * ### .own
   *
   * Causes all \`.property\` and \`.include\` assertions that follow in the chain
   * to ignore inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * \`.own\` cannot be combined with \`.nested\`.
   *
   * @name own
   * @namespace BDD
   * @api public
   */Assertion.addProperty('own',function(){flag(this,'own',true);});/**
   * ### .ordered
   *
   * Causes all \`.members\` assertions that follow in the chain to require that
   * members be in the same order.
   *
   *     expect([1, 2]).to.have.ordered.members([1, 2])
   *       .but.not.have.ordered.members([2, 1]);
   *
   * When \`.include\` and \`.ordered\` are combined, the ordering begins at the
   * start of both arrays.
   *
   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])
   *       .but.not.include.ordered.members([2, 3]);
   *
   * @name ordered
   * @namespace BDD
   * @api public
   */Assertion.addProperty('ordered',function(){flag(this,'ordered',true);});/**
   * ### .any
   *
   * Causes all \`.keys\` assertions that follow in the chain to only require that
   * the target have at least one of the given keys. This is the opposite of
   * \`.all\`, which requires that the target have all of the given keys.
   *
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   * See the \`.keys\` doc for guidance on when to use \`.any\` or \`.all\`.
   *
   * @name any
   * @namespace BDD
   * @api public
   */Assertion.addProperty('any',function(){flag(this,'any',true);flag(this,'all',false);});/**
   * ### .all
   *
   * Causes all \`.keys\` assertions that follow in the chain to require that the
   * target have all of the given keys. This is the opposite of \`.any\`, which
   * only requires that the target have at least one of the given keys.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   * Note that \`.all\` is used by default when neither \`.all\` nor \`.any\` are
   * added earlier in the chain. However, it's often best to add \`.all\` anyway
   * because it improves readability.
   *
   * See the \`.keys\` doc for guidance on when to use \`.any\` or \`.all\`.
   *
   * @name all
   * @namespace BDD
   * @api public
   */Assertion.addProperty('all',function(){flag(this,'all',true);flag(this,'any',false);});/**
   * ### .a(type[, msg])
   *
   * Asserts that the target's type is equal to the given string \`type\`. Types
   * are case insensitive. See the \`type-detect\` project page for info on the
   * type detection algorithm: https://github.com/chaijs/type-detect.
   *
   *     expect('foo').to.be.a('string');
   *     expect({a: 1}).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(Promise.resolve()).to.be.a('promise');
   *     expect(new Float32Array).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   * \`.a\` supports objects that have a custom type set via \`Symbol.toStringTag\`.
   *
   *     var myObj = {
   *       [Symbol.toStringTag]: 'myCustomType'
   *     };
   *
   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');
   *
   * It's often best to use \`.a\` to check a target's type before making more
   * assertions on the same target. That way, you avoid unexpected behavior from
   * any assertion that does different things based on the target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add \`.not\` earlier in the chain to negate \`.a\`. However, it's often best to
   * assert that the target is the expected type, rather than asserting that it
   * isn't one of many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.an('array'); // Not recommended
   *
   * \`.a\` accepts an optional \`msg\` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to \`expect\`.
   *
   *     expect(1).to.be.a('string', 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.a('string');
   *
   * \`.a\` can also be used as a language chain to improve the readability of
   * your assertions.
   *
   *     expect({b: 2}).to.have.a.property('b');
   *
   * The alias \`.an\` can be used interchangeably with \`.a\`.
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function an(type,msg){if(msg)flag(this,'message',msg);type=type.toLowerCase();var obj=flag(this,'object'),article=~['a','e','i','o','u'].indexOf(type.charAt(0))?'an ':'a ';this.assert(type===_.type(obj).toLowerCase(),'expected #{this} to be '+article+type,'expected #{this} not to be '+article+type);}Assertion.addChainableMethod('an',an);Assertion.addChainableMethod('a',an);/**
   * ### .include(val[, msg])
   *
   * When the target is a string, \`.include\` asserts that the given string \`val\`
   * is a substring of the target.
   *
   *     expect('foobar').to.include('foo');
   *
   * When the target is an array, \`.include\` asserts that the given \`val\` is a
   * member of the target.
   *
   *     expect([1, 2, 3]).to.include(2);
   *
   * When the target is an object, \`.include\` asserts that the given object
   * \`val\`'s properties are a subset of the target's properties.
   *
   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
   *
   * When the target is a Set or WeakSet, \`.include\` asserts that the given \`val\` is a
   * member of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Set([1, 2])).to.include(2);
   *
   * When the target is a Map, \`.include\` asserts that the given \`val\` is one of
   * the values of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);
   *
   * Because \`.include\` does different things based on the target's type, it's
   * important to check the target's type before using \`.include\`. See the \`.a\`
   * doc for info on testing a target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *
   * By default, strict (\`===\`) equality is used to compare array members and
   * object properties. Add \`.deep\` earlier in the chain to use deep equality
   * instead (WeakSet targets are not supported). See the \`deep-eql\` project
   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) includes \`{a: 1}\`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes \`x: {a: 1}\`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   * By default, all of the target's properties are searched when working with
   * objects. This includes properties that are inherited and/or non-enumerable.
   * Add \`.own\` earlier in the chain to exclude the target's inherited
   * properties from the search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * Note that a target object is always only searched for \`val\`'s own
   * enumerable properties.
   *
   * \`.deep\` and \`.own\` can be combined.
   *
   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
   *
   * Add \`.nested\` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If \`.\` or \`[]\` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 2});
   *
   * \`.deep\` and \`.nested\` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
   *
   * \`.own\` and \`.nested\` cannot be combined.
   *
   * Add \`.not\` earlier in the chain to negate \`.include\`.
   *
   *     expect('foobar').to.not.include('taco');
   *     expect([1, 2, 3]).to.not.include(4);
   *
   * However, it's dangerous to negate \`.include\` when the target is an object.
   * The problem is that it creates uncertain expectations by asserting that the
   * target object doesn't have all of \`val\`'s key/value pairs but may or may
   * not have some of them. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target object isn't even expected to have \`val\`'s keys, it's
   * often best to assert exactly that.
   *
   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * When the target object is expected to have \`val\`'s keys, it's often best to
   * assert that each of the properties has its expected value, rather than
   * asserting that each property doesn't have one of many unexpected values.
   *
   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * \`.include\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);
   *
   * \`.include\` can also be used as a language chain, causing all \`.members\` and
   * \`.keys\` assertions that follow in the chain to require the target to be a
   * superset of the expected set, rather than an identical set. Note that
   * \`.members\` ignores duplicates in the subset when \`.include\` is added.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * Note that adding \`.any\` earlier in the chain causes the \`.keys\` assertion
   * to ignore \`.include\`.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *
   * The aliases \`.includes\`, \`.contain\`, and \`.contains\` can be used
   * interchangeably with \`.include\`.
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function SameValueZero(a,b){return _.isNaN(a)&&_.isNaN(b)||a===b;}function includeChainingBehavior(){flag(this,'contains',true);}function include(val,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),objType=_.type(obj).toLowerCase(),flagMsg=flag(this,'message'),negate=flag(this,'negate'),ssfi=flag(this,'ssfi'),isDeep=flag(this,'deep'),descriptor=isDeep?'deep ':'',isEql=isDeep?flag(this,'eql'):SameValueZero;flagMsg=flagMsg?flagMsg+': ':'';var included=false;switch(objType){case'string':included=obj.indexOf(val)!==-1;break;case'weakset':if(isDeep){throw new AssertionError(flagMsg+'unable to use .deep.include with WeakSet',undefined,ssfi);}included=obj.has(val);break;case'map':obj.forEach(function(item){included=included||isEql(item,val);});break;case'set':if(isDeep){obj.forEach(function(item){included=included||isEql(item,val);});}else{included=obj.has(val);}break;case'array':if(isDeep){included=obj.some(function(item){return isEql(item,val);});}else{included=obj.indexOf(val)!==-1;}break;default:// This block is for asserting a subset of properties in an object.
// \`_.expectTypes\` isn't used here because \`.include\` should work with
// objects with a custom \`@@toStringTag\`.
if(val!==Object(val)){throw new AssertionError(flagMsg+'the given combination of arguments ('+objType+' and '+_.type(val).toLowerCase()+')'+' is invalid for this assertion. '+'You can use an array, a map, an object, a set, a string, '+'or a weakset instead of a '+_.type(val).toLowerCase(),undefined,ssfi);}var props=Object.keys(val),firstErr=null,numErrs=0;props.forEach(function(prop){var propAssertion=new Assertion(obj);_.transferFlags(this,propAssertion,true);flag(propAssertion,'lockSsfi',true);if(!negate||props.length===1){propAssertion.property(prop,val[prop]);return;}try{propAssertion.property(prop,val[prop]);}catch(err){if(!_.checkError.compatibleConstructor(err,AssertionError)){throw err;}if(firstErr===null)firstErr=err;numErrs++;}},this);// When validating .not.include with multiple properties, we only want
// to throw an assertion error if all of the properties are included,
// in which case we throw the first property assertion error that we
// encountered.
if(negate&&props.length>1&&numErrs===props.length){throw firstErr;}return;}// Assert inclusion in collection or substring in a string.
this.assert(included,'expected #{this} to '+descriptor+'include '+_.inspect(val),'expected #{this} to not '+descriptor+'include '+_.inspect(val));}Assertion.addChainableMethod('include',include,includeChainingBehavior);Assertion.addChainableMethod('contain',include,includeChainingBehavior);Assertion.addChainableMethod('contains',include,includeChainingBehavior);Assertion.addChainableMethod('includes',include,includeChainingBehavior);/**
   * ### .ok
   *
   * Asserts that the target is a truthy value (considered \`true\` in boolean context).
   * However, it's often best to assert that the target is strictly (\`===\`) or
   * deeply equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.ok; // Not recommended
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.be.ok; // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.ok\`.
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.not.be.ok; // Not recommended
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.ok; // Not recommended
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.be.ok; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.be.ok; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(false, 'nooo why fail??').to.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */Assertion.addProperty('ok',function(){this.assert(flag(this,'object'),'expected #{this} to be truthy','expected #{this} to be falsy');});/**
   * ### .true
   *
   * Asserts that the target is strictly (\`===\`) equal to \`true\`.
   *
   *     expect(true).to.be.true;
   *
   * Add \`.not\` earlier in the chain to negate \`.true\`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to \`true\`.
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.true; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.true; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(false, 'nooo why fail??').to.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */Assertion.addProperty('true',function(){this.assert(true===flag(this,'object'),'expected #{this} to be true','expected #{this} to be false',flag(this,'negate')?false:true);});/**
   * ### .false
   *
   * Asserts that the target is strictly (\`===\`) equal to \`false\`.
   *
   *     expect(false).to.be.false;
   *
   * Add \`.not\` earlier in the chain to negate \`.false\`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to \`false\`.
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.not.be.false; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.false; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(true, 'nooo why fail??').to.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */Assertion.addProperty('false',function(){this.assert(false===flag(this,'object'),'expected #{this} to be false','expected #{this} to be true',flag(this,'negate')?true:false);});/**
   * ### .null
   *
   * Asserts that the target is strictly (\`===\`) equal to \`null\`.
   *
   *     expect(null).to.be.null;
   *
   * Add \`.not\` earlier in the chain to negate \`.null\`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to \`null\`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.null; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(42, 'nooo why fail??').to.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */Assertion.addProperty('null',function(){this.assert(null===flag(this,'object'),'expected #{this} to be null','expected #{this} not to be null');});/**
   * ### .undefined
   *
   * Asserts that the target is strictly (\`===\`) equal to \`undefined\`.
   *
   *     expect(undefined).to.be.undefined;
   *
   * Add \`.not\` earlier in the chain to negate \`.undefined\`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to \`undefined\`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.undefined; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(42, 'nooo why fail??').to.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */Assertion.addProperty('undefined',function(){this.assert(undefined===flag(this,'object'),'expected #{this} to be undefined','expected #{this} not to be undefined');});/**
   * ### .NaN
   *
   * Asserts that the target is exactly \`NaN\`.
   *
   *     expect(NaN).to.be.NaN;
   *
   * Add \`.not\` earlier in the chain to negate \`.NaN\`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to \`NaN\`.
   *
   *     expect('foo').to.equal('foo'); // Recommended
   *     expect('foo').to.not.be.NaN; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(42, 'nooo why fail??').to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */Assertion.addProperty('NaN',function(){this.assert(_.isNaN(flag(this,'object')),'expected #{this} to be NaN','expected #{this} not to be NaN');});/**
   * ### .exist
   *
   * Asserts that the target is not strictly (\`===\`) equal to either \`null\` or
   * \`undefined\`. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.exist; // Not recommended
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.exist; // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.exist\`.
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.exist; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.exist; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(null, 'nooo why fail??').to.exist;
   *
   * The alias \`.exists\` can be used interchangeably with \`.exist\`.
   *
   * @name exist
   * @alias exists
   * @namespace BDD
   * @api public
   */function assertExist(){var val=flag(this,'object');this.assert(val!==null&&val!==undefined,'expected #{this} to exist','expected #{this} to not exist');}Assertion.addProperty('exist',assertExist);Assertion.addProperty('exists',assertExist);/**
   * ### .empty
   *
   * When the target is a string or array, \`.empty\` asserts that the target's
   * \`length\` property is strictly (\`===\`) equal to \`0\`.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *
   * When the target is a map or set, \`.empty\` asserts that the target's \`size\`
   * property is strictly equal to \`0\`.
   *
   *     expect(new Set()).to.be.empty;
   *     expect(new Map()).to.be.empty;
   *
   * When the target is a non-function object, \`.empty\` asserts that the target
   * doesn't have any own enumerable properties. Properties with Symbol-based
   * keys are excluded from the count.
   *
   *     expect({}).to.be.empty;
   *
   * Because \`.empty\` does different things based on the target's type, it's
   * important to check the target's type before using \`.empty\`. See the \`.a\`
   * doc for info on testing a target's type.
   *
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add \`.not\` earlier in the chain to negate \`.empty\`. However, it's often
   * best to assert that the target contains its expected number of values,
   * rather than asserting that it's not empty.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended
   *
   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended
   *
   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
   *     expect({a: 1}).to.not.be.empty; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */Assertion.addProperty('empty',function(){var val=flag(this,'object'),ssfi=flag(this,'ssfi'),flagMsg=flag(this,'message'),itemsCount;flagMsg=flagMsg?flagMsg+': ':'';switch(_.type(val).toLowerCase()){case'array':case'string':itemsCount=val.length;break;case'map':case'set':itemsCount=val.size;break;case'weakmap':case'weakset':throw new AssertionError(flagMsg+'.empty was passed a weak collection',undefined,ssfi);case'function':var msg=flagMsg+'.empty was passed a function '+_.getName(val);throw new AssertionError(msg.trim(),undefined,ssfi);default:if(val!==Object(val)){throw new AssertionError(flagMsg+'.empty was passed non-string primitive '+_.inspect(val),undefined,ssfi);}itemsCount=Object.keys(val).length;}this.assert(0===itemsCount,'expected #{this} to be empty','expected #{this} not to be empty');});/**
   * ### .arguments
   *
   * Asserts that the target is an \`arguments\` object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   *     test();
   *
   * Add \`.not\` earlier in the chain to negate \`.arguments\`. However, it's often
   * best to assert which type the target is expected to be, rather than
   * asserting that it’s not an \`arguments\` object.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.arguments; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect({}, 'nooo why fail??').to.be.arguments;
   *
   * The alias \`.Arguments\` can be used interchangeably with \`.arguments\`.
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */function checkArguments(){var obj=flag(this,'object'),type=_.type(obj);this.assert('Arguments'===type,'expected #{this} to be arguments but got '+type,'expected #{this} to not be arguments');}Assertion.addProperty('arguments',checkArguments);Assertion.addProperty('Arguments',checkArguments);/**
   * ### .equal(val[, msg])
   *
   * Asserts that the target is strictly (\`===\`) equal to the given \`val\`.
   *
   *     expect(1).to.equal(1);
   *     expect('foo').to.equal('foo');
   *
   * Add \`.deep\` earlier in the chain to use deep equality instead. See the
   * \`deep-eql\` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals \`{a: 1}\`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) equals \`[1, 2]\`
   *     expect([1, 2]).to.deep.equal([1, 2]);
   *     expect([1, 2]).to.not.equal([1, 2]);
   *
   * Add \`.not\` earlier in the chain to negate \`.equal\`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to one of countless unexpected values.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.equal(2); // Not recommended
   *
   * \`.equal\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect(1).to.equal(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.equal(2);
   *
   * The aliases \`.equals\` and \`eq\` can be used interchangeably with \`.equal\`.
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertEqual(val,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object');if(flag(this,'deep')){var prevLockSsfi=flag(this,'lockSsfi');flag(this,'lockSsfi',true);this.eql(val);flag(this,'lockSsfi',prevLockSsfi);}else{this.assert(val===obj,'expected #{this} to equal #{exp}','expected #{this} to not equal #{exp}',val,this._obj,true);}}Assertion.addMethod('equal',assertEqual);Assertion.addMethod('equals',assertEqual);Assertion.addMethod('eq',assertEqual);/**
   * ### .eql(obj[, msg])
   *
   * Asserts that the target is deeply equal to the given \`obj\`. See the
   * \`deep-eql\` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object is deeply (but not strictly) equal to {a: 1}
   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});
   *
   *     // Target array is deeply (but not strictly) equal to [1, 2]
   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
   *
   * Add \`.not\` earlier in the chain to negate \`.eql\`. However, it's often best
   * to assert that the target is deeply equal to its expected value, rather
   * than not deeply equal to one of countless unexpected values.
   *
   *     expect({a: 1}).to.eql({a: 1}); // Recommended
   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended
   *
   * \`.eql\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
   *
   * The alias \`.eqls\` can be used interchangeably with \`.eql\`.
   *
   * The \`.deep.equal\` assertion is almost identical to \`.eql\` but with one
   * difference: \`.deep.equal\` causes deep equality comparisons to also be used
   * for any other assertions that follow in the chain.
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} obj
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertEql(obj,msg){if(msg)flag(this,'message',msg);var eql=flag(this,'eql');this.assert(eql(obj,flag(this,'object')),'expected #{this} to deeply equal #{exp}','expected #{this} to not deeply equal #{exp}',obj,this._obj,true);}Assertion.addMethod('eql',assertEql);Assertion.addMethod('eqls',assertEql);/**
   * ### .above(n[, msg])
   *
   * Asserts that the target is a number or a date greater than the given number or date \`n\` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.above(1); // Not recommended
   *
   * Add \`.lengthOf\` earlier in the chain to assert that the target's \`length\`
   * or \`size\` is greater than the given number \`n\`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.above(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.above\`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(1).to.not.be.above(2); // Not recommended
   *
   * \`.above\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect(1).to.be.above(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.above(2);
   *
   * The aliases \`.gt\` and \`.greaterThan\` can be used interchangeably with
   * \`.above\`.
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertAbove(n,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),doLength=flag(this,'doLength'),flagMsg=flag(this,'message'),msgPrefix=flagMsg?flagMsg+': ':'',ssfi=flag(this,'ssfi'),objType=_.type(obj).toLowerCase(),nType=_.type(n).toLowerCase(),errorMessage,shouldThrow=true;if(doLength&&objType!=='map'&&objType!=='set'){new Assertion(obj,flagMsg,ssfi,true).to.have.property('length');}if(!doLength&&objType==='date'&&nType!=='date'){errorMessage=msgPrefix+'the argument to above must be a date';}else if(nType!=='number'&&(doLength||objType==='number')){errorMessage=msgPrefix+'the argument to above must be a number';}else if(!doLength&&objType!=='date'&&objType!=='number'){var printObj=objType==='string'?"'"+obj+"'":obj;errorMessage=msgPrefix+'expected '+printObj+' to be a number or a date';}else{shouldThrow=false;}if(shouldThrow){throw new AssertionError(errorMessage,undefined,ssfi);}if(doLength){var descriptor='length',itemsCount;if(objType==='map'||objType==='set'){descriptor='size';itemsCount=obj.size;}else{itemsCount=obj.length;}this.assert(itemsCount>n,'expected #{this} to have a '+descriptor+' above #{exp} but got #{act}','expected #{this} to not have a '+descriptor+' above #{exp}',n,itemsCount);}else{this.assert(obj>n,'expected #{this} to be above #{exp}','expected #{this} to be at most #{exp}',n);}}Assertion.addMethod('above',assertAbove);Assertion.addMethod('gt',assertAbove);Assertion.addMethod('greaterThan',assertAbove);/**
   * ### .least(n[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date \`n\` respectively. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.at.least(1); // Not recommended
   *     expect(2).to.be.at.least(2); // Not recommended
   *
   * Add \`.lengthOf\` earlier in the chain to assert that the target's \`length\`
   * or \`size\` is greater than or equal to the given number \`n\`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.least\`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.at.least(2); // Not recommended
   *
   * \`.least\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect(1).to.be.at.least(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.at.least(2);
   *
   * The aliases \`.gte\` and \`.greaterThanOrEqual\` can be used interchangeably with
   * \`.least\`.
   *
   * @name least
   * @alias gte
   * @alias greaterThanOrEqual
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertLeast(n,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),doLength=flag(this,'doLength'),flagMsg=flag(this,'message'),msgPrefix=flagMsg?flagMsg+': ':'',ssfi=flag(this,'ssfi'),objType=_.type(obj).toLowerCase(),nType=_.type(n).toLowerCase(),errorMessage,shouldThrow=true;if(doLength&&objType!=='map'&&objType!=='set'){new Assertion(obj,flagMsg,ssfi,true).to.have.property('length');}if(!doLength&&objType==='date'&&nType!=='date'){errorMessage=msgPrefix+'the argument to least must be a date';}else if(nType!=='number'&&(doLength||objType==='number')){errorMessage=msgPrefix+'the argument to least must be a number';}else if(!doLength&&objType!=='date'&&objType!=='number'){var printObj=objType==='string'?"'"+obj+"'":obj;errorMessage=msgPrefix+'expected '+printObj+' to be a number or a date';}else{shouldThrow=false;}if(shouldThrow){throw new AssertionError(errorMessage,undefined,ssfi);}if(doLength){var descriptor='length',itemsCount;if(objType==='map'||objType==='set'){descriptor='size';itemsCount=obj.size;}else{itemsCount=obj.length;}this.assert(itemsCount>=n,'expected #{this} to have a '+descriptor+' at least #{exp} but got #{act}','expected #{this} to have a '+descriptor+' below #{exp}',n,itemsCount);}else{this.assert(obj>=n,'expected #{this} to be at least #{exp}','expected #{this} to be below #{exp}',n);}}Assertion.addMethod('least',assertLeast);Assertion.addMethod('gte',assertLeast);Assertion.addMethod('greaterThanOrEqual',assertLeast);/**
   * ### .below(n[, msg])
   *
   * Asserts that the target is a number or a date less than the given number or date \`n\` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.below(2); // Not recommended
   *
   * Add \`.lengthOf\` earlier in the chain to assert that the target's \`length\`
   * or \`size\` is less than the given number \`n\`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.below(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.length(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.below\`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.below(1); // Not recommended
   *
   * \`.below\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect(2).to.be.below(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.below(1);
   *
   * The aliases \`.lt\` and \`.lessThan\` can be used interchangeably with
   * \`.below\`.
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertBelow(n,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),doLength=flag(this,'doLength'),flagMsg=flag(this,'message'),msgPrefix=flagMsg?flagMsg+': ':'',ssfi=flag(this,'ssfi'),objType=_.type(obj).toLowerCase(),nType=_.type(n).toLowerCase(),errorMessage,shouldThrow=true;if(doLength&&objType!=='map'&&objType!=='set'){new Assertion(obj,flagMsg,ssfi,true).to.have.property('length');}if(!doLength&&objType==='date'&&nType!=='date'){errorMessage=msgPrefix+'the argument to below must be a date';}else if(nType!=='number'&&(doLength||objType==='number')){errorMessage=msgPrefix+'the argument to below must be a number';}else if(!doLength&&objType!=='date'&&objType!=='number'){var printObj=objType==='string'?"'"+obj+"'":obj;errorMessage=msgPrefix+'expected '+printObj+' to be a number or a date';}else{shouldThrow=false;}if(shouldThrow){throw new AssertionError(errorMessage,undefined,ssfi);}if(doLength){var descriptor='length',itemsCount;if(objType==='map'||objType==='set'){descriptor='size';itemsCount=obj.size;}else{itemsCount=obj.length;}this.assert(itemsCount<n,'expected #{this} to have a '+descriptor+' below #{exp} but got #{act}','expected #{this} to not have a '+descriptor+' below #{exp}',n,itemsCount);}else{this.assert(obj<n,'expected #{this} to be below #{exp}','expected #{this} to be at least #{exp}',n);}}Assertion.addMethod('below',assertBelow);Assertion.addMethod('lt',assertBelow);Assertion.addMethod('lessThan',assertBelow);/**
   * ### .most(n[, msg])
   *
   * Asserts that the target is a number or a date less than or equal to the given number
   * or date \`n\` respectively. However, it's often best to assert that the target is equal to its
   * expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.at.most(2); // Not recommended
   *     expect(1).to.be.at.most(1); // Not recommended
   *
   * Add \`.lengthOf\` earlier in the chain to assert that the target's \`length\`
   * or \`size\` is less than or equal to the given number \`n\`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.most\`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.at.most(1); // Not recommended
   *
   * \`.most\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect(2).to.be.at.most(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.at.most(1);
   *
   * The aliases \`.lte\` and \`.lessThanOrEqual\` can be used interchangeably with
   * \`.most\`.
   *
   * @name most
   * @alias lte
   * @alias lessThanOrEqual
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertMost(n,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),doLength=flag(this,'doLength'),flagMsg=flag(this,'message'),msgPrefix=flagMsg?flagMsg+': ':'',ssfi=flag(this,'ssfi'),objType=_.type(obj).toLowerCase(),nType=_.type(n).toLowerCase(),errorMessage,shouldThrow=true;if(doLength&&objType!=='map'&&objType!=='set'){new Assertion(obj,flagMsg,ssfi,true).to.have.property('length');}if(!doLength&&objType==='date'&&nType!=='date'){errorMessage=msgPrefix+'the argument to most must be a date';}else if(nType!=='number'&&(doLength||objType==='number')){errorMessage=msgPrefix+'the argument to most must be a number';}else if(!doLength&&objType!=='date'&&objType!=='number'){var printObj=objType==='string'?"'"+obj+"'":obj;errorMessage=msgPrefix+'expected '+printObj+' to be a number or a date';}else{shouldThrow=false;}if(shouldThrow){throw new AssertionError(errorMessage,undefined,ssfi);}if(doLength){var descriptor='length',itemsCount;if(objType==='map'||objType==='set'){descriptor='size';itemsCount=obj.size;}else{itemsCount=obj.length;}this.assert(itemsCount<=n,'expected #{this} to have a '+descriptor+' at most #{exp} but got #{act}','expected #{this} to have a '+descriptor+' above #{exp}',n,itemsCount);}else{this.assert(obj<=n,'expected #{this} to be at most #{exp}','expected #{this} to be above #{exp}',n);}}Assertion.addMethod('most',assertMost);Assertion.addMethod('lte',assertMost);Assertion.addMethod('lessThanOrEqual',assertMost);/**
   * ### .within(start, finish[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date \`start\`, and less than or equal to the given number or date \`finish\` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.within(1, 3); // Not recommended
   *     expect(2).to.be.within(2, 3); // Not recommended
   *     expect(2).to.be.within(1, 2); // Not recommended
   *
   * Add \`.lengthOf\` earlier in the chain to assert that the target's \`length\`
   * or \`size\` is greater than or equal to the given number \`start\`, and less
   * than or equal to the given number \`finish\`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.within\`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.within(2, 4); // Not recommended
   *
   * \`.within\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect(4).to.be.within(1, 3, 'nooo why fail??');
   *     expect(4, 'nooo why fail??').to.be.within(1, 3);
   *
   * @name within
   * @param {Number} start lower bound inclusive
   * @param {Number} finish upper bound inclusive
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */Assertion.addMethod('within',function(start,finish,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),doLength=flag(this,'doLength'),flagMsg=flag(this,'message'),msgPrefix=flagMsg?flagMsg+': ':'',ssfi=flag(this,'ssfi'),objType=_.type(obj).toLowerCase(),startType=_.type(start).toLowerCase(),finishType=_.type(finish).toLowerCase(),errorMessage,shouldThrow=true,range=startType==='date'&&finishType==='date'?start.toISOString()+'..'+finish.toISOString():start+'..'+finish;if(doLength&&objType!=='map'&&objType!=='set'){new Assertion(obj,flagMsg,ssfi,true).to.have.property('length');}if(!doLength&&objType==='date'&&(startType!=='date'||finishType!=='date')){errorMessage=msgPrefix+'the arguments to within must be dates';}else if((startType!=='number'||finishType!=='number')&&(doLength||objType==='number')){errorMessage=msgPrefix+'the arguments to within must be numbers';}else if(!doLength&&objType!=='date'&&objType!=='number'){var printObj=objType==='string'?"'"+obj+"'":obj;errorMessage=msgPrefix+'expected '+printObj+' to be a number or a date';}else{shouldThrow=false;}if(shouldThrow){throw new AssertionError(errorMessage,undefined,ssfi);}if(doLength){var descriptor='length',itemsCount;if(objType==='map'||objType==='set'){descriptor='size';itemsCount=obj.size;}else{itemsCount=obj.length;}this.assert(itemsCount>=start&&itemsCount<=finish,'expected #{this} to have a '+descriptor+' within '+range,'expected #{this} to not have a '+descriptor+' within '+range);}else{this.assert(obj>=start&&obj<=finish,'expected #{this} to be within '+range,'expected #{this} to not be within '+range);}});/**
   * ### .instanceof(constructor[, msg])
   *
   * Asserts that the target is an instance of the given \`constructor\`.
   *
   *     function Cat () { }
   *
   *     expect(new Cat()).to.be.an.instanceof(Cat);
   *     expect([1, 2]).to.be.an.instanceof(Array);
   *
   * Add \`.not\` earlier in the chain to negate \`.instanceof\`.
   *
   *     expect({a: 1}).to.not.be.an.instanceof(Array);
   *
   * \`.instanceof\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
   *
   * Due to limitations in ES5, \`.instanceof\` may not always work as expected
   * when using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing built-in object such as
   * \`Array\`, \`Error\`, and \`Map\`. See your transpiler's docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * The alias \`.instanceOf\` can be used interchangeably with \`.instanceof\`.
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} msg _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */function assertInstanceOf(constructor,msg){if(msg)flag(this,'message',msg);var target=flag(this,'object');var ssfi=flag(this,'ssfi');var flagMsg=flag(this,'message');try{var isInstanceOf=target instanceof constructor;}catch(err){if(err instanceof TypeError){flagMsg=flagMsg?flagMsg+': ':'';throw new AssertionError(flagMsg+'The instanceof assertion needs a constructor but '+_.type(constructor)+' was given.',undefined,ssfi);}throw err;}var name=_.getName(constructor);if(name===null){name='an unnamed constructor';}this.assert(isInstanceOf,'expected #{this} to be an instance of '+name,'expected #{this} to not be an instance of '+name);}Assertion.addMethod('instanceof',assertInstanceOf);Assertion.addMethod('instanceOf',assertInstanceOf);/**
   * ### .property(name[, val[, msg]])
   *
   * Asserts that the target has a property with the given key \`name\`.
   *
   *     expect({a: 1}).to.have.property('a');
   *
   * When \`val\` is provided, \`.property\` also asserts that the property's value
   * is equal to the given \`val\`.
   *
   *     expect({a: 1}).to.have.property('a', 1);
   *
   * By default, strict (\`===\`) equality is used. Add \`.deep\` earlier in the
   * chain to use deep equality instead. See the \`deep-eql\` project page for
   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) has property \`x: {a: 1}\`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * The target's enumerable and non-enumerable properties are always included
   * in the search. By default, both own and inherited properties are included.
   * Add \`.own\` earlier in the chain to exclude inherited properties from the
   * search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.own.property('a', 1);
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   * \`.deep\` and \`.own\` can be combined.
   *
   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
   *
   * Add \`.nested\` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
   *
   * If \`.\` or \`[]\` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');
   *
   * \`.deep\` and \`.nested\` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}})
   *       .to.have.deep.nested.property('a.b[0]', {c: 3});
   *
   * \`.own\` and \`.nested\` cannot be combined.
   *
   * Add \`.not\` earlier in the chain to negate \`.property\`.
   *
   *     expect({a: 1}).to.not.have.property('b');
   *
   * However, it's dangerous to negate \`.property\` when providing \`val\`. The
   * problem is that it creates uncertain expectations by asserting that the
   * target either doesn't have a property with the given key \`name\`, or that it
   * does have a property with the given key \`name\` but its value isn't equal to
   * the given \`val\`. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property with the given key
   * \`name\`, it's often best to assert exactly that.
   *
   *     expect({b: 2}).to.not.have.property('a'); // Recommended
   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended
   *
   * When the target is expected to have a property with the given key \`name\`,
   * it's often best to assert that the property has its expected value, rather
   * than asserting that it doesn't have one of many unexpected values.
   *
   *     expect({a: 3}).to.have.property('a', 3); // Recommended
   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended
   *
   * \`.property\` changes the target of any assertions that follow in the chain
   * to be the value of the property from the original target object.
   *
   *     expect({a: 1}).to.have.property('a').that.is.a('number');
   *
   * \`.property\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`. When not providing \`val\`, only use the
   * second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');
   *
   *     // Not recommended
   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing \`val\`. Instead,
   * it's asserting that the target object has a \`b\` property that's equal to
   * \`undefined\`.
   *
   * The assertions \`.ownProperty\` and \`.haveOwnProperty\` can be used
   * interchangeably with \`.own.property\`.
   *
   * @name property
   * @param {String} name
   * @param {Mixed} val (optional)
   * @param {String} msg _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */function assertProperty(name,val,msg){if(msg)flag(this,'message',msg);var isNested=flag(this,'nested'),isOwn=flag(this,'own'),flagMsg=flag(this,'message'),obj=flag(this,'object'),ssfi=flag(this,'ssfi'),nameType=typeof name;flagMsg=flagMsg?flagMsg+': ':'';if(isNested){if(nameType!=='string'){throw new AssertionError(flagMsg+'the argument to property must be a string when using nested syntax',undefined,ssfi);}}else{if(nameType!=='string'&&nameType!=='number'&&nameType!=='symbol'){throw new AssertionError(flagMsg+'the argument to property must be a string, number, or symbol',undefined,ssfi);}}if(isNested&&isOwn){throw new AssertionError(flagMsg+'The "nested" and "own" flags cannot be combined.',undefined,ssfi);}if(obj===null||obj===undefined){throw new AssertionError(flagMsg+'Target cannot be null or undefined.',undefined,ssfi);}var isDeep=flag(this,'deep'),negate=flag(this,'negate'),pathInfo=isNested?_.getPathInfo(obj,name):null,value=isNested?pathInfo.value:obj[name],isEql=isDeep?flag(this,'eql'):(val1,val2)=>val1===val2;var descriptor='';if(isDeep)descriptor+='deep ';if(isOwn)descriptor+='own ';if(isNested)descriptor+='nested ';descriptor+='property ';var hasProperty;if(isOwn)hasProperty=Object.prototype.hasOwnProperty.call(obj,name);else if(isNested)hasProperty=pathInfo.exists;else hasProperty=_.hasProperty(obj,name);// When performing a negated assertion for both name and val, merely having
// a property with the given name isn't enough to cause the assertion to
// fail. It must both have a property with the given name, and the value of
// that property must equal the given val. Therefore, skip this assertion in
// favor of the next.
if(!negate||arguments.length===1){this.assert(hasProperty,'expected #{this} to have '+descriptor+_.inspect(name),'expected #{this} to not have '+descriptor+_.inspect(name));}if(arguments.length>1){this.assert(hasProperty&&isEql(val,value),'expected #{this} to have '+descriptor+_.inspect(name)+' of #{exp}, but got #{act}','expected #{this} to not have '+descriptor+_.inspect(name)+' of #{act}',val,value);}flag(this,'object',value);}Assertion.addMethod('property',assertProperty);function assertOwnProperty(name,value,msg){flag(this,'own',true);assertProperty.apply(this,arguments);}Assertion.addMethod('ownProperty',assertOwnProperty);Assertion.addMethod('haveOwnProperty',assertOwnProperty);/**
   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])
   *
   * Asserts that the target has its own property descriptor with the given key
   * \`name\`. Enumerable and non-enumerable properties are included in the
   * search.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');
   *
   * When \`descriptor\` is provided, \`.ownPropertyDescriptor\` also asserts that
   * the property's descriptor is deeply equal to the given \`descriptor\`. See
   * the \`deep-eql\` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * Add \`.not\` earlier in the chain to negate \`.ownPropertyDescriptor\`.
   *
   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
   *
   * However, it's dangerous to negate \`.ownPropertyDescriptor\` when providing
   * a \`descriptor\`. The problem is that it creates uncertain expectations by
   * asserting that the target either doesn't have a property descriptor with
   * the given key \`name\`, or that it does have a property descriptor with the
   * given key \`name\` but it’s not deeply equal to the given \`descriptor\`. It's
   * often best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property descriptor with the given
   * key \`name\`, it's often best to assert exactly that.
   *
   *     // Recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');
   *
   *     // Not recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * When the target is expected to have a property descriptor with the given
   * key \`name\`, it's often best to assert that the property has its expected
   * descriptor, rather than asserting that it doesn't have one of many
   * unexpected descriptors.
   *
   *     // Recommended
   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 3,
   *     });
   *
   *     // Not recommended
   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * \`.ownPropertyDescriptor\` changes the target of any assertions that follow
   * in the chain to be the value of the property descriptor from the original
   * target object.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')
   *       .that.has.property('enumerable', true);
   *
   * \`.ownPropertyDescriptor\` accepts an optional \`msg\` argument which is a
   * custom error message to show when the assertion fails. The message can also
   * be given as the second argument to \`expect\`. When not providing
   * \`descriptor\`, only use the second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     }, 'nooo why fail??');
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     });
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');
   *
   *     // Not recommended
   *     expect({a: 1})
   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing \`descriptor\`.
   * Instead, it's asserting that the target object has a \`b\` property
   * descriptor that's deeply equal to \`undefined\`.
   *
   * The alias \`.haveOwnPropertyDescriptor\` can be used interchangeably with
   * \`.ownPropertyDescriptor\`.
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertOwnPropertyDescriptor(name,descriptor,msg){if(typeof descriptor==='string'){msg=descriptor;descriptor=null;}if(msg)flag(this,'message',msg);var obj=flag(this,'object');var actualDescriptor=Object.getOwnPropertyDescriptor(Object(obj),name);var eql=flag(this,'eql');if(actualDescriptor&&descriptor){this.assert(eql(descriptor,actualDescriptor),'expected the own property descriptor for '+_.inspect(name)+' on #{this} to match '+_.inspect(descriptor)+', got '+_.inspect(actualDescriptor),'expected the own property descriptor for '+_.inspect(name)+' on #{this} to not match '+_.inspect(descriptor),descriptor,actualDescriptor,true);}else{this.assert(actualDescriptor,'expected #{this} to have an own property descriptor for '+_.inspect(name),'expected #{this} to not have an own property descriptor for '+_.inspect(name));}flag(this,'object',actualDescriptor);}Assertion.addMethod('ownPropertyDescriptor',assertOwnPropertyDescriptor);Assertion.addMethod('haveOwnPropertyDescriptor',assertOwnPropertyDescriptor);/**
   * ### .lengthOf(n[, msg])
   *
   * Asserts that the target's \`length\` or \`size\` is equal to the given number
   * \`n\`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *     expect('foo').to.have.lengthOf(3);
   *     expect(new Set([1, 2, 3])).to.have.lengthOf(3);
   *     expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);
   *
   * Add \`.not\` earlier in the chain to negate \`.lengthOf\`. However, it's often
   * best to assert that the target's \`length\` property is equal to its expected
   * value, rather than not equal to one of many unexpected values.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.not.have.lengthOf(4); // Not recommended
   *
   * \`.lengthOf\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
   *
   * \`.lengthOf\` can also be used as a language chain, causing all \`.above\`,
   * \`.below\`, \`.least\`, \`.most\`, and \`.within\` assertions that follow in the
   * chain to use the target's \`length\` property as the target. However, it's
   * often best to assert that the target's \`length\` property is equal to its
   * expected length, rather than asserting that its \`length\` property falls
   * within some range of values.
   *
   *     // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *
   *     // Not recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2);
   *     expect([1, 2, 3]).to.have.lengthOf.below(4);
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);
   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);
   *
   * Due to a compatibility issue, the alias \`.length\` can't be chained directly
   * off of an uninvoked method such as \`.a\`. Therefore, \`.length\` can't be used
   * interchangeably with \`.lengthOf\` in every situation. It's recommended to
   * always use \`.lengthOf\` instead of \`.length\`.
   *
   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
   *
   * @name lengthOf
   * @alias length
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertLengthChain(){flag(this,'doLength',true);}function assertLength(n,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),objType=_.type(obj).toLowerCase(),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi'),descriptor='length',itemsCount;switch(objType){case'map':case'set':descriptor='size';itemsCount=obj.size;break;default:new Assertion(obj,flagMsg,ssfi,true).to.have.property('length');itemsCount=obj.length;}this.assert(itemsCount==n,'expected #{this} to have a '+descriptor+' of #{exp} but got #{act}','expected #{this} to not have a '+descriptor+' of #{act}',n,itemsCount);}Assertion.addChainableMethod('length',assertLength,assertLengthChain);Assertion.addChainableMethod('lengthOf',assertLength,assertLengthChain);/**
   * ### .match(re[, msg])
   *
   * Asserts that the target matches the given regular expression \`re\`.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * Add \`.not\` earlier in the chain to negate \`.match\`.
   *
   *     expect('foobar').to.not.match(/taco/);
   *
   * \`.match\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect('foobar').to.match(/taco/, 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.match(/taco/);
   *
   * The alias \`.matches\` can be used interchangeably with \`.match\`.
   *
   * @name match
   * @alias matches
   * @param {RegExp} re
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertMatch(re,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object');this.assert(re.exec(obj),'expected #{this} to match '+re,'expected #{this} not to match '+re);}Assertion.addMethod('match',assertMatch);Assertion.addMethod('matches',assertMatch);/**
   * ### .string(str[, msg])
   *
   * Asserts that the target string contains the given substring \`str\`.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * Add \`.not\` earlier in the chain to negate \`.string\`.
   *
   *     expect('foobar').to.not.have.string('taco');
   *
   * \`.string\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect('foobar').to.have.string('taco', 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.have.string('taco');
   *
   * @name string
   * @param {String} str
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */Assertion.addMethod('string',function(str,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi');new Assertion(obj,flagMsg,ssfi,true).is.a('string');this.assert(~obj.indexOf(str),'expected #{this} to contain '+_.inspect(str),'expected #{this} to not contain '+_.inspect(str));});/**
   * ### .keys(key1[, key2[, ...]])
   *
   * Asserts that the target object, array, map, or set has the given keys. Only
   * the target's own inherited properties are included in the search.
   *
   * When the target is an object or array, keys can be provided as one or more
   * string arguments, a single array argument, or a single object argument. In
   * the latter case, only the keys in the given object matter; the values are
   * ignored.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *     expect(['x', 'y']).to.have.all.keys(0, 1);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
   *     expect(['x', 'y']).to.have.all.keys([0, 1]);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
   *
   * When the target is a map or set, each key must be provided as a separate
   * argument.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
   *
   * Because \`.keys\` does different things based on the target's type, it's
   * important to check the target's type before using \`.keys\`. See the \`.a\` doc
   * for info on testing a target's type.
   *
   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
   *
   * By default, strict (\`===\`) equality is used to compare keys of maps and
   * sets. Add \`.deep\` earlier in the chain to use deep equality instead. See
   * the \`deep-eql\` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target set deeply (but not strictly) has key \`{a: 1}\`
   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
   *
   * By default, the target must have all of the given keys and no more. Add
   * \`.any\` earlier in the chain to only require that the target have at least
   * one of the given keys. Also, add \`.not\` earlier in the chain to negate
   * \`.keys\`. It's often best to add \`.any\` when negating \`.keys\`, and to use
   * \`.all\` when asserting \`.keys\` without negation.
   *
   * When negating \`.keys\`, \`.any\` is preferred because \`.not.any.keys\` asserts
   * exactly what's expected of the output, whereas \`.not.all.keys\` creates
   * uncertain expectations.
   *
   *     // Recommended; asserts that target doesn't have any of the given keys
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   *     // Not recommended; asserts that target doesn't have all of the given
   *     // keys but may or may not have some of them
   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
   *
   * When asserting \`.keys\` without negation, \`.all\` is preferred because
   * \`.all.keys\` asserts exactly what's expected of the output, whereas
   * \`.any.keys\` creates uncertain expectations.
   *
   *     // Recommended; asserts that target has all the given keys
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   *     // Not recommended; asserts that target has at least one of the given
   *     // keys but may or may not have more of them
   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
   *
   * Note that \`.all\` is used by default when neither \`.all\` nor \`.any\` appear
   * earlier in the chain. However, it's often best to add \`.all\` anyway because
   * it improves readability.
   *
   *     // Both assertions are identical
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
   *
   * Add \`.include\` earlier in the chain to require that the target's keys be a
   * superset of the expected keys, rather than identical sets.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   * However, if \`.any\` and \`.include\` are combined, only the \`.any\` takes
   * effect. The \`.include\` is ignored in this case.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');
   *
   * The alias \`.key\` can be used interchangeably with \`.keys\`.
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */function assertKeys(keys){var obj=flag(this,'object'),objType=_.type(obj),keysType=_.type(keys),ssfi=flag(this,'ssfi'),isDeep=flag(this,'deep'),str,deepStr='',actual,ok=true,flagMsg=flag(this,'message');flagMsg=flagMsg?flagMsg+': ':'';var mixedArgsMsg=flagMsg+'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';if(objType==='Map'||objType==='Set'){deepStr=isDeep?'deeply ':'';actual=[];// Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.
obj.forEach(function(val,key){actual.push(key);});if(keysType!=='Array'){keys=Array.prototype.slice.call(arguments);}}else{actual=_.getOwnEnumerableProperties(obj);switch(keysType){case'Array':if(arguments.length>1){throw new AssertionError(mixedArgsMsg,undefined,ssfi);}break;case'Object':if(arguments.length>1){throw new AssertionError(mixedArgsMsg,undefined,ssfi);}keys=Object.keys(keys);break;default:keys=Array.prototype.slice.call(arguments);}// Only stringify non-Symbols because Symbols would become "Symbol()"
keys=keys.map(function(val){return typeof val==='symbol'?val:String(val);});}if(!keys.length){throw new AssertionError(flagMsg+'keys required',undefined,ssfi);}var len=keys.length,any=flag(this,'any'),all=flag(this,'all'),expected=keys,isEql=isDeep?flag(this,'eql'):(val1,val2)=>val1===val2;if(!any&&!all){all=true;}// Has any
if(any){ok=expected.some(function(expectedKey){return actual.some(function(actualKey){return isEql(expectedKey,actualKey);});});}// Has all
if(all){ok=expected.every(function(expectedKey){return actual.some(function(actualKey){return isEql(expectedKey,actualKey);});});if(!flag(this,'contains')){ok=ok&&keys.length==actual.length;}}// Key string
if(len>1){keys=keys.map(function(key){return _.inspect(key);});var last=keys.pop();if(all){str=keys.join(', ')+', and '+last;}if(any){str=keys.join(', ')+', or '+last;}}else{str=_.inspect(keys[0]);}// Form
str=(len>1?'keys ':'key ')+str;// Have / include
str=(flag(this,'contains')?'contain ':'have ')+str;// Assertion
this.assert(ok,'expected #{this} to '+deepStr+str,'expected #{this} to not '+deepStr+str,expected.slice(0).sort(_.compareByInspect),actual.sort(_.compareByInspect),true);}Assertion.addMethod('keys',assertKeys);Assertion.addMethod('key',assertKeys);/**
   * ### .throw([errorLike], [errMsgMatcher], [msg])
   *
   * When no arguments are provided, \`.throw\` invokes the target function and
   * asserts that an error is thrown.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw();
   *
   * When one argument is provided, and it's an error constructor, \`.throw\`
   * invokes the target function and asserts that an error is thrown that's an
   * instance of that error constructor.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError);
   *
   * When one argument is provided, and it's an error instance, \`.throw\` invokes
   * the target function and asserts that an error is thrown that's strictly
   * (\`===\`) equal to that error instance.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(err);
   *
   * When one argument is provided, and it's a string, \`.throw\` invokes the
   * target function and asserts that an error is thrown with a message that
   * contains that string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw('salmon');
   *
   * When one argument is provided, and it's a regular expression, \`.throw\`
   * invokes the target function and asserts that an error is thrown with a
   * message that matches that regular expression.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(/salmon/);
   *
   * When two arguments are provided, and the first is an error instance or
   * constructor, and the second is a string or regular expression, \`.throw\`
   * invokes the function and asserts that an error is thrown that fulfills both
   * conditions as described above.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon');
   *     expect(badFn).to.throw(TypeError, /salmon/);
   *     expect(badFn).to.throw(err, 'salmon');
   *     expect(badFn).to.throw(err, /salmon/);
   *
   * Add \`.not\` earlier in the chain to negate \`.throw\`.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw();
   *
   * However, it's dangerous to negate \`.throw\` when providing any arguments.
   * The problem is that it creates uncertain expectations by asserting that the
   * target either doesn't throw an error, or that it throws an error but of a
   * different type than the given type, or that it throws an error of the given
   * type but with a message that doesn't include the given string. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to throw an error, it's often best to assert
   * exactly that.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw(); // Recommended
   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * When the target is expected to throw an error, it's often best to assert
   * that the error is of its expected type, and has a message that includes an
   * expected string, rather than asserting that it doesn't have one of many
   * unexpected types, and doesn't have a message that includes some string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * \`.throw\` changes the target of any assertions that follow in the chain to
   * be the error object that's thrown.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     err.code = 42;
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError).with.property('code', 42);
   *
   * \`.throw\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`. When not providing two arguments, always use
   * the second form.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
   *     expect(goodFn, 'nooo why fail??').to.throw();
   *
   * Due to limitations in ES5, \`.throw\` may not always work as expected when
   * using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing the built-in \`Error\` object and
   * then passing the subclassed constructor to \`.throw\`. See your transpiler's
   * docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * Beware of some common mistakes when using the \`throw\` assertion. One common
   * mistake is to accidentally invoke the function yourself instead of letting
   * the \`throw\` assertion invoke the function for you. For example, when
   * testing if a function named \`fn\` throws, provide \`fn\` instead of \`fn()\` as
   * the target for the assertion.
   *
   *     expect(fn).to.throw();     // Good! Tests \`fn\` as desired
   *     expect(fn()).to.throw();   // Bad! Tests result of \`fn()\`, not \`fn\`
   *
   * If you need to assert that your function \`fn\` throws when passed certain
   * arguments, then wrap a call to \`fn\` inside of another function.
   *
   *     expect(function () { fn(42); }).to.throw();  // Function expression
   *     expect(() => fn(42)).to.throw();             // ES6 arrow function
   *
   * Another common mistake is to provide an object method (or any stand-alone
   * function that relies on \`this\`) as the target of the assertion. Doing so is
   * problematic because the \`this\` context will be lost when the function is
   * invoked by \`.throw\`; there's no way for it to know what \`this\` is supposed
   * to be. There are two ways around this problem. One solution is to wrap the
   * method or function call inside of another function. Another solution is to
   * use \`bind\`.
   *
   *     expect(function () { cat.meow(); }).to.throw();  // Function expression
   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function
   *     expect(cat.meow.bind(cat)).to.throw();           // Bind
   *
   * Finally, it's worth mentioning that it's a best practice in JavaScript to
   * only throw \`Error\` and derivatives of \`Error\` such as \`ReferenceError\`,
   * \`TypeError\`, and user-defined objects that extend \`Error\`. No other type of
   * value will generate a stack trace when initialized. With that said, the
   * \`throw\` assertion does technically support any type of value being thrown,
   * not just \`Error\` and its derivatives.
   *
   * The aliases \`.throws\` and \`.Throw\` can be used interchangeably with
   * \`.throw\`.
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {Error|ErrorConstructor} errorLike
   * @param {String|RegExp} errMsgMatcher error message
   * @param {String} msg _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */function assertThrows(errorLike,errMsgMatcher,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),ssfi=flag(this,'ssfi'),flagMsg=flag(this,'message'),negate=flag(this,'negate')||false;new Assertion(obj,flagMsg,ssfi,true).is.a('function');if(errorLike instanceof RegExp||typeof errorLike==='string'){errMsgMatcher=errorLike;errorLike=null;}var caughtErr;try{obj();}catch(err){caughtErr=err;}// If we have the negate flag enabled and at least one valid argument it means we do expect an error
// but we want it to match a given set of criteria
var everyArgIsUndefined=errorLike===undefined&&errMsgMatcher===undefined;// If we've got the negate flag enabled and both args, we should only fail if both aren't compatible
// See Issue #551 and PR #683@GitHub
var everyArgIsDefined=Boolean(errorLike&&errMsgMatcher);var errorLikeFail=false;var errMsgMatcherFail=false;// Checking if error was thrown
if(everyArgIsUndefined||!everyArgIsUndefined&&!negate){// We need this to display results correctly according to their types
var errorLikeString='an error';if(errorLike instanceof Error){errorLikeString='#{exp}';}else if(errorLike){errorLikeString=_.checkError.getConstructorName(errorLike);}this.assert(caughtErr,'expected #{this} to throw '+errorLikeString,'expected #{this} to not throw an error but #{act} was thrown',errorLike&&errorLike.toString(),caughtErr instanceof Error?caughtErr.toString():typeof caughtErr==='string'?caughtErr:caughtErr&&_.checkError.getConstructorName(caughtErr));}if(errorLike&&caughtErr){// We should compare instances only if \`errorLike\` is an instance of \`Error\`
if(errorLike instanceof Error){var isCompatibleInstance=_.checkError.compatibleInstance(caughtErr,errorLike);if(isCompatibleInstance===negate){// These checks were created to ensure we won't fail too soon when we've got both args and a negate
// See Issue #551 and PR #683@GitHub
if(everyArgIsDefined&&negate){errorLikeFail=true;}else{this.assert(negate,'expected #{this} to throw #{exp} but #{act} was thrown','expected #{this} to not throw #{exp}'+(caughtErr&&!negate?' but #{act} was thrown':''),errorLike.toString(),caughtErr.toString());}}}var isCompatibleConstructor=_.checkError.compatibleConstructor(caughtErr,errorLike);if(isCompatibleConstructor===negate){if(everyArgIsDefined&&negate){errorLikeFail=true;}else{this.assert(negate,'expected #{this} to throw #{exp} but #{act} was thrown','expected #{this} to not throw #{exp}'+(caughtErr?' but #{act} was thrown':''),errorLike instanceof Error?errorLike.toString():errorLike&&_.checkError.getConstructorName(errorLike),caughtErr instanceof Error?caughtErr.toString():caughtErr&&_.checkError.getConstructorName(caughtErr));}}}if(caughtErr&&errMsgMatcher!==undefined&&errMsgMatcher!==null){// Here we check compatible messages
var placeholder='including';if(errMsgMatcher instanceof RegExp){placeholder='matching';}var isCompatibleMessage=_.checkError.compatibleMessage(caughtErr,errMsgMatcher);if(isCompatibleMessage===negate){if(everyArgIsDefined&&negate){errMsgMatcherFail=true;}else{this.assert(negate,'expected #{this} to throw error '+placeholder+' #{exp} but got #{act}','expected #{this} to throw error not '+placeholder+' #{exp}',errMsgMatcher,_.checkError.getMessage(caughtErr));}}}// If both assertions failed and both should've matched we throw an error
if(errorLikeFail&&errMsgMatcherFail){this.assert(negate,'expected #{this} to throw #{exp} but #{act} was thrown','expected #{this} to not throw #{exp}'+(caughtErr?' but #{act} was thrown':''),errorLike instanceof Error?errorLike.toString():errorLike&&_.checkError.getConstructorName(errorLike),caughtErr instanceof Error?caughtErr.toString():caughtErr&&_.checkError.getConstructorName(caughtErr));}flag(this,'object',caughtErr);}Assertion.addMethod('throw',assertThrows);Assertion.addMethod('throws',assertThrows);Assertion.addMethod('Throw',assertThrows);/**
   * ### .respondTo(method[, msg])
   *
   * When the target is a non-function object, \`.respondTo\` asserts that the
   * target has a method with the given name \`method\`. The method can be own or
   * inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.respondTo('meow');
   *
   * When the target is a function, \`.respondTo\` asserts that the target's
   * \`prototype\` property has a method with the given name \`method\`. Again, the
   * method can be own or inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(Cat).to.respondTo('meow');
   *
   * Add \`.itself\` earlier in the chain to force \`.respondTo\` to treat the
   * target as a non-function object, even if it's a function. Thus, it asserts
   * that the target has a method with the given name \`method\`, rather than
   * asserting that the target's \`prototype\` property has a method with the
   * given name \`method\`.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * When not adding \`.itself\`, it's important to check the target's type before
   * using \`.respondTo\`. See the \`.a\` doc for info on checking a target's type.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');
   *
   * Add \`.not\` earlier in the chain to negate \`.respondTo\`.
   *
   *     function Dog () {}
   *     Dog.prototype.bark = function () {};
   *
   *     expect(new Dog()).to.not.respondTo('meow');
   *
   * \`.respondTo\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect({}).to.respondTo('meow', 'nooo why fail??');
   *     expect({}, 'nooo why fail??').to.respondTo('meow');
   *
   * The alias \`.respondsTo\` can be used interchangeably with \`.respondTo\`.
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function respondTo(method,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),itself=flag(this,'itself'),context='function'===typeof obj&&!itself?obj.prototype[method]:obj[method];this.assert('function'===typeof context,'expected #{this} to respond to '+_.inspect(method),'expected #{this} to not respond to '+_.inspect(method));}Assertion.addMethod('respondTo',respondTo);Assertion.addMethod('respondsTo',respondTo);/**
   * ### .itself
   *
   * Forces all \`.respondTo\` assertions that follow in the chain to behave as if
   * the target is a non-function object, even if it's a function. Thus, it
   * causes \`.respondTo\` to assert that the target has a method with the given
   * name, rather than asserting that the target's \`prototype\` property has a
   * method with the given name.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */Assertion.addProperty('itself',function(){flag(this,'itself',true);});/**
   * ### .satisfy(matcher[, msg])
   *
   * Invokes the given \`matcher\` function with the target being passed as the
   * first argument, and asserts that the value returned is truthy.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 0;
   *     });
   *
   * Add \`.not\` earlier in the chain to negate \`.satisfy\`.
   *
   *     expect(1).to.not.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * \`.satisfy\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 2;
   *     }, 'nooo why fail??');
   *
   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * The alias \`.satisfies\` can be used interchangeably with \`.satisfy\`.
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function satisfy(matcher,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object');var result=matcher(obj);this.assert(result,'expected #{this} to satisfy '+_.objDisplay(matcher),'expected #{this} to not satisfy'+_.objDisplay(matcher),flag(this,'negate')?false:true,result);}Assertion.addMethod('satisfy',satisfy);Assertion.addMethod('satisfies',satisfy);/**
   * ### .closeTo(expected, delta[, msg])
   *
   * Asserts that the target is a number that's within a given +/- \`delta\` range
   * of the given number \`expected\`. However, it's often best to assert that the
   * target is equal to its expected value.
   *
   *     // Recommended
   *     expect(1.5).to.equal(1.5);
   *
   *     // Not recommended
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *     expect(1.5).to.be.closeTo(2, 0.5);
   *     expect(1.5).to.be.closeTo(1, 1);
   *
   * Add \`.not\` earlier in the chain to negate \`.closeTo\`.
   *
   *     expect(1.5).to.equal(1.5); // Recommended
   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
   *
   * \`.closeTo\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
   *
   * The alias \`.approximately\` can be used interchangeably with \`.closeTo\`.
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function closeTo(expected,delta,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi');new Assertion(obj,flagMsg,ssfi,true).is.a('number');if(typeof expected!=='number'||typeof delta!=='number'){flagMsg=flagMsg?flagMsg+': ':'';var deltaMessage=delta===undefined?", and a delta is required":"";throw new AssertionError(flagMsg+'the arguments to closeTo or approximately must be numbers'+deltaMessage,undefined,ssfi);}this.assert(Math.abs(obj-expected)<=delta,'expected #{this} to be close to '+expected+' +/- '+delta,'expected #{this} not to be close to '+expected+' +/- '+delta);}Assertion.addMethod('closeTo',closeTo);Assertion.addMethod('approximately',closeTo);// Note: Duplicates are ignored if testing for inclusion instead of sameness.
function isSubsetOf(subset,superset,cmp,contains,ordered){if(!contains){if(subset.length!==superset.length)return false;superset=superset.slice();}return subset.every(function(elem,idx){if(ordered)return cmp?cmp(elem,superset[idx]):elem===superset[idx];if(!cmp){var matchIdx=superset.indexOf(elem);if(matchIdx===-1)return false;// Remove match from superset so not counted twice if duplicate in subset.
if(!contains)superset.splice(matchIdx,1);return true;}return superset.some(function(elem2,matchIdx){if(!cmp(elem,elem2))return false;// Remove match from superset so not counted twice if duplicate in subset.
if(!contains)superset.splice(matchIdx,1);return true;});});}/**
   * ### .members(set[, msg])
   *
   * Asserts that the target array has the same members as the given array
   * \`set\`.
   *
   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);
   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);
   *
   * By default, members are compared using strict (\`===\`) equality. Add \`.deep\`
   * earlier in the chain to use deep equality instead. See the \`deep-eql\`
   * project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) has member \`{a: 1}\`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   * By default, order doesn't matter. Add \`.ordered\` earlier in the chain to
   * require that members appear in the same order.
   *
   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
   *     expect([1, 2, 3]).to.have.members([2, 1, 3])
   *       .but.not.ordered.members([2, 1, 3]);
   *
   * By default, both arrays must be the same size. Add \`.include\` earlier in
   * the chain to require that the target's members be a superset of the
   * expected members. Note that duplicates are ignored in the subset when
   * \`.include\` is added.
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * \`.deep\`, \`.ordered\`, and \`.include\` can all be combined. However, if
   * \`.include\` and \`.ordered\` are combined, the ordering begins at the start of
   * both arrays.
   *
   *     expect([{a: 1}, {b: 2}, {c: 3}])
   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])
   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
   *
   * Add \`.not\` earlier in the chain to negate \`.members\`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the target array doesn't have all of the same members as
   * the given array \`set\` but may or may not have some of them. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
   *
   * \`.members\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
   *
   * @name members
   * @param {Array} set
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */Assertion.addMethod('members',function(subset,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi');new Assertion(obj,flagMsg,ssfi,true).to.be.an('array');new Assertion(subset,flagMsg,ssfi,true).to.be.an('array');var contains=flag(this,'contains');var ordered=flag(this,'ordered');var subject,failMsg,failNegateMsg;if(contains){subject=ordered?'an ordered superset':'a superset';failMsg='expected #{this} to be '+subject+' of #{exp}';failNegateMsg='expected #{this} to not be '+subject+' of #{exp}';}else{subject=ordered?'ordered members':'members';failMsg='expected #{this} to have the same '+subject+' as #{exp}';failNegateMsg='expected #{this} to not have the same '+subject+' as #{exp}';}var cmp=flag(this,'deep')?flag(this,'eql'):undefined;this.assert(isSubsetOf(subset,obj,cmp,contains,ordered),failMsg,failNegateMsg,subset,obj,true);});/**
   * ### .oneOf(list[, msg])
   *
   * Asserts that the target is a member of the given array \`list\`. However,
   * it's often best to assert that the target is equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
   *
   * Comparisons are performed using strict (\`===\`) equality.
   *
   * Add \`.not\` earlier in the chain to negate \`.oneOf\`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
   *
   * It can also be chained with \`.contain\` or \`.include\`, which will work with
   * both arrays and strings:
   *
   *     expect('Today is sunny').to.contain.oneOf(['sunny', 'cloudy'])
   *     expect('Today is rainy').to.not.contain.oneOf(['sunny', 'cloudy'])
   *     expect([1,2,3]).to.contain.oneOf([3,4,5])
   *     expect([1,2,3]).to.not.contain.oneOf([4,5,6])
   *
   * \`.oneOf\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function oneOf(list,msg){if(msg)flag(this,'message',msg);var expected=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi'),contains=flag(this,'contains'),isDeep=flag(this,'deep'),eql=flag(this,'eql');new Assertion(list,flagMsg,ssfi,true).to.be.an('array');if(contains){this.assert(list.some(function(possibility){return expected.indexOf(possibility)>-1;}),'expected #{this} to contain one of #{exp}','expected #{this} to not contain one of #{exp}',list,expected);}else{if(isDeep){this.assert(list.some(function(possibility){return eql(expected,possibility);}),'expected #{this} to deeply equal one of #{exp}','expected #{this} to deeply equal one of #{exp}',list,expected);}else{this.assert(list.indexOf(expected)>-1,'expected #{this} to be one of #{exp}','expected #{this} to not be one of #{exp}',list,expected);}}}Assertion.addMethod('oneOf',oneOf);/**
   * ### .change(subject[, prop[, msg]])
   *
   * When one argument is provided, \`.change\` asserts that the given function
   * \`subject\` returns a different value when it's invoked before the target
   * function compared to when it's invoked afterward. However, it's often best
   * to assert that \`subject\` is equal to its expected value.
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     // Recommended
   *     expect(getDots()).to.equal('');
   *     addDot();
   *     expect(getDots()).to.equal('.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(getDots);
   *
   * When two arguments are provided, \`.change\` asserts that the value of the
   * given object \`subject\`'s \`prop\` property is different before invoking the
   * target function compared to afterward.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     // Recommended
   *     expect(myObj).to.have.property('dots', '');
   *     addDot();
   *     expect(myObj).to.have.property('dots', '.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(myObj, 'dots');
   *
   * Strict (\`===\`) equality is used to compare before and after values.
   *
   * Add \`.not\` earlier in the chain to negate \`.change\`.
   *
   *     var dots = ''
   *       , noop = function () {}
   *       , getDots = function () { return dots; };
   *
   *     expect(noop).to.not.change(getDots);
   *
   *     var myObj = {dots: ''}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'dots');
   *
   * \`.change\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);
   *
   * \`.change\` also causes all \`.by\` assertions that follow in the chain to
   * assert how much a numeric subject was increased or decreased by. However,
   * it's dangerous to use \`.change.by\`. The problem is that it creates
   * uncertain expectations by asserting that the subject either increases by
   * the given delta, or that it decreases by the given delta. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * The alias \`.changes\` can be used interchangeably with \`.change\`.
   *
   * @name change
   * @alias changes
   * @param {String} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertChanges(subject,prop,msg){if(msg)flag(this,'message',msg);var fn=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi');new Assertion(fn,flagMsg,ssfi,true).is.a('function');var initial;if(!prop){new Assertion(subject,flagMsg,ssfi,true).is.a('function');initial=subject();}else{new Assertion(subject,flagMsg,ssfi,true).to.have.property(prop);initial=subject[prop];}fn();var final=prop===undefined||prop===null?subject():subject[prop];var msgObj=prop===undefined||prop===null?initial:'.'+prop;// This gets flagged because of the .by(delta) assertion
flag(this,'deltaMsgObj',msgObj);flag(this,'initialDeltaValue',initial);flag(this,'finalDeltaValue',final);flag(this,'deltaBehavior','change');flag(this,'realDelta',final!==initial);this.assert(initial!==final,'expected '+msgObj+' to change','expected '+msgObj+' to not change');}Assertion.addMethod('change',assertChanges);Assertion.addMethod('changes',assertChanges);/**
   * ### .increase(subject[, prop[, msg]])
   *
   * When one argument is provided, \`.increase\` asserts that the given function
   * \`subject\` returns a greater number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. \`.increase\` also
   * causes all \`.by\` assertions that follow in the chain to assert how much
   * greater of a number is returned. It's often best to assert that the return
   * value increased by the expected amount, rather than asserting it increased
   * by any amount.
   *
   *     var val = 1
   *       , addTwo = function () { val += 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(addTwo).to.increase(getVal).by(2); // Recommended
   *     expect(addTwo).to.increase(getVal); // Not recommended
   *
   * When two arguments are provided, \`.increase\` asserts that the value of the
   * given object \`subject\`'s \`prop\` property is greater after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.increase\`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either decreases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to decrease, it's often best to assert that it
   * decreased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended
   *
   * \`.increase\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.increase(getVal);
   *
   * The alias \`.increases\` can be used interchangeably with \`.increase\`.
   *
   * @name increase
   * @alias increases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertIncreases(subject,prop,msg){if(msg)flag(this,'message',msg);var fn=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi');new Assertion(fn,flagMsg,ssfi,true).is.a('function');var initial;if(!prop){new Assertion(subject,flagMsg,ssfi,true).is.a('function');initial=subject();}else{new Assertion(subject,flagMsg,ssfi,true).to.have.property(prop);initial=subject[prop];}// Make sure that the target is a number
new Assertion(initial,flagMsg,ssfi,true).is.a('number');fn();var final=prop===undefined||prop===null?subject():subject[prop];var msgObj=prop===undefined||prop===null?initial:'.'+prop;flag(this,'deltaMsgObj',msgObj);flag(this,'initialDeltaValue',initial);flag(this,'finalDeltaValue',final);flag(this,'deltaBehavior','increase');flag(this,'realDelta',final-initial);this.assert(final-initial>0,'expected '+msgObj+' to increase','expected '+msgObj+' to not increase');}Assertion.addMethod('increase',assertIncreases);Assertion.addMethod('increases',assertIncreases);/**
   * ### .decrease(subject[, prop[, msg]])
   *
   * When one argument is provided, \`.decrease\` asserts that the given function
   * \`subject\` returns a lesser number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. \`.decrease\` also
   * causes all \`.by\` assertions that follow in the chain to assert how much
   * lesser of a number is returned. It's often best to assert that the return
   * value decreased by the expected amount, rather than asserting it decreased
   * by any amount.
   *
   *     var val = 1
   *       , subtractTwo = function () { val -= 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
   *     expect(subtractTwo).to.decrease(getVal); // Not recommended
   *
   * When two arguments are provided, \`.decrease\` asserts that the value of the
   * given object \`subject\`'s \`prop\` property is lesser after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.decrease\`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either increases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to increase, it's often best to assert that it
   * increased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * \`.decrease\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.decrease(getVal);
   *
   * The alias \`.decreases\` can be used interchangeably with \`.decrease\`.
   *
   * @name decrease
   * @alias decreases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertDecreases(subject,prop,msg){if(msg)flag(this,'message',msg);var fn=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi');new Assertion(fn,flagMsg,ssfi,true).is.a('function');var initial;if(!prop){new Assertion(subject,flagMsg,ssfi,true).is.a('function');initial=subject();}else{new Assertion(subject,flagMsg,ssfi,true).to.have.property(prop);initial=subject[prop];}// Make sure that the target is a number
new Assertion(initial,flagMsg,ssfi,true).is.a('number');fn();var final=prop===undefined||prop===null?subject():subject[prop];var msgObj=prop===undefined||prop===null?initial:'.'+prop;flag(this,'deltaMsgObj',msgObj);flag(this,'initialDeltaValue',initial);flag(this,'finalDeltaValue',final);flag(this,'deltaBehavior','decrease');flag(this,'realDelta',initial-final);this.assert(final-initial<0,'expected '+msgObj+' to decrease','expected '+msgObj+' to not decrease');}Assertion.addMethod('decrease',assertDecreases);Assertion.addMethod('decreases',assertDecreases);/**
   * ### .by(delta[, msg])
   *
   * When following an \`.increase\` assertion in the chain, \`.by\` asserts that
   * the subject of the \`.increase\` assertion increased by the given \`delta\`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   * When following a \`.decrease\` assertion in the chain, \`.by\` asserts that the
   * subject of the \`.decrease\` assertion decreased by the given \`delta\`.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);
   *
   * When following a \`.change\` assertion in the chain, \`.by\` asserts that the
   * subject of the \`.change\` assertion either increased or decreased by the
   * given \`delta\`. However, it's dangerous to use \`.change.by\`. The problem is
   * that it creates uncertain expectations. It's often best to identify the
   * exact output that's expected, and then write an assertion that only accepts
   * that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.by\`. However, it's often best
   * to assert that the subject changed by its expected delta, rather than
   * asserting that it didn't change by one of countless unexpected deltas.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     // Recommended
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   *     // Not recommended
   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
   *
   * \`.by\` accepts an optional \`msg\` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to \`expect\`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
   *
   * @name by
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertDelta(delta,msg){if(msg)flag(this,'message',msg);var msgObj=flag(this,'deltaMsgObj');var initial=flag(this,'initialDeltaValue');var final=flag(this,'finalDeltaValue');var behavior=flag(this,'deltaBehavior');var realDelta=flag(this,'realDelta');var expression;if(behavior==='change'){expression=Math.abs(final-initial)===Math.abs(delta);}else{expression=realDelta===Math.abs(delta);}this.assert(expression,'expected '+msgObj+' to '+behavior+' by '+delta,'expected '+msgObj+' to not '+behavior+' by '+delta);}Assertion.addMethod('by',assertDelta);/**
   * ### .extensible
   *
   * Asserts that the target is extensible, which means that new properties can
   * be added to it. Primitives are never extensible.
   *
   *     expect({a: 1}).to.be.extensible;
   *
   * Add \`.not\` earlier in the chain to negate \`.extensible\`.
   *
   *     var nonExtensibleObject = Object.preventExtensions({})
   *       , sealedObject = Object.seal({})
   *       , frozenObject = Object.freeze({});
   *
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *     expect(1).to.not.be.extensible;
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(1, 'nooo why fail??').to.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */Assertion.addProperty('extensible',function(){var obj=flag(this,'object');// In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
// In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
// The following provides ES6 behavior for ES5 environments.
var isExtensible=obj===Object(obj)&&Object.isExtensible(obj);this.assert(isExtensible,'expected #{this} to be extensible','expected #{this} to not be extensible');});/**
   * ### .sealed
   *
   * Asserts that the target is sealed, which means that new properties can't be
   * added to it, and its existing properties can't be reconfigured or deleted.
   * However, it's possible that its existing properties can still be reassigned
   * to different values. Primitives are always sealed.
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect(1).to.be.sealed;
   *
   * Add \`.not\` earlier in the chain to negate \`.sealed\`.
   *
   *     expect({a: 1}).to.not.be.sealed;
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */Assertion.addProperty('sealed',function(){var obj=flag(this,'object');// In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
// In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
// The following provides ES6 behavior for ES5 environments.
var isSealed=obj===Object(obj)?Object.isSealed(obj):true;this.assert(isSealed,'expected #{this} to be sealed','expected #{this} to not be sealed');});/**
   * ### .frozen
   *
   * Asserts that the target is frozen, which means that new properties can't be
   * added to it, and its existing properties can't be reassigned to different
   * values, reconfigured, or deleted. Primitives are always frozen.
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect(1).to.be.frozen;
   *
   * Add \`.not\` earlier in the chain to negate \`.frozen\`.
   *
   *     expect({a: 1}).to.not.be.frozen;
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */Assertion.addProperty('frozen',function(){var obj=flag(this,'object');// In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
// In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
// The following provides ES6 behavior for ES5 environments.
var isFrozen=obj===Object(obj)?Object.isFrozen(obj):true;this.assert(isFrozen,'expected #{this} to be frozen','expected #{this} to not be frozen');});/**
   * ### .finite
   *
   * Asserts that the target is a number, and isn't \`NaN\` or positive/negative
   * \`Infinity\`.
   *
   *     expect(1).to.be.finite;
   *
   * Add \`.not\` earlier in the chain to negate \`.finite\`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either isn't a number, or that it's \`NaN\`, or
   * that it's positive \`Infinity\`, or that it's negative \`Infinity\`. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to be a number, it's often best to assert
   * that it's the expected type, rather than asserting that it isn't one of
   * many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.finite; // Not recommended
   *
   * When the target is expected to be \`NaN\`, it's often best to assert exactly
   * that.
   *
   *     expect(NaN).to.be.NaN; // Recommended
   *     expect(NaN).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be positive infinity, it's often best to
   * assert exactly that.
   *
   *     expect(Infinity).to.equal(Infinity); // Recommended
   *     expect(Infinity).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be negative infinity, it's often best to
   * assert exactly that.
   *
   *     expect(-Infinity).to.equal(-Infinity); // Recommended
   *     expect(-Infinity).to.not.be.finite; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect('foo', 'nooo why fail??').to.be.finite;
   *
   * @name finite
   * @namespace BDD
   * @api public
   */Assertion.addProperty('finite',function(msg){var obj=flag(this,'object');this.assert(typeof obj==='number'&&isFinite(obj),'expected #{this} to be a finite number','expected #{this} to not be a finite number');});};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var expect$1=function(chai,util){chai.expect=function(val,message){return new chai.Assertion(val,message);};/**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   *     expect.fail();
   *     expect.fail("custom error message");
   *     expect.fail(1, 2);
   *     expect.fail(1, 2, "custom error message");
   *     expect.fail(1, 2, "custom error message", ">");
   *     expect.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace BDD
   * @api public
   */chai.expect.fail=function(actual,expected,message,operator){if(arguments.length<2){message=actual;actual=undefined;}message=message||'expect.fail()';throw new chai.AssertionError(message,{actual:actual,expected:expected,operator:operator},chai.expect.fail);};};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var should=function(chai,util){var Assertion=chai.Assertion;function loadShould(){// explicitly define this method as function as to have it's name to include as \`ssfi\`
function shouldGetter(){if(this instanceof String||this instanceof Number||this instanceof Boolean||typeof Symbol==='function'&&this instanceof Symbol||typeof BigInt==='function'&&this instanceof BigInt){return new Assertion(this.valueOf(),null,shouldGetter);}return new Assertion(this,null,shouldGetter);}function shouldSetter(value){// See https://github.com/chaijs/chai/issues/86: this makes
// \`whatever.should = someValue\` actually set \`someValue\`, which is
// especially useful for \`global.should = require('chai').should()\`.
//
// Note that we have to use [[DefineProperty]] instead of [[Put]]
// since otherwise we would trigger this very setter!
Object.defineProperty(this,'should',{value:value,enumerable:true,configurable:true,writable:true});}// modify Object.prototype to have \`should\`
Object.defineProperty(Object.prototype,'should',{set:shouldSetter,get:shouldGetter,configurable:true});var should={};/**
     * ### .fail([message])
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     *     should.fail();
     *     should.fail("custom error message");
     *     should.fail(1, 2);
     *     should.fail(1, 2, "custom error message");
     *     should.fail(1, 2, "custom error message", ">");
     *     should.fail(1, 2, undefined, ">");
     *
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace BDD
     * @api public
     */should.fail=function(actual,expected,message,operator){if(arguments.length<2){message=actual;actual=undefined;}message=message||'should.fail()';throw new chai.AssertionError(message,{actual:actual,expected:expected,operator:operator},should.fail);};/**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (\`==\`) of \`actual\` and \`expected\`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */should.equal=function(val1,val2,msg){new Assertion(val1,msg).to.equal(val2);};/**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that \`function\` will throw an error that is an instance of
     * \`constructor\`, or alternately that it will throw an error with message
     * matching \`regexp\`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */should.Throw=function(fn,errt,errs,msg){new Assertion(fn,msg).to.Throw(errt,errs);};/**
     * ### .exist
     *
     * Asserts that the target is neither \`null\` nor \`undefined\`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */should.exist=function(val,msg){new Assertion(val,msg).to.exist;};// negation
should.not={};/**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (\`!=\`) of \`actual\` and \`expected\`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */should.not.equal=function(val1,val2,msg){new Assertion(val1,msg).to.not.equal(val2);};/**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that \`function\` will _not_ throw an error that is an instance of
     * \`constructor\`, or alternately that it will not throw an error with message
     * matching \`regexp\`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */should.not.Throw=function(fn,errt,errs,msg){new Assertion(fn,msg).to.not.Throw(errt,errs);};/**
     * ### .not.exist
     *
     * Asserts that the target is neither \`null\` nor \`undefined\`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */should.not.exist=function(val,msg){new Assertion(val,msg).to.not.exist;};should['throw']=should['Throw'];should.not['throw']=should.not['Throw'];return should;}chai.should=loadShould;chai.Should=loadShould;};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var assert$1=function(chai,util){/*!
   * Chai dependencies.
   */var Assertion=chai.Assertion,flag=util.flag;/*!
   * Module export.
   */ /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */var assert=chai.assert=function(express,errmsg){var test=new Assertion(null,null,chai.assert,true);test.assert(express,errmsg,'[ negation message unavailable ]');};/**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js \`assert\` module-compatible.
   *
   *     assert.fail();
   *     assert.fail("custom error message");
   *     assert.fail(1, 2);
   *     assert.fail(1, 2, "custom error message");
   *     assert.fail(1, 2, "custom error message", ">");
   *     assert.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */assert.fail=function(actual,expected,message,operator){if(arguments.length<2){// Comply with Node's fail([message]) interface
message=actual;actual=undefined;}message=message||'assert.fail()';throw new chai.AssertionError(message,{actual:actual,expected:expected,operator:operator},assert.fail);};/**
   * ### .isOk(object, [message])
   *
   * Asserts that \`object\` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isOk=function(val,msg){new Assertion(val,msg,assert.isOk,true).is.ok;};/**
   * ### .isNotOk(object, [message])
   *
   * Asserts that \`object\` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotOk=function(val,msg){new Assertion(val,msg,assert.isNotOk,true).is.not.ok;};/**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (\`==\`) of \`actual\` and \`expected\`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.equal=function(act,exp,msg){var test=new Assertion(act,msg,assert.equal,true);test.assert(exp==flag(test,'object'),'expected #{this} to equal #{exp}','expected #{this} to not equal #{act}',exp,act,true);};/**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (\`!=\`) of \`actual\` and \`expected\`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notEqual=function(act,exp,msg){var test=new Assertion(act,msg,assert.notEqual,true);test.assert(exp!=flag(test,'object'),'expected #{this} to not equal #{exp}','expected #{this} to equal #{act}',exp,act,true);};/**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (\`===\`) of \`actual\` and \`expected\`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.strictEqual=function(act,exp,msg){new Assertion(act,msg,assert.strictEqual,true).to.equal(exp);};/**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (\`!==\`) of \`actual\` and \`expected\`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notStrictEqual=function(act,exp,msg){new Assertion(act,msg,assert.notStrictEqual,true).to.not.equal(exp);};/**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that \`actual\` is deeply equal to \`expected\`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @alias deepStrictEqual
   * @namespace Assert
   * @api public
   */assert.deepEqual=assert.deepStrictEqual=function(act,exp,msg){new Assertion(act,msg,assert.deepEqual,true).to.eql(exp);};/**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that \`actual\` is not deeply equal to \`expected\`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notDeepEqual=function(act,exp,msg){new Assertion(act,msg,assert.notDeepEqual,true).to.not.eql(exp);};/**
  * ### .isAbove(valueToCheck, valueToBeAbove, [message])
  *
  * Asserts \`valueToCheck\` is strictly greater than (>) \`valueToBeAbove\`.
  *
  *     assert.isAbove(5, 2, '5 is strictly greater than 2');
  *
  * @name isAbove
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAbove
  * @param {String} message
  * @namespace Assert
  * @api public
  */assert.isAbove=function(val,abv,msg){new Assertion(val,msg,assert.isAbove,true).to.be.above(abv);};/**
  * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
  *
  * Asserts \`valueToCheck\` is greater than or equal to (>=) \`valueToBeAtLeast\`.
  *
  *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
  *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
  *
  * @name isAtLeast
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtLeast
  * @param {String} message
  * @namespace Assert
  * @api public
  */assert.isAtLeast=function(val,atlst,msg){new Assertion(val,msg,assert.isAtLeast,true).to.be.least(atlst);};/**
  * ### .isBelow(valueToCheck, valueToBeBelow, [message])
  *
  * Asserts \`valueToCheck\` is strictly less than (<) \`valueToBeBelow\`.
  *
  *     assert.isBelow(3, 6, '3 is strictly less than 6');
  *
  * @name isBelow
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeBelow
  * @param {String} message
  * @namespace Assert
  * @api public
  */assert.isBelow=function(val,blw,msg){new Assertion(val,msg,assert.isBelow,true).to.be.below(blw);};/**
  * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
  *
  * Asserts \`valueToCheck\` is less than or equal to (<=) \`valueToBeAtMost\`.
  *
  *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
  *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
  *
  * @name isAtMost
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtMost
  * @param {String} message
  * @namespace Assert
  * @api public
  */assert.isAtMost=function(val,atmst,msg){new Assertion(val,msg,assert.isAtMost,true).to.be.most(atmst);};/**
   * ### .isTrue(value, [message])
   *
   * Asserts that \`value\` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isTrue=function(val,msg){new Assertion(val,msg,assert.isTrue,true).is['true'];};/**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that \`value\` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotTrue=function(val,msg){new Assertion(val,msg,assert.isNotTrue,true).to.not.equal(true);};/**
   * ### .isFalse(value, [message])
   *
   * Asserts that \`value\` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isFalse=function(val,msg){new Assertion(val,msg,assert.isFalse,true).is['false'];};/**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that \`value\` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotFalse=function(val,msg){new Assertion(val,msg,assert.isNotFalse,true).to.not.equal(false);};/**
   * ### .isNull(value, [message])
   *
   * Asserts that \`value\` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNull=function(val,msg){new Assertion(val,msg,assert.isNull,true).to.equal(null);};/**
   * ### .isNotNull(value, [message])
   *
   * Asserts that \`value\` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotNull=function(val,msg){new Assertion(val,msg,assert.isNotNull,true).to.not.equal(null);};/**
   * ### .isNaN
   *
   * Asserts that value is NaN.
   *
   *     assert.isNaN(NaN, 'NaN is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNaN=function(val,msg){new Assertion(val,msg,assert.isNaN,true).to.be.NaN;};/**
   * ### .isNotNaN
   *
   * Asserts that value is not NaN.
   *
   *     assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotNaN=function(val,msg){new Assertion(val,msg,assert.isNotNaN,true).not.to.be.NaN;};/**
   * ### .exists
   *
   * Asserts that the target is neither \`null\` nor \`undefined\`.
   *
   *     var foo = 'hi';
   *
   *     assert.exists(foo, 'foo is neither \`null\` nor \`undefined\`');
   *
   * @name exists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.exists=function(val,msg){new Assertion(val,msg,assert.exists,true).to.exist;};/**
   * ### .notExists
   *
   * Asserts that the target is either \`null\` or \`undefined\`.
   *
   *     var bar = null
   *       , baz;
   *
   *     assert.notExists(bar);
   *     assert.notExists(baz, 'baz is either null or undefined');
   *
   * @name notExists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notExists=function(val,msg){new Assertion(val,msg,assert.notExists,true).to.not.exist;};/**
   * ### .isUndefined(value, [message])
   *
   * Asserts that \`value\` is \`undefined\`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isUndefined=function(val,msg){new Assertion(val,msg,assert.isUndefined,true).to.equal(undefined);};/**
   * ### .isDefined(value, [message])
   *
   * Asserts that \`value\` is not \`undefined\`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isDefined=function(val,msg){new Assertion(val,msg,assert.isDefined,true).to.not.equal(undefined);};/**
   * ### .isFunction(value, [message])
   *
   * Asserts that \`value\` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isFunction=function(val,msg){new Assertion(val,msg,assert.isFunction,true).to.be.a('function');};/**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that \`value\` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotFunction=function(val,msg){new Assertion(val,msg,assert.isNotFunction,true).to.not.be.a('function');};/**
   * ### .isObject(value, [message])
   *
   * Asserts that \`value\` is an object of type 'Object' (as revealed by \`Object.prototype.toString\`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isObject=function(val,msg){new Assertion(val,msg,assert.isObject,true).to.be.a('object');};/**
   * ### .isNotObject(value, [message])
   *
   * Asserts that \`value\` is _not_ an object of type 'Object' (as revealed by \`Object.prototype.toString\`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotObject=function(val,msg){new Assertion(val,msg,assert.isNotObject,true).to.not.be.a('object');};/**
   * ### .isArray(value, [message])
   *
   * Asserts that \`value\` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isArray=function(val,msg){new Assertion(val,msg,assert.isArray,true).to.be.an('array');};/**
   * ### .isNotArray(value, [message])
   *
   * Asserts that \`value\` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotArray=function(val,msg){new Assertion(val,msg,assert.isNotArray,true).to.not.be.an('array');};/**
   * ### .isString(value, [message])
   *
   * Asserts that \`value\` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isString=function(val,msg){new Assertion(val,msg,assert.isString,true).to.be.a('string');};/**
   * ### .isNotString(value, [message])
   *
   * Asserts that \`value\` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotString=function(val,msg){new Assertion(val,msg,assert.isNotString,true).to.not.be.a('string');};/**
   * ### .isNumber(value, [message])
   *
   * Asserts that \`value\` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNumber=function(val,msg){new Assertion(val,msg,assert.isNumber,true).to.be.a('number');};/**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that \`value\` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotNumber=function(val,msg){new Assertion(val,msg,assert.isNotNumber,true).to.not.be.a('number');};/**
  * ### .isFinite(value, [message])
  *
  * Asserts that \`value\` is a finite number. Unlike \`.isNumber\`, this will fail for \`NaN\` and \`Infinity\`.
  *
  *     var cups = 2;
  *     assert.isFinite(cups, 'how many cups');
  *
  *     assert.isFinite(NaN); // throws
  *
  * @name isFinite
  * @param {Number} value
  * @param {String} message
  * @namespace Assert
  * @api public
  */assert.isFinite=function(val,msg){new Assertion(val,msg,assert.isFinite,true).to.be.finite;};/**
   * ### .isBoolean(value, [message])
   *
   * Asserts that \`value\` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isBoolean=function(val,msg){new Assertion(val,msg,assert.isBoolean,true).to.be.a('boolean');};/**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that \`value\` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotBoolean=function(val,msg){new Assertion(val,msg,assert.isNotBoolean,true).to.not.be.a('boolean');};/**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that \`value\`'s type is \`name\`, as determined by
   * \`Object.prototype.toString\`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.typeOf=function(val,type,msg){new Assertion(val,msg,assert.typeOf,true).to.be.a(type);};/**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that \`value\`'s type is _not_ \`name\`, as determined by
   * \`Object.prototype.toString\`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notTypeOf=function(val,type,msg){new Assertion(val,msg,assert.notTypeOf,true).to.not.be.a(type);};/**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that \`value\` is an instance of \`constructor\`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.instanceOf=function(val,type,msg){new Assertion(val,msg,assert.instanceOf,true).to.be.instanceOf(type);};/**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts \`value\` is not an instance of \`constructor\`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notInstanceOf=function(val,type,msg){new Assertion(val,msg,assert.notInstanceOf,true).to.not.be.instanceOf(type);};/**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that \`haystack\` includes \`needle\`. Can be used to assert the
   * inclusion of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.include([1,2,3], 2, 'array contains value');
   *     assert.include('foobar', 'foo', 'string contains substring');
   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');
   *
   * Strict equality (===) is used. When asserting the inclusion of a value in
   * an array, the array is searched for an element that's strictly equal to the
   * given value. When asserting a subset of properties in an object, the object
   * is searched for the given property keys, checking that each one is present
   * and strictly equal to the given property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.include([obj1, obj2], obj1);
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.include=function(exp,inc,msg){new Assertion(exp,msg,assert.include,true).include(inc);};/**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that \`haystack\` does not include \`needle\`. Can be used to assert
   * the absence of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.notInclude([1,2,3], 4, "array doesn't contain value");
   *     assert.notInclude('foobar', 'baz', "string doesn't contain substring");
   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');
   *
   * Strict equality (===) is used. When asserting the absence of a value in an
   * array, the array is searched to confirm the absence of an element that's
   * strictly equal to the given value. When asserting a subset of properties in
   * an object, the object is searched to confirm that at least one of the given
   * property keys is either not present or not strictly equal to the given
   * property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notInclude([obj1, obj2], {a: 1});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.notInclude,true).not.include(inc);};/**
   * ### .deepInclude(haystack, needle, [message])
   *
   * Asserts that \`haystack\` includes \`needle\`. Can be used to assert the
   * inclusion of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.deepInclude([obj1, obj2], {a: 1});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
   *
   * @name deepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.deepInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.deepInclude,true).deep.include(inc);};/**
   * ### .notDeepInclude(haystack, needle, [message])
   *
   * Asserts that \`haystack\` does not include \`needle\`. Can be used to assert
   * the absence of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notDeepInclude([obj1, obj2], {a: 9});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
   *
   * @name notDeepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notDeepInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.notDeepInclude,true).not.deep.include(inc);};/**
   * ### .nestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.[b]': 'x'});
   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'x'});
   *
   * @name nestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.nestedInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.nestedInclude,true).nested.include(inc);};/**
   * ### .notNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.b': 'y'});
   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'y'});
   *
   * @name notNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notNestedInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.notNestedInclude,true).not.nested.include(inc);};/**
   * ### .deepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {x: 1}});
   *
   * @name deepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.deepNestedInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.deepNestedInclude,true).deep.nested.include(inc);};/**
   * ### .notDeepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {y: 2}});
   *
   * @name notDeepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notDeepNestedInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.notDeepNestedInclude,true).not.deep.nested.include(inc);};/**
   * ### .ownInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     assert.ownInclude({ a: 1 }, { a: 1 });
   *
   * @name ownInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.ownInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.ownInclude,true).own.include(inc);};/**
   * ### .notOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     assert.notOwnInclude({ a: 1 }, { b: 2 });
   *
   * @name notOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notOwnInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.notOwnInclude,true).not.own.include(inc);};/**
   * ### .deepOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties and checking for deep equality.
   *
   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
   *
   * @name deepOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.deepOwnInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.deepOwnInclude,true).deep.own.include(inc);};/**
  * ### .notDeepOwnInclude(haystack, needle, [message])
  *
  * Asserts that 'haystack' includes 'needle'.
  * Can be used to assert the absence of a subset of properties in an
  * object while ignoring inherited properties and checking for deep equality.
  *
  *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
  *
  * @name notDeepOwnInclude
  * @param {Object} haystack
  * @param {Object} needle
  * @param {String} message
  * @namespace Assert
  * @api public
  */assert.notDeepOwnInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.notDeepOwnInclude,true).not.deep.own.include(inc);};/**
   * ### .match(value, regexp, [message])
   *
   * Asserts that \`value\` matches the regular expression \`regexp\`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.match=function(exp,re,msg){new Assertion(exp,msg,assert.match,true).to.match(re);};/**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that \`value\` does not match the regular expression \`regexp\`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notMatch=function(exp,re,msg){new Assertion(exp,msg,assert.notMatch,true).to.not.match(re);};/**
   * ### .property(object, property, [message])
   *
   * Asserts that \`object\` has a direct or inherited property named by
   * \`property\`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *     assert.property({ tea: { green: 'matcha' }}, 'toString');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.property=function(obj,prop,msg){new Assertion(obj,msg,assert.property,true).to.have.property(prop);};/**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that \`object\` does _not_ have a direct or inherited property named
   * by \`property\`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notProperty=function(obj,prop,msg){new Assertion(obj,msg,assert.notProperty,true).to.not.have.property(prop);};/**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` has a direct or inherited property named by
   * \`property\` with a value given by \`value\`. Uses a strict equality check
   * (===).
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.propertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.propertyVal,true).to.have.property(prop,val);};/**
   * ### .notPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` does _not_ have a direct or inherited property named
   * by \`property\` with value given by \`value\`. Uses a strict equality check
   * (===).
   *
   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
   *
   * @name notPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.notPropertyVal,true).to.not.have.property(prop,val);};/**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` has a direct or inherited property named by
   * \`property\` with a value given by \`value\`. Uses a deep equality check.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.deepPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.deepPropertyVal,true).to.have.deep.property(prop,val);};/**
   * ### .notDeepPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` does _not_ have a direct or inherited property named
   * by \`property\` with value given by \`value\`. Uses a deep equality check.
   *
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *
   * @name notDeepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notDeepPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.notDeepPropertyVal,true).to.not.have.deep.property(prop,val);};/**
   * ### .ownProperty(object, property, [message])
   *
   * Asserts that \`object\` has a direct property named by \`property\`. Inherited
   * properties aren't checked.
   *
   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name ownProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */assert.ownProperty=function(obj,prop,msg){new Assertion(obj,msg,assert.ownProperty,true).to.have.own.property(prop);};/**
   * ### .notOwnProperty(object, property, [message])
   *
   * Asserts that \`object\` does _not_ have a direct property named by
   * \`property\`. Inherited properties aren't checked.
   *
   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');
   *     assert.notOwnProperty({}, 'toString');
   *
   * @name notOwnProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */assert.notOwnProperty=function(obj,prop,msg){new Assertion(obj,msg,assert.notOwnProperty,true).to.not.have.own.property(prop);};/**
   * ### .ownPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` has a direct property named by \`property\` and a value
   * equal to the provided \`value\`. Uses a strict equality check (===).
   * Inherited properties aren't checked.
   *
   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');
   *
   * @name ownPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */assert.ownPropertyVal=function(obj,prop,value,msg){new Assertion(obj,msg,assert.ownPropertyVal,true).to.have.own.property(prop,value);};/**
   * ### .notOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` does _not_ have a direct property named by \`property\`
   * with a value equal to the provided \`value\`. Uses a strict equality check
   * (===). Inherited properties aren't checked.
   *
   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');
   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */assert.notOwnPropertyVal=function(obj,prop,value,msg){new Assertion(obj,msg,assert.notOwnPropertyVal,true).to.not.have.own.property(prop,value);};/**
   * ### .deepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` has a direct property named by \`property\` and a value
   * equal to the provided \`value\`. Uses a deep equality check. Inherited
   * properties aren't checked.
   *
   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */assert.deepOwnPropertyVal=function(obj,prop,value,msg){new Assertion(obj,msg,assert.deepOwnPropertyVal,true).to.have.deep.own.property(prop,value);};/**
   * ### .notDeepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` does _not_ have a direct property named by \`property\`
   * with a value equal to the provided \`value\`. Uses a deep equality check.
   * Inherited properties aren't checked.
   *
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notDeepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */assert.notDeepOwnPropertyVal=function(obj,prop,value,msg){new Assertion(obj,msg,assert.notDeepOwnPropertyVal,true).to.not.have.deep.own.property(prop,value);};/**
   * ### .nestedProperty(object, property, [message])
   *
   * Asserts that \`object\` has a direct or inherited property named by
   * \`property\`, which can be a string using dot- and bracket-notation for
   * nested reference.
   *
   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name nestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.nestedProperty=function(obj,prop,msg){new Assertion(obj,msg,assert.nestedProperty,true).to.have.nested.property(prop);};/**
   * ### .notNestedProperty(object, property, [message])
   *
   * Asserts that \`object\` does _not_ have a property named by \`property\`, which
   * can be a string using dot- and bracket-notation for nested reference. The
   * property cannot exist on the object nor anywhere in its prototype chain.
   *
   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notNestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notNestedProperty=function(obj,prop,msg){new Assertion(obj,msg,assert.notNestedProperty,true).to.not.have.nested.property(prop);};/**
   * ### .nestedPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` has a property named by \`property\` with value given
   * by \`value\`. \`property\` can use dot- and bracket-notation for nested
   * reference. Uses a strict equality check (===).
   *
   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name nestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.nestedPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.nestedPropertyVal,true).to.have.nested.property(prop,val);};/**
   * ### .notNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` does _not_ have a property named by \`property\` with
   * value given by \`value\`. \`property\` can use dot- and bracket-notation for
   * nested reference. Uses a strict equality check (===).
   *
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
   *
   * @name notNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notNestedPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.notNestedPropertyVal,true).to.not.have.nested.property(prop,val);};/**
   * ### .deepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` has a property named by \`property\` with a value given
   * by \`value\`. \`property\` can use dot- and bracket-notation for nested
   * reference. Uses a deep equality check.
   *
   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
   *
   * @name deepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.deepNestedPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.deepNestedPropertyVal,true).to.have.deep.nested.property(prop,val);};/**
   * ### .notDeepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` does _not_ have a property named by \`property\` with
   * value given by \`value\`. \`property\` can use dot- and bracket-notation for
   * nested reference. Uses a deep equality check.
   *
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
   *
   * @name notDeepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notDeepNestedPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.notDeepNestedPropertyVal,true).to.not.have.deep.nested.property(prop,val);};/**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that \`object\` has a \`length\` or \`size\` with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *     assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');
   *     assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.lengthOf=function(exp,len,msg){new Assertion(exp,msg,assert.lengthOf,true).to.have.lengthOf(len);};/**
   * ### .hasAnyKeys(object, [keys], [message])
   *
   * Asserts that \`object\` has at least one of the \`keys\` provided.
   * You can also provide a single object instead of a \`keys\` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});
   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAnyKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.hasAnyKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.hasAnyKeys,true).to.have.any.keys(keys);};/**
   * ### .hasAllKeys(object, [keys], [message])
   *
   * Asserts that \`object\` has all and only all of the \`keys\` provided.
   * You can also provide a single object instead of a \`keys\` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.hasAllKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.hasAllKeys,true).to.have.all.keys(keys);};/**
   * ### .containsAllKeys(object, [keys], [message])
   *
   * Asserts that \`object\` has all of the \`keys\` provided but may have more keys not listed.
   * You can also provide a single object instead of a \`keys\` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name containsAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.containsAllKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.containsAllKeys,true).to.contain.all.keys(keys);};/**
   * ### .doesNotHaveAnyKeys(object, [keys], [message])
   *
   * Asserts that \`object\` has none of the \`keys\` provided.
   * You can also provide a single object instead of a \`keys\` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAnyKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.doesNotHaveAnyKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.doesNotHaveAnyKeys,true).to.not.have.any.keys(keys);};/**
   * ### .doesNotHaveAllKeys(object, [keys], [message])
   *
   * Asserts that \`object\` does not have at least one of the \`keys\` provided.
   * You can also provide a single object instead of a \`keys\` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.doesNotHaveAllKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.doesNotHaveAllKeys,true).to.not.have.all.keys(keys);};/**
   * ### .hasAnyDeepKeys(object, [keys], [message])
   *
   * Asserts that \`object\` has at least one of the \`keys\` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a \`keys\` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name hasAnyDeepKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.hasAnyDeepKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.hasAnyDeepKeys,true).to.have.any.deep.keys(keys);};/**
    * ### .hasAllDeepKeys(object, [keys], [message])
    *
    * Asserts that \`object\` has all and only all of the \`keys\` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a \`keys\` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name hasAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */assert.hasAllDeepKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.hasAllDeepKeys,true).to.have.all.deep.keys(keys);};/**
    * ### .containsAllDeepKeys(object, [keys], [message])
    *
    * Asserts that \`object\` contains all of the \`keys\` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a \`keys\` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name containsAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */assert.containsAllDeepKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.containsAllDeepKeys,true).to.contain.all.deep.keys(keys);};/**
    * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])
    *
    * Asserts that \`object\` has none of the \`keys\` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a \`keys\` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAnyDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */assert.doesNotHaveAnyDeepKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.doesNotHaveAnyDeepKeys,true).to.not.have.any.deep.keys(keys);};/**
    * ### .doesNotHaveAllDeepKeys(object, [keys], [message])
    *
    * Asserts that \`object\` does not have at least one of the \`keys\` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a \`keys\` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */assert.doesNotHaveAllDeepKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.doesNotHaveAllDeepKeys,true).to.not.have.all.deep.keys(keys);};/**
    * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])
    *
    * If \`errorLike\` is an \`Error\` constructor, asserts that \`fn\` will throw an error that is an
    * instance of \`errorLike\`.
    * If \`errorLike\` is an \`Error\` instance, asserts that the error thrown is the same
    * instance as \`errorLike\`.
    * If \`errMsgMatcher\` is provided, it also asserts that the error thrown will have a
    * message matching \`errMsgMatcher\`.
    *
    *     assert.throws(fn, 'Error thrown must have this msg');
    *     assert.throws(fn, /Error thrown must have a msg that matches this/);
    *     assert.throws(fn, ReferenceError);
    *     assert.throws(fn, errorInstance);
    *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
    *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
    *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
    *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
    *
    * @name throws
    * @alias throw
    * @alias Throw
    * @param {Function} fn
    * @param {ErrorConstructor|Error} errorLike
    * @param {RegExp|String} errMsgMatcher
    * @param {String} message
    * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
    * @namespace Assert
    * @api public
    */assert.throws=function(fn,errorLike,errMsgMatcher,msg){if('string'===typeof errorLike||errorLike instanceof RegExp){errMsgMatcher=errorLike;errorLike=null;}var assertErr=new Assertion(fn,msg,assert.throws,true).to.throw(errorLike,errMsgMatcher);return flag(assertErr,'object');};/**
   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])
   *
   * If \`errorLike\` is an \`Error\` constructor, asserts that \`fn\` will _not_ throw an error that is an
   * instance of \`errorLike\`.
   * If \`errorLike\` is an \`Error\` instance, asserts that the error thrown is _not_ the same
   * instance as \`errorLike\`.
   * If \`errMsgMatcher\` is provided, it also asserts that the error thrown will _not_ have a
   * message matching \`errMsgMatcher\`.
   *
   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);
   *     assert.doesNotThrow(fn, Error);
   *     assert.doesNotThrow(fn, errorInstance);
   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');
   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
   *     assert.doesNotThrow(fn, Error, /Error must not match this/);
   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
   *
   * @name doesNotThrow
   * @param {Function} fn
   * @param {ErrorConstructor} errorLike
   * @param {RegExp|String} errMsgMatcher
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */assert.doesNotThrow=function(fn,errorLike,errMsgMatcher,msg){if('string'===typeof errorLike||errorLike instanceof RegExp){errMsgMatcher=errorLike;errorLike=null;}new Assertion(fn,msg,assert.doesNotThrow,true).to.not.throw(errorLike,errMsgMatcher);};/**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using \`operator\`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.operator=function(val,operator,val2,msg){var ok;switch(operator){case'==':ok=val==val2;break;case'===':ok=val===val2;break;case'>':ok=val>val2;break;case'>=':ok=val>=val2;break;case'<':ok=val<val2;break;case'<=':ok=val<=val2;break;case'!=':ok=val!=val2;break;case'!==':ok=val!==val2;break;default:msg=msg?msg+': ':msg;throw new chai.AssertionError(msg+'Invalid operator "'+operator+'"',undefined,assert.operator);}var test=new Assertion(ok,msg,assert.operator,true);test.assert(true===flag(test,'object'),'expected '+util.inspect(val)+' to be '+operator+' '+util.inspect(val2),'expected '+util.inspect(val)+' to not be '+operator+' '+util.inspect(val2));};/**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal \`expected\`, to within a +/- \`delta\` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.closeTo=function(act,exp,delta,msg){new Assertion(act,msg,assert.closeTo,true).to.be.closeTo(exp,delta);};/**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal \`expected\`, to within a +/- \`delta\` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.approximately=function(act,exp,delta,msg){new Assertion(act,msg,assert.approximately,true).to.be.approximately(exp,delta);};/**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` have the same members in any order. Uses a
   * strict equality check (===).
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.sameMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.sameMembers,true).to.have.same.members(set2);};/**
   * ### .notSameMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` don't have the same members in any order.
   * Uses a strict equality check (===).
   *
   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
   *
   * @name notSameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notSameMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.notSameMembers,true).to.not.have.same.members(set2);};/**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` have the same members in any order. Uses a
   * deep equality check.
   *
   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.sameDeepMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.sameDeepMembers,true).to.have.same.deep.members(set2);};/**
   * ### .notSameDeepMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` don't have the same members in any order.
   * Uses a deep equality check.
   *
   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
   *
   * @name notSameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notSameDeepMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.notSameDeepMembers,true).to.not.have.same.deep.members(set2);};/**
   * ### .sameOrderedMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` have the same members in the same order.
   * Uses a strict equality check (===).
   *
   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
   *
   * @name sameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.sameOrderedMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.sameOrderedMembers,true).to.have.same.ordered.members(set2);};/**
   * ### .notSameOrderedMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` don't have the same members in the same
   * order. Uses a strict equality check (===).
   *
   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
   *
   * @name notSameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notSameOrderedMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.notSameOrderedMembers,true).to.not.have.same.ordered.members(set2);};/**
   * ### .sameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` have the same members in the same order.
   * Uses a deep equality check.
   *
   *     assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
   *
   * @name sameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.sameDeepOrderedMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.sameDeepOrderedMembers,true).to.have.same.deep.ordered.members(set2);};/**
   * ### .notSameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` don't have the same members in the same
   * order. Uses a deep equality check.
   *
   *     assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
   *     assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
   *
   * @name notSameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notSameDeepOrderedMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.notSameDeepOrderedMembers,true).to.not.have.same.deep.ordered.members(set2);};/**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` is included in \`superset\` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.includeMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.includeMembers,true).to.include.members(subset);};/**
   * ### .notIncludeMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` isn't included in \`superset\` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
   *
   * @name notIncludeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notIncludeMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.notIncludeMembers,true).to.not.include.members(subset);};/**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` is included in \`superset\` in any order. Uses a deep
   * equality check. Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.includeDeepMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.includeDeepMembers,true).to.include.deep.members(subset);};/**
   * ### .notIncludeDeepMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` isn't included in \`superset\` in any order. Uses a
   * deep equality check. Duplicates are ignored.
   *
   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
   *
   * @name notIncludeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notIncludeDeepMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.notIncludeDeepMembers,true).to.not.include.deep.members(subset);};/**
   * ### .includeOrderedMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` is included in \`superset\` in the same order
   * beginning with the first element in \`superset\`. Uses a strict equality
   * check (===).
   *
   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
   *
   * @name includeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.includeOrderedMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.includeOrderedMembers,true).to.include.ordered.members(subset);};/**
   * ### .notIncludeOrderedMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` isn't included in \`superset\` in the same order
   * beginning with the first element in \`superset\`. Uses a strict equality
   * check (===).
   *
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
   *
   * @name notIncludeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notIncludeOrderedMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.notIncludeOrderedMembers,true).to.not.include.ordered.members(subset);};/**
   * ### .includeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` is included in \`superset\` in the same order
   * beginning with the first element in \`superset\`. Uses a deep equality
   * check.
   *
   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
   *
   * @name includeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.includeDeepOrderedMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.includeDeepOrderedMembers,true).to.include.deep.ordered.members(subset);};/**
   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` isn't included in \`superset\` in the same order
   * beginning with the first element in \`superset\`. Uses a deep equality
   * check.
   *
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
   *
   * @name notIncludeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notIncludeDeepOrderedMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.notIncludeDeepOrderedMembers,true).to.not.include.deep.ordered.members(subset);};/**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value \`inList\` appears in the flat array \`list\`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.oneOf=function(inList,list,msg){new Assertion(inList,msg,assert.oneOf,true).to.be.oneOf(list);};/**
   * ### .changes(function, object, property, [message])
   *
   * Asserts that a function changes the value of a property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.changes=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==='function'){msg=prop;prop=null;}new Assertion(fn,msg,assert.changes,true).to.change(obj,prop);};/**
  * ### .changesBy(function, object, property, delta, [message])
  *
  * Asserts that a function changes the value of a property by an amount (delta).
  *
  *     var obj = { val: 10 };
  *     var fn = function() { obj.val += 2 };
  *     assert.changesBy(fn, obj, 'val', 2);
  *
  * @name changesBy
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {Number} change amount (delta)
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */assert.changesBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}new Assertion(fn,msg,assert.changesBy,true).to.change(obj,prop).by(delta);};/**
  * ### .doesNotChange(function, object, property, [message])
  *
  * Asserts that a function does not change the value of a property.
  *
  *     var obj = { val: 10 };
  *     var fn = function() { console.log('foo'); };
  *     assert.doesNotChange(fn, obj, 'val');
  *
  * @name doesNotChange
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */assert.doesNotChange=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==='function'){msg=prop;prop=null;}return new Assertion(fn,msg,assert.doesNotChange,true).to.not.change(obj,prop);};/**
   * ### .changesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.changesButNotBy(fn, obj, 'val', 5);
   *
   * @name changesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.changesButNotBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}new Assertion(fn,msg,assert.changesButNotBy,true).to.change(obj,prop).but.not.by(delta);};/**
   * ### .increases(function, object, property, [message])
   *
   * Asserts that a function increases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.increases=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==='function'){msg=prop;prop=null;}return new Assertion(fn,msg,assert.increases,true).to.increase(obj,prop);};/**
   * ### .increasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.increasesBy(fn, obj, 'val', 10);
   *
   * @name increasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.increasesBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}new Assertion(fn,msg,assert.increasesBy,true).to.increase(obj,prop).by(delta);};/**
   * ### .doesNotIncrease(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.doesNotIncrease=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==='function'){msg=prop;prop=null;}return new Assertion(fn,msg,assert.doesNotIncrease,true).to.not.increase(obj,prop);};/**
   * ### .increasesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.increasesButNotBy(fn, obj, 'val', 10);
   *
   * @name increasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.increasesButNotBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}new Assertion(fn,msg,assert.increasesButNotBy,true).to.increase(obj,prop).but.not.by(delta);};/**
   * ### .decreases(function, object, property, [message])
   *
   * Asserts that a function decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.decreases=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==='function'){msg=prop;prop=null;}return new Assertion(fn,msg,assert.decreases,true).to.decrease(obj,prop);};/**
   * ### .decreasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val -= 5 };
   *     assert.decreasesBy(fn, obj, 'val', 5);
   *
   * @name decreasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.decreasesBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}new Assertion(fn,msg,assert.decreasesBy,true).to.decrease(obj,prop).by(delta);};/**
   * ### .doesNotDecrease(function, object, property, [message])
   *
   * Asserts that a function does not decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.doesNotDecrease=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==='function'){msg=prop;prop=null;}return new Assertion(fn,msg,assert.doesNotDecrease,true).to.not.decrease(obj,prop);};/**
   * ### .doesNotDecreaseBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);
   *
   * @name doesNotDecreaseBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.doesNotDecreaseBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}return new Assertion(fn,msg,assert.doesNotDecreaseBy,true).to.not.decrease(obj,prop).by(delta);};/**
   * ### .decreasesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreasesButNotBy(fn, obj, 'val', 1);
   *
   * @name decreasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.decreasesButNotBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}new Assertion(fn,msg,assert.decreasesButNotBy,true).to.decrease(obj,prop).but.not.by(delta);};/*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */assert.ifError=function(val){if(val){throw val;}};/**
   * ### .isExtensible(object)
   *
   * Asserts that \`object\` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isExtensible=function(obj,msg){new Assertion(obj,msg,assert.isExtensible,true).to.be.extensible;};/**
   * ### .isNotExtensible(object)
   *
   * Asserts that \`object\` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isNotExtensible=function(obj,msg){new Assertion(obj,msg,assert.isNotExtensible,true).to.not.be.extensible;};/**
   * ### .isSealed(object)
   *
   * Asserts that \`object\` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isSealed=function(obj,msg){new Assertion(obj,msg,assert.isSealed,true).to.be.sealed;};/**
   * ### .isNotSealed(object)
   *
   * Asserts that \`object\` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isNotSealed=function(obj,msg){new Assertion(obj,msg,assert.isNotSealed,true).to.not.be.sealed;};/**
   * ### .isFrozen(object)
   *
   * Asserts that \`object\` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isFrozen=function(obj,msg){new Assertion(obj,msg,assert.isFrozen,true).to.be.frozen;};/**
   * ### .isNotFrozen(object)
   *
   * Asserts that \`object\` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isNotFrozen=function(obj,msg){new Assertion(obj,msg,assert.isNotFrozen,true).to.not.be.frozen;};/**
   * ### .isEmpty(target)
   *
   * Asserts that the target does not contain any values.
   * For arrays and strings, it checks the \`length\` property.
   * For \`Map\` and \`Set\` instances, it checks the \`size\` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isEmpty([]);
   *     assert.isEmpty('');
   *     assert.isEmpty(new Map);
   *     assert.isEmpty({});
   *
   * @name isEmpty
   * @alias empty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isEmpty=function(val,msg){new Assertion(val,msg,assert.isEmpty,true).to.be.empty;};/**
   * ### .isNotEmpty(target)
   *
   * Asserts that the target contains values.
   * For arrays and strings, it checks the \`length\` property.
   * For \`Map\` and \`Set\` instances, it checks the \`size\` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isNotEmpty([1, 2]);
   *     assert.isNotEmpty('34');
   *     assert.isNotEmpty(new Set([5, 6]));
   *     assert.isNotEmpty({ key: 7 });
   *
   * @name isNotEmpty
   * @alias notEmpty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isNotEmpty=function(val,msg){new Assertion(val,msg,assert.isNotEmpty,true).to.not.be.empty;};/*!
   * Aliases.
   */(function alias(name,as){assert[as]=assert[name];return alias;})('isOk','ok')('isNotOk','notOk')('throws','throw')('throws','Throw')('isExtensible','extensible')('isNotExtensible','notExtensible')('isSealed','sealed')('isNotSealed','notSealed')('isFrozen','frozen')('isNotFrozen','notFrozen')('isEmpty','empty')('isNotEmpty','notEmpty');};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var hasRequiredChai;function requireChai(){if(hasRequiredChai)return chai$3;hasRequiredChai=1;(function(exports){var used=[];/*!
     * Chai version
     */exports.version='4.3.8';/*!
     * Assertion Error
     */exports.AssertionError=assertionError;/*!
     * Utils for plugins (not exported)
     */var util=requireUtils();/**
     * # .use(function)
     *
     * Provides a way to extend the internals of Chai.
     *
     * @param {Function}
     * @returns {this} for chaining
     * @api public
     */exports.use=function(fn){if(!~used.indexOf(fn)){fn(exports,util);used.push(fn);}return exports;};/*!
     * Utility Functions
     */exports.util=util;/*!
     * Configuration
     */var config=config$5;exports.config=config;/*!
     * Primary \`Assertion\` prototype
     */var assertion$1=assertion;exports.use(assertion$1);/*!
     * Core Assertions
     */var core=assertions;exports.use(core);/*!
     * Expect interface
     */var expect=expect$1;exports.use(expect);/*!
     * Should interface
     */var should$1=should;exports.use(should$1);/*!
     * Assert interface
     */var assert=assert$1;exports.use(assert);})(chai$3);return chai$3;}var chai$1=requireChai();const chai$2=/*@__PURE__*/getDefaultExportFromCjs$2(chai$1);const expect=chai$2.expect;chai$2.version;chai$2.Assertion;chai$2.AssertionError;const util=chai$2.util;chai$2.config;const use=chai$2.use;chai$2.should;const assert=chai$2.assert;chai$2.core;var commonjsGlobal=typeof globalThis!=='undefined'?globalThis:typeof window!=='undefined'?window:typeof global!=='undefined'?global:typeof self!=='undefined'?self:{};function getDefaultExportFromCjs$1(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,'default')?x['default']:x;}// src/utils.ts
function R(e,t){if(!e)throw new Error(t);}function u(e,t){return typeof t===e;}function b(e){return e instanceof Promise;}function f(e,t,n){Object.defineProperty(e,t,n);}function i(e,t,n){Object.defineProperty(e,t,{value:n});}// src/constants.ts
var c=Symbol.for("tinyspy:spy");// src/internal.ts
var g=/* @__PURE__ */new Set(),C=e=>{e.called=!1,e.callCount=0,e.calls=[],e.results=[],e.next=[];},M=e=>(f(e,c,{value:{reset:()=>C(e[c])}}),e[c]),A=e=>e[c]||M(e);function I(e){R(u("function",e)||u("undefined",e),"cannot spy on a non-function value");let t=function(...s){let r=A(t);r.called=!0,r.callCount++,r.calls.push(s);let m=r.next.shift();if(m){r.results.push(m);let _m=_slicedToArray(m,2),l=_m[0],o=_m[1];if(l==="ok")return o;throw o;}let p,d="ok";if(r.impl)try{new.target?p=Reflect.construct(r.impl,s,new.target):p=r.impl.apply(this,s),d="ok";}catch(l){throw p=l,d="error",r.results.push([d,l]),l;}let a=[d,p];if(b(p)){let l=p.then(o=>a[1]=o).catch(o=>{throw a[0]="error",a[1]=o,o;});Object.assign(l,p),p=l;}return r.results.push(a),p;};i(t,"_isMockFunction",!0),i(t,"length",e?e.length:0),i(t,"name",e&&e.name||"spy");let n=A(t);return n.reset(),n.impl=e,t;}// src/spyOn.ts
var k=(e,t)=>Object.getOwnPropertyDescriptor(e,t),P=(e,t)=>{t!=null&&typeof t=="function"&&t.prototype!=null&&Object.setPrototypeOf(e.prototype,t.prototype);};function E(e,t,n){R(!u("undefined",e),"spyOn could not find an object to spy upon"),R(u("object",e)||u("function",e),"cannot spyOn on a primitive value");let _ref9=(()=>{if(!u("object",t))return[t,"value"];if("getter"in t&&"setter"in t)throw new Error("cannot spy on both getter and setter");if("getter"in t)return[t.getter,"get"];if("setter"in t)return[t.setter,"set"];throw new Error("specify getter or setter to spy on");})(),_ref10=_slicedToArray(_ref9,2),s=_ref10[0],r=_ref10[1],m=k(e,s),p=Object.getPrototypeOf(e),d=p&&k(p,s),a=m||d;R(a||s in e,\`\${String(s)} does not exist\`);let l=!1;r==="value"&&a&&!a.value&&a.get&&(r="get",l=!0,n=a.get());let o;a?o=a[r]:r!=="value"?o=()=>e[s]:o=e[s],n||(n=o);let y=I(n);r==="value"&&P(y,o);let O=h=>{let _ref11=a||{configurable:!0,writable:!0},G=_ref11.value,w=_objectWithoutProperties(_ref11,_excluded2);r!=="value"&&delete w.writable,w[r]=h,f(e,s,w);},K=()=>a?f(e,s,a):O(o),T=y[c];return i(T,"restore",K),i(T,"getOriginal",()=>l?o():o),i(T,"willCall",h=>(T.impl=h,y)),O(l?()=>(P(y,n),y):y),g.add(y),y;}const mocks=/* @__PURE__ */new Set();function isMockFunction(fn2){return typeof fn2==="function"&&"_isMockFunction"in fn2&&fn2._isMockFunction;}function spyOn(obj,method,accessType){const dictionary={get:"getter",set:"setter"};const objMethod=accessType?{[dictionary[accessType]]:method}:method;const stub=E(obj,objMethod);return enhanceSpy(stub);}let callOrder=0;function enhanceSpy(spy){const stub=spy;let implementation;let instances=[];let invocations=[];const state=A(spy);const mockContext={get calls(){return state.calls;},get instances(){return instances;},get invocationCallOrder(){return invocations;},get results(){return state.results.map(([callType,value])=>{const type=callType==="error"?"throw":"return";return{type,value};});},get lastCall(){return state.calls[state.calls.length-1];}};let onceImplementations=[];let implementationChangedTemporarily=false;function mockCall(...args){instances.push(this);invocations.push(++callOrder);const impl=implementationChangedTemporarily?implementation:onceImplementations.shift()||implementation||state.getOriginal()||(()=>{});return impl.apply(this,args);}let name=stub.name;stub.getMockName=()=>name||"vi.fn()";stub.mockName=n=>{name=n;return stub;};stub.mockClear=()=>{state.reset();instances=[];invocations=[];return stub;};stub.mockReset=()=>{stub.mockClear();implementation=()=>void 0;onceImplementations=[];return stub;};stub.mockRestore=()=>{stub.mockReset();state.restore();implementation=void 0;return stub;};stub.getMockImplementation=()=>implementation;stub.mockImplementation=fn2=>{implementation=fn2;state.willCall(mockCall);return stub;};stub.mockImplementationOnce=fn2=>{onceImplementations.push(fn2);return stub;};function withImplementation(fn2,cb){const originalImplementation=implementation;implementation=fn2;state.willCall(mockCall);implementationChangedTemporarily=true;const reset=()=>{implementation=originalImplementation;implementationChangedTemporarily=false;};const result=cb();if(result instanceof Promise){return result.then(()=>{reset();return stub;});}reset();return stub;}stub.withImplementation=withImplementation;stub.mockReturnThis=()=>stub.mockImplementation(function(){return this;});stub.mockReturnValue=val=>stub.mockImplementation(()=>val);stub.mockReturnValueOnce=val=>stub.mockImplementationOnce(()=>val);stub.mockResolvedValue=val=>stub.mockImplementation(()=>Promise.resolve(val));stub.mockResolvedValueOnce=val=>stub.mockImplementationOnce(()=>Promise.resolve(val));stub.mockRejectedValue=val=>stub.mockImplementation(()=>Promise.reject(val));stub.mockRejectedValueOnce=val=>stub.mockImplementationOnce(()=>Promise.reject(val));Object.defineProperty(stub,"mock",{get:()=>mockContext});state.willCall(mockCall);mocks.add(stub);return stub;}function fn(implementation){const enhancedSpy=enhanceSpy(E({spy:implementation||(()=>{})},"spy"));if(implementation)enhancedSpy.mockImplementation(implementation);return enhancedSpy;}const MATCHERS_OBJECT$1=Symbol.for("matchers-object");const JEST_MATCHERS_OBJECT$1=Symbol.for("$$jest-matchers-object");const GLOBAL_EXPECT$1=Symbol.for("expect-global");const ASYMMETRIC_MATCHERS_OBJECT$1=Symbol.for("asymmetric-matchers-object");if(!Object.prototype.hasOwnProperty.call(globalThis,MATCHERS_OBJECT$1)){const globalState=/* @__PURE__ */new WeakMap();const matchers=/* @__PURE__ */Object.create(null);const customEqualityTesters=[];const assymetricMatchers=/* @__PURE__ */Object.create(null);Object.defineProperty(globalThis,MATCHERS_OBJECT$1,{get:()=>globalState});Object.defineProperty(globalThis,JEST_MATCHERS_OBJECT$1,{configurable:true,get:()=>({state:globalState.get(globalThis[GLOBAL_EXPECT$1]),matchers,customEqualityTesters})});Object.defineProperty(globalThis,ASYMMETRIC_MATCHERS_OBJECT$1,{get:()=>assymetricMatchers});}function getState(expect){return globalThis[MATCHERS_OBJECT$1].get(expect);}function setState(state,expect){const map=globalThis[MATCHERS_OBJECT$1];const current=map.get(expect)||{};Object.assign(current,state);map.set(expect,current);}function getMatcherUtils(){const c=()=>getColors();const EXPECTED_COLOR=c().green;const RECEIVED_COLOR=c().red;const INVERTED_COLOR=c().inverse;const BOLD_WEIGHT=c().bold;const DIM_COLOR=c().dim;function matcherHint(matcherName,received="received",expected="expected",options={}){const _options$comment=options.comment,comment=_options$comment===void 0?"":_options$comment,_options$isDirectExpe=options.isDirectExpectCall,isDirectExpectCall=_options$isDirectExpe===void 0?false:_options$isDirectExpe,_options$isNot=options.isNot,isNot=_options$isNot===void 0?false:_options$isNot,_options$promise=options.promise,promise=_options$promise===void 0?"":_options$promise,_options$secondArgume=options.secondArgument,secondArgument=_options$secondArgume===void 0?"":_options$secondArgume,_options$expectedColo=options.expectedColor,expectedColor=_options$expectedColo===void 0?EXPECTED_COLOR:_options$expectedColo,_options$receivedColo=options.receivedColor,receivedColor=_options$receivedColo===void 0?RECEIVED_COLOR:_options$receivedColo,_options$secondArgume2=options.secondArgumentColor,secondArgumentColor=_options$secondArgume2===void 0?EXPECTED_COLOR:_options$secondArgume2;let hint="";let dimString="expect";if(!isDirectExpectCall&&received!==""){hint+=DIM_COLOR(\`\${dimString}(\`)+receivedColor(received);dimString=")";}if(promise!==""){hint+=DIM_COLOR(\`\${dimString}.\`)+promise;dimString="";}if(isNot){hint+=\`\${DIM_COLOR(\`\${dimString}.\`)}not\`;dimString="";}if(matcherName.includes(".")){dimString+=matcherName;}else{hint+=DIM_COLOR(\`\${dimString}.\`)+matcherName;dimString="";}if(expected===""){dimString+="()";}else{hint+=DIM_COLOR(\`\${dimString}(\`)+expectedColor(expected);if(secondArgument)hint+=DIM_COLOR(", ")+secondArgumentColor(secondArgument);dimString=")";}if(comment!=="")dimString+=\` // \${comment}\`;if(dimString!=="")hint+=DIM_COLOR(dimString);return hint;}const SPACE_SYMBOL="\\xB7";const replaceTrailingSpaces=text=>text.replace(/\\s+$/gm,spaces=>SPACE_SYMBOL.repeat(spaces.length));const printReceived=object=>RECEIVED_COLOR(replaceTrailingSpaces(stringify(object)));const printExpected=value=>EXPECTED_COLOR(replaceTrailingSpaces(stringify(value)));return{EXPECTED_COLOR,RECEIVED_COLOR,INVERTED_COLOR,BOLD_WEIGHT,DIM_COLOR,matcherHint,printReceived,printExpected};}function addCustomEqualityTesters(newTesters){if(!Array.isArray(newTesters)){throw new TypeError(\`expect.customEqualityTesters: Must be set to an array of Testers. Was given "\${getType$2(newTesters)}"\`);}globalThis[JEST_MATCHERS_OBJECT$1].customEqualityTesters.push(...newTesters);}function getCustomEqualityTesters(){return globalThis[JEST_MATCHERS_OBJECT$1].customEqualityTesters;}function equals(a,b,customTesters,strictCheck){customTesters=customTesters||[];return eq(a,b,[],[],customTesters,strictCheck?hasKey:hasDefinedKey);}function isAsymmetric(obj){return!!obj&&typeof obj==="object"&&"asymmetricMatch"in obj&&isA("Function",obj.asymmetricMatch);}function asymmetricMatch(a,b){const asymmetricA=isAsymmetric(a);const asymmetricB=isAsymmetric(b);if(asymmetricA&&asymmetricB)return void 0;if(asymmetricA)return a.asymmetricMatch(b);if(asymmetricB)return b.asymmetricMatch(a);}function eq(a,b,aStack,bStack,customTesters,hasKey2){let result=true;const asymmetricResult=asymmetricMatch(a,b);if(asymmetricResult!==void 0)return asymmetricResult;const testerContext={equals};for(let i=0;i<customTesters.length;i++){const customTesterResult=customTesters[i].call(testerContext,a,b,customTesters);if(customTesterResult!==void 0)return customTesterResult;}if(a instanceof Error&&b instanceof Error)return a.message===b.message;if(typeof URL==="function"&&a instanceof URL&&b instanceof URL)return a.href===b.href;if(Object.is(a,b))return true;if(a===null||b===null)return a===b;const className=Object.prototype.toString.call(a);if(className!==Object.prototype.toString.call(b))return false;switch(className){case"[object Boolean]":case"[object String]":case"[object Number]":if(typeof a!==typeof b){return false;}else if(typeof a!=="object"&&typeof b!=="object"){return Object.is(a,b);}else{return Object.is(a.valueOf(),b.valueOf());}case"[object Date]":{const numA=+a;const numB=+b;return numA===numB||Number.isNaN(numA)&&Number.isNaN(numB);}case"[object RegExp]":return a.source===b.source&&a.flags===b.flags;}if(typeof a!=="object"||typeof b!=="object")return false;if(isDomNode(a)&&isDomNode(b))return a.isEqualNode(b);let length=aStack.length;while(length--){if(aStack[length]===a)return bStack[length]===b;else if(bStack[length]===b)return false;}aStack.push(a);bStack.push(b);if(className==="[object Array]"&&a.length!==b.length)return false;const aKeys=keys(a,hasKey2);let key;let size=aKeys.length;if(keys(b,hasKey2).length!==size)return false;while(size--){key=aKeys[size];result=hasKey2(b,key)&&eq(a[key],b[key],aStack,bStack,customTesters,hasKey2);if(!result)return false;}aStack.pop();bStack.pop();return result;}function keys(obj,hasKey2){const keys2=[];for(const key in obj){if(hasKey2(obj,key))keys2.push(key);}return keys2.concat(Object.getOwnPropertySymbols(obj).filter(symbol=>Object.getOwnPropertyDescriptor(obj,symbol).enumerable));}function hasDefinedKey(obj,key){return hasKey(obj,key)&&obj[key]!==void 0;}function hasKey(obj,key){return Object.prototype.hasOwnProperty.call(obj,key);}function isA(typeName,value){return Object.prototype.toString.apply(value)===\`[object \${typeName}]\`;}function isDomNode(obj){return obj!==null&&typeof obj==="object"&&"nodeType"in obj&&typeof obj.nodeType==="number"&&"nodeName"in obj&&typeof obj.nodeName==="string"&&"isEqualNode"in obj&&typeof obj.isEqualNode==="function";}const IS_KEYED_SENTINEL="@@__IMMUTABLE_KEYED__@@";const IS_SET_SENTINEL="@@__IMMUTABLE_SET__@@";const IS_ORDERED_SENTINEL="@@__IMMUTABLE_ORDERED__@@";function isImmutableUnorderedKeyed(maybeKeyed){return!!(maybeKeyed&&maybeKeyed[IS_KEYED_SENTINEL]&&!maybeKeyed[IS_ORDERED_SENTINEL]);}function isImmutableUnorderedSet(maybeSet){return!!(maybeSet&&maybeSet[IS_SET_SENTINEL]&&!maybeSet[IS_ORDERED_SENTINEL]);}const IteratorSymbol=Symbol.iterator;function hasIterator(object){return!!(object!=null&&object[IteratorSymbol]);}function iterableEquality(a,b,customTesters=[],aStack=[],bStack=[]){if(typeof a!=="object"||typeof b!=="object"||Array.isArray(a)||Array.isArray(b)||!hasIterator(a)||!hasIterator(b))return void 0;if(a.constructor!==b.constructor)return false;let length=aStack.length;while(length--){if(aStack[length]===a)return bStack[length]===b;}aStack.push(a);bStack.push(b);const filteredCustomTesters=[...customTesters.filter(t=>t!==iterableEquality),iterableEqualityWithStack];function iterableEqualityWithStack(a2,b2){return iterableEquality(a2,b2,[...customTesters],[...aStack],[...bStack]);}if(a.size!==void 0){if(a.size!==b.size){return false;}else if(isA("Set",a)||isImmutableUnorderedSet(a)){let allFound=true;for(const aValue of a){if(!b.has(aValue)){let has=false;for(const bValue of b){const isEqual=equals(aValue,bValue,filteredCustomTesters);if(isEqual===true)has=true;}if(has===false){allFound=false;break;}}}aStack.pop();bStack.pop();return allFound;}else if(isA("Map",a)||isImmutableUnorderedKeyed(a)){let allFound=true;for(const aEntry of a){if(!b.has(aEntry[0])||!equals(aEntry[1],b.get(aEntry[0]),filteredCustomTesters)){let has=false;for(const bEntry of b){const matchedKey=equals(aEntry[0],bEntry[0],filteredCustomTesters);let matchedValue=false;if(matchedKey===true)matchedValue=equals(aEntry[1],bEntry[1],filteredCustomTesters);if(matchedValue===true)has=true;}if(has===false){allFound=false;break;}}}aStack.pop();bStack.pop();return allFound;}}const bIterator=b[IteratorSymbol]();for(const aValue of a){const nextB=bIterator.next();if(nextB.done||!equals(aValue,nextB.value,filteredCustomTesters))return false;}if(!bIterator.next().done)return false;const aEntries=Object.entries(a);const bEntries=Object.entries(b);if(!equals(aEntries,bEntries))return false;aStack.pop();bStack.pop();return true;}function hasPropertyInObject(object,key){const shouldTerminate=!object||typeof object!=="object"||object===Object.prototype;if(shouldTerminate)return false;return Object.prototype.hasOwnProperty.call(object,key)||hasPropertyInObject(Object.getPrototypeOf(object),key);}function isObjectWithKeys(a){return isObject$1(a)&&!(a instanceof Error)&&!Array.isArray(a)&&!(a instanceof Date);}function subsetEquality(object,subset,customTesters=[]){const filteredCustomTesters=customTesters.filter(t=>t!==subsetEquality);const subsetEqualityWithContext=(seenReferences=/* @__PURE__ */new WeakMap())=>(object2,subset2)=>{if(!isObjectWithKeys(subset2))return void 0;return Object.keys(subset2).every(key=>{if(subset2[key]!=null&&typeof subset2[key]==="object"){if(seenReferences.has(subset2[key]))return equals(object2[key],subset2[key],filteredCustomTesters);seenReferences.set(subset2[key],true);}const result=object2!=null&&hasPropertyInObject(object2,key)&&equals(object2[key],subset2[key],[...filteredCustomTesters,subsetEqualityWithContext(seenReferences)]);seenReferences.delete(subset2[key]);return result;});};return subsetEqualityWithContext()(object,subset);}function typeEquality(a,b){if(a==null||b==null||a.constructor===b.constructor)return void 0;return false;}function arrayBufferEquality(a,b){let dataViewA=a;let dataViewB=b;if(!(a instanceof DataView&&b instanceof DataView)){if(!(a instanceof ArrayBuffer)||!(b instanceof ArrayBuffer))return void 0;try{dataViewA=new DataView(a);dataViewB=new DataView(b);}catch{return void 0;}}if(dataViewA.byteLength!==dataViewB.byteLength)return false;for(let i=0;i<dataViewA.byteLength;i++){if(dataViewA.getUint8(i)!==dataViewB.getUint8(i))return false;}return true;}function sparseArrayEquality(a,b,customTesters=[]){if(!Array.isArray(a)||!Array.isArray(b))return void 0;const aKeys=Object.keys(a);const bKeys=Object.keys(b);const filteredCustomTesters=customTesters.filter(t=>t!==sparseArrayEquality);return equals(a,b,filteredCustomTesters,true)&&equals(aKeys,bKeys);}function generateToBeMessage(deepEqualityName,expected="#{this}",actual="#{exp}"){const toBeMessage=\`expected \${expected} to be \${actual} // Object.is equality\`;if(["toStrictEqual","toEqual"].includes(deepEqualityName))return\`\${toBeMessage}

If it should pass with deep equality, replace "toBe" with "\${deepEqualityName}"

Expected: \${expected}
Received: serializes to the same string
\`;return toBeMessage;}function pluralize(word,count){return\`\${count} \${word}\${count===1?"":"s"}\`;}function getObjectKeys(object){return[...Object.keys(object),...Object.getOwnPropertySymbols(object).filter(s=>{var _a;return(_a=Object.getOwnPropertyDescriptor(object,s))==null?void 0:_a.enumerable;})];}function getObjectSubset(object,subset,customTesters=[]){let stripped=0;const getObjectSubsetWithContext=(seenReferences=/* @__PURE__ */new WeakMap())=>(object2,subset2)=>{if(Array.isArray(object2)){if(Array.isArray(subset2)&&subset2.length===object2.length){return subset2.map((sub,i)=>getObjectSubsetWithContext(seenReferences)(object2[i],sub));}}else if(object2 instanceof Date){return object2;}else if(isObject$1(object2)&&isObject$1(subset2)){if(equals(object2,subset2,[...customTesters,iterableEquality,subsetEquality])){return subset2;}const trimmed={};seenReferences.set(object2,trimmed);for(const key of getObjectKeys(object2)){if(hasPropertyInObject(subset2,key)){trimmed[key]=seenReferences.has(object2[key])?seenReferences.get(object2[key]):getObjectSubsetWithContext(seenReferences)(object2[key],subset2[key]);}else{if(!seenReferences.has(object2[key])){stripped+=1;if(isObject$1(object2[key]))stripped+=getObjectKeys(object2[key]).length;getObjectSubsetWithContext(seenReferences)(object2[key],subset2[key]);}}}if(getObjectKeys(trimmed).length>0)return trimmed;}return object2;};return{subset:getObjectSubsetWithContext()(object,subset),stripped};}let AsymmetricMatcher$1=class AsymmetricMatcher{constructor(sample,inverse=false){this.sample=sample;this.inverse=inverse;}// should have "jest" to be compatible with its ecosystem
$$typeof=Symbol.for("jest.asymmetricMatcher");getMatcherContext(expect){return _objectSpread(_objectSpread({},getState(expect||globalThis[GLOBAL_EXPECT$1])),{},{equals,isNot:this.inverse,customTesters:getCustomEqualityTesters(),utils:_objectSpread(_objectSpread({},getMatcherUtils()),{},{diff,stringify,iterableEquality,subsetEquality})});}// implement custom chai/loupe inspect for better AssertionError.message formatting
// https://github.com/chaijs/loupe/blob/9b8a6deabcd50adc056a64fb705896194710c5c6/src/index.ts#L29
[Symbol.for("chai/inspect")](options){const result=stringify(this,options.depth,{min:true});if(result.length<=options.truncate)return result;return\`\${this.toString()}{\\u2026}\`;}};class StringContaining extends AsymmetricMatcher$1{constructor(sample,inverse=false){if(!isA("String",sample))throw new Error("Expected is not a string");super(sample,inverse);}asymmetricMatch(other){const result=isA("String",other)&&other.includes(this.sample);return this.inverse?!result:result;}toString(){return\`String\${this.inverse?"Not":""}Containing\`;}getExpectedType(){return"string";}}class Anything extends AsymmetricMatcher$1{asymmetricMatch(other){return other!=null;}toString(){return"Anything";}toAsymmetricMatcher(){return"Anything";}}class ObjectContaining extends AsymmetricMatcher$1{constructor(sample,inverse=false){super(sample,inverse);}getPrototype(obj){if(Object.getPrototypeOf)return Object.getPrototypeOf(obj);if(obj.constructor.prototype===obj)return null;return obj.constructor.prototype;}hasProperty(obj,property){if(!obj)return false;if(Object.prototype.hasOwnProperty.call(obj,property))return true;return this.hasProperty(this.getPrototype(obj),property);}asymmetricMatch(other){if(typeof this.sample!=="object"){throw new TypeError(\`You must provide an object to \${this.toString()}, not '\${typeof this.sample}'.\`);}let result=true;const matcherContext=this.getMatcherContext();for(const property in this.sample){if(!this.hasProperty(other,property)||!equals(this.sample[property],other[property],matcherContext.customTesters)){result=false;break;}}return this.inverse?!result:result;}toString(){return\`Object\${this.inverse?"Not":""}Containing\`;}getExpectedType(){return"object";}}class ArrayContaining extends AsymmetricMatcher$1{constructor(sample,inverse=false){super(sample,inverse);}asymmetricMatch(other){if(!Array.isArray(this.sample)){throw new TypeError(\`You must provide an array to \${this.toString()}, not '\${typeof this.sample}'.\`);}const matcherContext=this.getMatcherContext();const result=this.sample.length===0||Array.isArray(other)&&this.sample.every(item=>other.some(another=>equals(item,another,matcherContext.customTesters)));return this.inverse?!result:result;}toString(){return\`Array\${this.inverse?"Not":""}Containing\`;}getExpectedType(){return"array";}}class Any extends AsymmetricMatcher$1{constructor(sample){if(typeof sample==="undefined"){throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");}super(sample);}fnNameFor(func){if(func.name)return func.name;const functionToString=Function.prototype.toString;const matches=functionToString.call(func).match(/^(?:async)?\\s*function\\s*\\*?\\s*([\\w$]+)\\s*\\(/);return matches?matches[1]:"<anonymous>";}asymmetricMatch(other){if(this.sample===String)return typeof other=="string"||other instanceof String;if(this.sample===Number)return typeof other=="number"||other instanceof Number;if(this.sample===Function)return typeof other=="function"||other instanceof Function;if(this.sample===Boolean)return typeof other=="boolean"||other instanceof Boolean;if(this.sample===BigInt)return typeof other=="bigint"||other instanceof BigInt;if(this.sample===Symbol)return typeof other=="symbol"||other instanceof Symbol;if(this.sample===Object)return typeof other=="object";return other instanceof this.sample;}toString(){return"Any";}getExpectedType(){if(this.sample===String)return"string";if(this.sample===Number)return"number";if(this.sample===Function)return"function";if(this.sample===Object)return"object";if(this.sample===Boolean)return"boolean";return this.fnNameFor(this.sample);}toAsymmetricMatcher(){return\`Any<\${this.fnNameFor(this.sample)}>\`;}}class StringMatching extends AsymmetricMatcher$1{constructor(sample,inverse=false){if(!isA("String",sample)&&!isA("RegExp",sample))throw new Error("Expected is not a String or a RegExp");super(new RegExp(sample),inverse);}asymmetricMatch(other){const result=isA("String",other)&&this.sample.test(other);return this.inverse?!result:result;}toString(){return\`String\${this.inverse?"Not":""}Matching\`;}getExpectedType(){return"string";}}class CloseTo extends AsymmetricMatcher$1{precision;constructor(sample,precision=2,inverse=false){if(!isA("Number",sample))throw new Error("Expected is not a Number");if(!isA("Number",precision))throw new Error("Precision is not a Number");super(sample);this.inverse=inverse;this.precision=precision;}asymmetricMatch(other){if(!isA("Number",other))return false;let result=false;if(other===Number.POSITIVE_INFINITY&&this.sample===Number.POSITIVE_INFINITY){result=true;}else if(other===Number.NEGATIVE_INFINITY&&this.sample===Number.NEGATIVE_INFINITY){result=true;}else{result=Math.abs(this.sample-other)<10**-this.precision/2;}return this.inverse?!result:result;}toString(){return\`Number\${this.inverse?"Not":""}CloseTo\`;}getExpectedType(){return"number";}toAsymmetricMatcher(){return[this.toString(),this.sample,\`(\${pluralize("digit",this.precision)})\`].join(" ");}}const JestAsymmetricMatchers=(chai,utils)=>{utils.addMethod(chai.expect,"anything",()=>new Anything());utils.addMethod(chai.expect,"any",expected=>new Any(expected));utils.addMethod(chai.expect,"stringContaining",expected=>new StringContaining(expected));utils.addMethod(chai.expect,"objectContaining",expected=>new ObjectContaining(expected));utils.addMethod(chai.expect,"arrayContaining",expected=>new ArrayContaining(expected));utils.addMethod(chai.expect,"stringMatching",expected=>new StringMatching(expected));utils.addMethod(chai.expect,"closeTo",(expected,precision)=>new CloseTo(expected,precision));chai.expect.not={stringContaining:expected=>new StringContaining(expected,true),objectContaining:expected=>new ObjectContaining(expected,true),arrayContaining:expected=>new ArrayContaining(expected,true),stringMatching:expected=>new StringMatching(expected,true),closeTo:(expected,precision)=>new CloseTo(expected,precision,true)};};function recordAsyncExpect$1(test,promise){if(test&&promise instanceof Promise){promise=promise.finally(()=>{const index=test.promises.indexOf(promise);if(index!==-1)test.promises.splice(index,1);});if(!test.promises)test.promises=[];test.promises.push(promise);}return promise;}function wrapSoft(utils,fn){return function(...args){var _a;const test=utils.flag(this,"vitest-test");const state=(test==null?void 0:test.context._local)?test.context.expect.getState():getState(globalThis[GLOBAL_EXPECT$1]);if(!state.soft)return fn.apply(this,args);if(!test)throw new Error("expect.soft() can only be used inside a test");try{return fn.apply(this,args);}catch(err){test.result||(test.result={state:"fail"});test.result.state="fail";(_a=test.result).errors||(_a.errors=[]);test.result.errors.push(processError(err));}};}const JestChaiExpect=(chai,utils)=>{const AssertionError=chai.AssertionError;const c=()=>getColors();const customTesters=getCustomEqualityTesters();function def(name,fn){const addMethod=n=>{const softWrapper=wrapSoft(utils,fn);utils.addMethod(chai.Assertion.prototype,n,softWrapper);utils.addMethod(globalThis[JEST_MATCHERS_OBJECT$1].matchers,n,softWrapper);};if(Array.isArray(name))name.forEach(n=>addMethod(n));else addMethod(name);}["throw","throws","Throw"].forEach(m=>{utils.overwriteMethod(chai.Assertion.prototype,m,_super=>{return function(...args){const promise=utils.flag(this,"promise");const object=utils.flag(this,"object");const isNot=utils.flag(this,"negate");if(promise==="rejects"){utils.flag(this,"object",()=>{throw object;});}else if(promise==="resolves"&&typeof object!=="function"){if(!isNot){const message=utils.flag(this,"message")||"expected promise to throw an error, but it didn't";const error={showDiff:false};throw new AssertionError(message,error,utils.flag(this,"ssfi"));}else{return;}}_super.apply(this,args);};});});def("withTest",function(test){utils.flag(this,"vitest-test",test);return this;});def("toEqual",function(expected){const actual=utils.flag(this,"object");const equal=equals(actual,expected,[...customTesters,iterableEquality]);return this.assert(equal,"expected #{this} to deeply equal #{exp}","expected #{this} to not deeply equal #{exp}",expected,actual);});def("toStrictEqual",function(expected){const obj=utils.flag(this,"object");const equal=equals(obj,expected,[...customTesters,iterableEquality,typeEquality,sparseArrayEquality,arrayBufferEquality],true);return this.assert(equal,"expected #{this} to strictly equal #{exp}","expected #{this} to not strictly equal #{exp}",expected,obj);});def("toBe",function(expected){const actual=this._obj;const pass=Object.is(actual,expected);let deepEqualityName="";if(!pass){const toStrictEqualPass=equals(actual,expected,[...customTesters,iterableEquality,typeEquality,sparseArrayEquality,arrayBufferEquality],true);if(toStrictEqualPass){deepEqualityName="toStrictEqual";}else{const toEqualPass=equals(actual,expected,[...customTesters,iterableEquality]);if(toEqualPass)deepEqualityName="toEqual";}}return this.assert(pass,generateToBeMessage(deepEqualityName),"expected #{this} not to be #{exp} // Object.is equality",expected,actual);});def("toMatchObject",function(expected){const actual=this._obj;const pass=equals(actual,expected,[...customTesters,iterableEquality,subsetEquality]);const isNot=utils.flag(this,"negate");const _getObjectSubset=getObjectSubset(actual,expected),actualSubset=_getObjectSubset.subset,stripped=_getObjectSubset.stripped;if(pass&&isNot||!pass&&!isNot){const msg=utils.getMessage(this,[pass,"expected #{this} to match object #{exp}","expected #{this} to not match object #{exp}",expected,actualSubset,false]);const message=stripped===0?msg:\`\${msg}
(\${stripped} matching \${stripped===1?"property":"properties"} omitted from actual)\`;throw new AssertionError(message,{showDiff:true,expected,actual:actualSubset});}});def("toMatch",function(expected){const actual=this._obj;if(typeof actual!=="string")throw new TypeError(\`.toMatch() expects to receive a string, but got \${typeof actual}\`);return this.assert(typeof expected==="string"?actual.includes(expected):actual.match(expected),\`expected #{this} to match #{exp}\`,\`expected #{this} not to match #{exp}\`,expected,actual);});def("toContain",function(item){const actual=this._obj;if(typeof Node!=="undefined"&&actual instanceof Node){if(!(item instanceof Node))throw new TypeError(\`toContain() expected a DOM node as the argument, but got \${typeof item}\`);return this.assert(actual.contains(item),"expected #{this} to contain element #{exp}","expected #{this} not to contain element #{exp}",item,actual);}if(typeof DOMTokenList!=="undefined"&&actual instanceof DOMTokenList){assertTypes(item,"class name",["string"]);const isNot=utils.flag(this,"negate");const expectedClassList=isNot?actual.value.replace(item,"").trim():\`\${actual.value} \${item}\`;return this.assert(actual.contains(item),\`expected "\${actual.value}" to contain "\${item}"\`,\`expected "\${actual.value}" not to contain "\${item}"\`,expectedClassList,actual.value);}if(typeof actual==="string"&&typeof item==="string"){return this.assert(actual.includes(item),\`expected #{this} to contain #{exp}\`,\`expected #{this} not to contain #{exp}\`,item,actual);}if(actual!=null&&typeof actual!=="string")utils.flag(this,"object",Array.from(actual));return this.contain(item);});def("toContainEqual",function(expected){const obj=utils.flag(this,"object");const index=Array.from(obj).findIndex(item=>{return equals(item,expected,customTesters);});this.assert(index!==-1,"expected #{this} to deep equally contain #{exp}","expected #{this} to not deep equally contain #{exp}",expected);});def("toBeTruthy",function(){const obj=utils.flag(this,"object");this.assert(Boolean(obj),"expected #{this} to be truthy","expected #{this} to not be truthy",obj,false);});def("toBeFalsy",function(){const obj=utils.flag(this,"object");this.assert(!obj,"expected #{this} to be falsy","expected #{this} to not be falsy",obj,false);});def("toBeGreaterThan",function(expected){const actual=this._obj;assertTypes(actual,"actual",["number","bigint"]);assertTypes(expected,"expected",["number","bigint"]);return this.assert(actual>expected,\`expected \${actual} to be greater than \${expected}\`,\`expected \${actual} to be not greater than \${expected}\`,actual,expected,false);});def("toBeGreaterThanOrEqual",function(expected){const actual=this._obj;assertTypes(actual,"actual",["number","bigint"]);assertTypes(expected,"expected",["number","bigint"]);return this.assert(actual>=expected,\`expected \${actual} to be greater than or equal to \${expected}\`,\`expected \${actual} to be not greater than or equal to \${expected}\`,actual,expected,false);});def("toBeLessThan",function(expected){const actual=this._obj;assertTypes(actual,"actual",["number","bigint"]);assertTypes(expected,"expected",["number","bigint"]);return this.assert(actual<expected,\`expected \${actual} to be less than \${expected}\`,\`expected \${actual} to be not less than \${expected}\`,actual,expected,false);});def("toBeLessThanOrEqual",function(expected){const actual=this._obj;assertTypes(actual,"actual",["number","bigint"]);assertTypes(expected,"expected",["number","bigint"]);return this.assert(actual<=expected,\`expected \${actual} to be less than or equal to \${expected}\`,\`expected \${actual} to be not less than or equal to \${expected}\`,actual,expected,false);});def("toBeNaN",function(){return this.be.NaN;});def("toBeUndefined",function(){return this.be.undefined;});def("toBeNull",function(){return this.be.null;});def("toBeDefined",function(){const negate=utils.flag(this,"negate");utils.flag(this,"negate",false);if(negate)return this.be.undefined;return this.not.be.undefined;});def("toBeTypeOf",function(expected){const actual=typeof this._obj;const equal=expected===actual;return this.assert(equal,"expected #{this} to be type of #{exp}","expected #{this} not to be type of #{exp}",expected,actual);});def("toBeInstanceOf",function(obj){return this.instanceOf(obj);});def("toHaveLength",function(length){return this.have.length(length);});def("toHaveProperty",function(...args){if(Array.isArray(args[0]))args[0]=args[0].map(key=>String(key).replace(/([.[\\]])/g,"\\\\$1")).join(".");const actual=this._obj;const propertyName=args[0],expected=args[1];const getValue=()=>{const hasOwn=Object.prototype.hasOwnProperty.call(actual,propertyName);if(hasOwn)return{value:actual[propertyName],exists:true};return utils.getPathInfo(actual,propertyName);};const _getValue=getValue(),value=_getValue.value,exists=_getValue.exists;const pass=exists&&(args.length===1||equals(expected,value,customTesters));const valueString=args.length===1?"":\` with value \${utils.objDisplay(expected)}\`;return this.assert(pass,\`expected #{this} to have property "\${propertyName}"\${valueString}\`,\`expected #{this} to not have property "\${propertyName}"\${valueString}\`,expected,exists?value:void 0);});def("toBeCloseTo",function(received,precision=2){const expected=this._obj;let pass=false;let expectedDiff=0;let receivedDiff=0;if(received===Number.POSITIVE_INFINITY&&expected===Number.POSITIVE_INFINITY){pass=true;}else if(received===Number.NEGATIVE_INFINITY&&expected===Number.NEGATIVE_INFINITY){pass=true;}else{expectedDiff=10**-precision/2;receivedDiff=Math.abs(expected-received);pass=receivedDiff<expectedDiff;}return this.assert(pass,\`expected #{this} to be close to #{exp}, received difference is \${receivedDiff}, but expected \${expectedDiff}\`,\`expected #{this} to not be close to #{exp}, received difference is \${receivedDiff}, but expected \${expectedDiff}\`,received,expected,false);});const assertIsMock=assertion=>{if(!isMockFunction(assertion._obj))throw new TypeError(\`\${utils.inspect(assertion._obj)} is not a spy or a call to a spy!\`);};const getSpy=assertion=>{assertIsMock(assertion);return assertion._obj;};const ordinalOf=i=>{const j=i%10;const k=i%100;if(j===1&&k!==11)return\`\${i}st\`;if(j===2&&k!==12)return\`\${i}nd\`;if(j===3&&k!==13)return\`\${i}rd\`;return\`\${i}th\`;};const formatCalls=(spy,msg,actualCall)=>{if(spy.mock.calls){msg+=c().gray(\`

Received: 

\${spy.mock.calls.map((callArg,i)=>{let methodCall=c().bold(\`  \${ordinalOf(i+1)} \${spy.getMockName()} call:

\`);if(actualCall)methodCall+=diff(actualCall,callArg,{omitAnnotationLines:true});else methodCall+=stringify(callArg).split("\\n").map(line=>\`    \${line}\`).join("\\n");methodCall+="\\n";return methodCall;}).join("\\n")}\`);}msg+=c().gray(\`

Number of calls: \${c().bold(spy.mock.calls.length)}
\`);return msg;};const formatReturns=(spy,msg,actualReturn)=>{msg+=c().gray(\`

Received: 

\${spy.mock.results.map((callReturn,i)=>{let methodCall=c().bold(\`  \${ordinalOf(i+1)} \${spy.getMockName()} call return:

\`);if(actualReturn)methodCall+=diff(actualReturn,callReturn.value,{omitAnnotationLines:true});else methodCall+=stringify(callReturn).split("\\n").map(line=>\`    \${line}\`).join("\\n");methodCall+="\\n";return methodCall;}).join("\\n")}\`);msg+=c().gray(\`

Number of calls: \${c().bold(spy.mock.calls.length)}
\`);return msg;};def(["toHaveBeenCalledTimes","toBeCalledTimes"],function(number){const spy=getSpy(this);const spyName=spy.getMockName();const callCount=spy.mock.calls.length;return this.assert(callCount===number,\`expected "\${spyName}" to be called #{exp} times, but got \${callCount} times\`,\`expected "\${spyName}" to not be called #{exp} times\`,number,callCount,false);});def("toHaveBeenCalledOnce",function(){const spy=getSpy(this);const spyName=spy.getMockName();const callCount=spy.mock.calls.length;return this.assert(callCount===1,\`expected "\${spyName}" to be called once, but got \${callCount} times\`,\`expected "\${spyName}" to not be called once\`,1,callCount,false);});def(["toHaveBeenCalled","toBeCalled"],function(){const spy=getSpy(this);const spyName=spy.getMockName();const callCount=spy.mock.calls.length;const called=callCount>0;const isNot=utils.flag(this,"negate");let msg=utils.getMessage(this,[called,\`expected "\${spyName}" to be called at least once\`,\`expected "\${spyName}" to not be called at all, but actually been called \${callCount} times\`,true,called]);if(called&&isNot)msg=formatCalls(spy,msg);if(called&&isNot||!called&&!isNot)throw new AssertionError(msg);});def(["toHaveBeenCalledWith","toBeCalledWith"],function(...args){const spy=getSpy(this);const spyName=spy.getMockName();const pass=spy.mock.calls.some(callArg=>equals(callArg,args,[...customTesters,iterableEquality]));const isNot=utils.flag(this,"negate");const msg=utils.getMessage(this,[pass,\`expected "\${spyName}" to be called with arguments: #{exp}\`,\`expected "\${spyName}" to not be called with arguments: #{exp}\`,args]);if(pass&&isNot||!pass&&!isNot)throw new AssertionError(formatCalls(spy,msg,args));});def(["toHaveBeenNthCalledWith","nthCalledWith"],function(times,...args){const spy=getSpy(this);const spyName=spy.getMockName();const nthCall=spy.mock.calls[times-1];const callCount=spy.mock.calls.length;const isCalled=times<=callCount;this.assert(equals(nthCall,args,[...customTesters,iterableEquality]),\`expected \${ordinalOf(times)} "\${spyName}" call to have been called with #{exp}\${isCalled?\`\`:\`, but called only \${callCount} times\`}\`,\`expected \${ordinalOf(times)} "\${spyName}" call to not have been called with #{exp}\`,args,nthCall,isCalled);});def(["toHaveBeenLastCalledWith","lastCalledWith"],function(...args){const spy=getSpy(this);const spyName=spy.getMockName();const lastCall=spy.mock.calls[spy.mock.calls.length-1];this.assert(equals(lastCall,args,[...customTesters,iterableEquality]),\`expected last "\${spyName}" call to have been called with #{exp}\`,\`expected last "\${spyName}" call to not have been called with #{exp}\`,args,lastCall);});def(["toThrow","toThrowError"],function(expected){if(typeof expected==="string"||typeof expected==="undefined"||expected instanceof RegExp)return this.throws(expected);const obj=this._obj;const promise=utils.flag(this,"promise");const isNot=utils.flag(this,"negate");let thrown=null;if(promise==="rejects"){thrown=obj;}else if(promise==="resolves"&&typeof obj!=="function"){if(!isNot){const message=utils.flag(this,"message")||"expected promise to throw an error, but it didn't";const error={showDiff:false};throw new AssertionError(message,error,utils.flag(this,"ssfi"));}else{return;}}else{let isThrow=false;try{obj();}catch(err){isThrow=true;thrown=err;}if(!isThrow&&!isNot){const message=utils.flag(this,"message")||"expected function to throw an error, but it didn't";const error={showDiff:false};throw new AssertionError(message,error,utils.flag(this,"ssfi"));}}if(typeof expected==="function"){const name=expected.name||expected.prototype.constructor.name;return this.assert(thrown&&thrown instanceof expected,\`expected error to be instance of \${name}\`,\`expected error not to be instance of \${name}\`,expected,thrown);}if(expected instanceof Error){return this.assert(thrown&&expected.message===thrown.message,\`expected error to have message: \${expected.message}\`,\`expected error not to have message: \${expected.message}\`,expected.message,thrown&&thrown.message);}if(typeof expected==="object"&&"asymmetricMatch"in expected&&typeof expected.asymmetricMatch==="function"){const matcher=expected;return this.assert(thrown&&matcher.asymmetricMatch(thrown),"expected error to match asymmetric matcher","expected error not to match asymmetric matcher",matcher,thrown);}throw new Error(\`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "\${typeof expected}"\`);});def(["toHaveReturned","toReturn"],function(){const spy=getSpy(this);const spyName=spy.getMockName();const calledAndNotThrew=spy.mock.calls.length>0&&spy.mock.results.some(({type})=>type!=="throw");this.assert(calledAndNotThrew,\`expected "\${spyName}" to be successfully called at least once\`,\`expected "\${spyName}" to not be successfully called\`,calledAndNotThrew,!calledAndNotThrew,false);});def(["toHaveReturnedTimes","toReturnTimes"],function(times){const spy=getSpy(this);const spyName=spy.getMockName();const successfulReturns=spy.mock.results.reduce((success,{type})=>type==="throw"?success:++success,0);this.assert(successfulReturns===times,\`expected "\${spyName}" to be successfully called \${times} times\`,\`expected "\${spyName}" to not be successfully called \${times} times\`,\`expected number of returns: \${times}\`,\`received number of returns: \${successfulReturns}\`,false);});def(["toHaveReturnedWith","toReturnWith"],function(value){const spy=getSpy(this);const spyName=spy.getMockName();const pass=spy.mock.results.some(({type,value:result})=>type==="return"&&equals(value,result));const isNot=utils.flag(this,"negate");const msg=utils.getMessage(this,[pass,\`expected "\${spyName}" to return with: #{exp} at least once\`,\`expected "\${spyName}" to not return with: #{exp}\`,value]);if(pass&&isNot||!pass&&!isNot)throw new AssertionError(formatReturns(spy,msg,value));});def(["toHaveLastReturnedWith","lastReturnedWith"],function(value){const spy=getSpy(this);const spyName=spy.getMockName();const lastResult=spy.mock.results[spy.mock.results.length-1].value;const pass=equals(lastResult,value);this.assert(pass,\`expected last "\${spyName}" call to return #{exp}\`,\`expected last "\${spyName}" call to not return #{exp}\`,value,lastResult);});def(["toHaveNthReturnedWith","nthReturnedWith"],function(nthCall,value){const spy=getSpy(this);const spyName=spy.getMockName();const isNot=utils.flag(this,"negate");const _spy$mock$results=spy.mock.results[nthCall-1],callType=_spy$mock$results.type,callResult=_spy$mock$results.value;const ordinalCall=\`\${ordinalOf(nthCall)} call\`;if(!isNot&&callType==="throw")chai.assert.fail(\`expected \${ordinalCall} to return #{exp}, but instead it threw an error\`);const nthCallReturn=equals(callResult,value);this.assert(nthCallReturn,\`expected \${ordinalCall} "\${spyName}" call to return #{exp}\`,\`expected \${ordinalCall} "\${spyName}" call to not return #{exp}\`,value,callResult);});def("toSatisfy",function(matcher,message){return this.be.satisfy(matcher,message);});utils.addProperty(chai.Assertion.prototype,"resolves",function __VITEST_RESOLVES__(){const error=new Error("resolves");utils.flag(this,"promise","resolves");utils.flag(this,"error",error);const test=utils.flag(this,"vitest-test");const obj=utils.flag(this,"object");if(typeof(obj==null?void 0:obj.then)!=="function")throw new TypeError(\`You must provide a Promise to expect() when using .resolves, not '\${typeof obj}'.\`);const proxy=new Proxy(this,{get:(target,key,receiver)=>{const result=Reflect.get(target,key,receiver);if(typeof result!=="function")return result instanceof chai.Assertion?proxy:result;return async(...args)=>{const promise=obj.then(value=>{utils.flag(this,"object",value);return result.call(this,...args);},err=>{const _error=new AssertionError(\`promise rejected "\${utils.inspect(err)}" instead of resolving\`,{showDiff:false});_error.cause=err;_error.stack=error.stack.replace(error.message,_error.message);throw _error;});return recordAsyncExpect$1(test,promise);};}});return proxy;});utils.addProperty(chai.Assertion.prototype,"rejects",function __VITEST_REJECTS__(){const error=new Error("rejects");utils.flag(this,"promise","rejects");utils.flag(this,"error",error);const test=utils.flag(this,"vitest-test");const obj=utils.flag(this,"object");const wrapper=typeof obj==="function"?obj():obj;if(typeof(wrapper==null?void 0:wrapper.then)!=="function")throw new TypeError(\`You must provide a Promise to expect() when using .rejects, not '\${typeof wrapper}'.\`);const proxy=new Proxy(this,{get:(target,key,receiver)=>{const result=Reflect.get(target,key,receiver);if(typeof result!=="function")return result instanceof chai.Assertion?proxy:result;return async(...args)=>{const promise=wrapper.then(value=>{const _error=new AssertionError(\`promise resolved "\${utils.inspect(value)}" instead of rejecting\`,{showDiff:true,expected:new Error("rejected promise"),actual:value});_error.stack=error.stack.replace(error.message,_error.message);throw _error;},err=>{utils.flag(this,"object",err);return result.call(this,...args);});return recordAsyncExpect$1(test,promise);};}});return proxy;});};function getMatcherState(assertion,expect){const obj=assertion._obj;const isNot=util.flag(assertion,"negate");const promise=util.flag(assertion,"promise")||"";const jestUtils=_objectSpread(_objectSpread({},getMatcherUtils()),{},{diff,stringify,iterableEquality,subsetEquality});const matcherState=_objectSpread(_objectSpread({},getState(expect)),{},{customTesters:getCustomEqualityTesters(),isNot,utils:jestUtils,promise,equals,// needed for built-in jest-snapshots, but we don't use it
suppressedErrors:[]});return{state:matcherState,isNot,obj};}class JestExtendError extends Error{constructor(message,actual,expected){super(message);this.actual=actual;this.expected=expected;}}function JestExtendPlugin(expect,matchers){return(c,utils)=>{Object.entries(matchers).forEach(([expectAssertionName,expectAssertion])=>{function expectWrapper(...args){const _getMatcherState=getMatcherState(this,expect),state=_getMatcherState.state,isNot=_getMatcherState.isNot,obj=_getMatcherState.obj;const result=expectAssertion.call(state,obj,...args);if(result&&typeof result==="object"&&result instanceof Promise){return result.then(({pass:pass2,message:message2,actual:actual2,expected:expected2})=>{if(pass2&&isNot||!pass2&&!isNot)throw new JestExtendError(message2(),actual2,expected2);});}const pass=result.pass,message=result.message,actual=result.actual,expected=result.expected;if(pass&&isNot||!pass&&!isNot)throw new JestExtendError(message(),actual,expected);}const softWrapper=wrapSoft(utils,expectWrapper);utils.addMethod(globalThis[JEST_MATCHERS_OBJECT$1].matchers,expectAssertionName,softWrapper);utils.addMethod(c.Assertion.prototype,expectAssertionName,softWrapper);class CustomMatcher extends AsymmetricMatcher$1{constructor(inverse=false,...sample){super(sample,inverse);}asymmetricMatch(other){const _expectAssertion$call=expectAssertion.call(this.getMatcherContext(expect),other,...this.sample),pass=_expectAssertion$call.pass;return this.inverse?!pass:pass;}toString(){return\`\${this.inverse?"not.":""}\${expectAssertionName}\`;}getExpectedType(){return"any";}toAsymmetricMatcher(){return\`\${this.toString()}<\${this.sample.map(String).join(", ")}>\`;}}const customMatcher=(...sample)=>new CustomMatcher(false,...sample);Object.defineProperty(expect,expectAssertionName,{configurable:true,enumerable:true,value:customMatcher,writable:true});Object.defineProperty(expect.not,expectAssertionName,{configurable:true,enumerable:true,value:(...sample)=>new CustomMatcher(true,...sample),writable:true});Object.defineProperty(globalThis[ASYMMETRIC_MATCHERS_OBJECT$1],expectAssertionName,{configurable:true,enumerable:true,value:customMatcher,writable:true});});};}const JestExtend=(chai,utils)=>{utils.addMethod(chai.expect,"extend",(expect,expects)=>{chai.use(JestExtendPlugin(expect,expects));});};function getDefaultExportFromCjs(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,'default')?x['default']:x;}var naturalCompare$2={exports:{}};/*
 * @version    1.4.0
 * @date       2015-10-26
 * @stability  3 - Stable
 * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
 * @license    MIT License
 */var naturalCompare=function(a,b){var i,codeA,codeB=1,posA=0,posB=0,alphabet=String.alphabet;function getCode(str,pos,code){if(code){for(i=pos;code=getCode(str,i),code<76&&code>65;)++i;return+str.slice(pos-1,i);}code=alphabet&&alphabet.indexOf(str.charAt(pos));return code>-1?code+76:(code=str.charCodeAt(pos)||0,code<45||code>127)?code:code<46?65// -
:code<48?code-1:code<58?code+18// 0-9
:code<65?code-11:code<91?code+11// A-Z
:code<97?code-37:code<123?code+5// a-z
:code-63;}if((a+="")!=(b+=""))for(;codeB;){codeA=getCode(a,posA++);codeB=getCode(b,posB++);if(codeA<76&&codeB<76&&codeA>66&&codeB>66){codeA=getCode(a,posA,posA);codeB=getCode(b,posB,posA=i);posB=i;}if(codeA!=codeB)return codeA<codeB?-1:1;}return 0;};try{naturalCompare$2.exports=naturalCompare;}catch(e){String.naturalCompare=naturalCompare;}var naturalCompareExports=naturalCompare$2.exports;var naturalCompare$1=/*@__PURE__*/getDefaultExportFromCjs(naturalCompareExports);function notNullish(v){return v!=null;}function isPrimitive(value){return value===null||typeof value!=="function"&&typeof value!=="object";}function isObject(item){return item!=null&&typeof item==="object"&&!Array.isArray(item);}function getCallLastIndex(code){let charIndex=-1;let inString=null;let startedBracers=0;let endedBracers=0;let beforeChar=null;while(charIndex<=code.length){beforeChar=code[charIndex];charIndex++;const char=code[charIndex];const isCharString=char==='"'||char==="'"||char==="\`";if(isCharString&&beforeChar!=="\\\\"){if(inString===char)inString=null;else if(!inString)inString=char;}if(!inString){if(char==="(")startedBracers++;if(char===")")endedBracers++;}if(startedBracers&&endedBracers&&startedBracers===endedBracers)return charIndex;}return null;}let getPromiseValue=()=>'Promise{…}';try{const _process$binding2=process.binding('util'),getPromiseDetails=_process$binding2.getPromiseDetails,kPending=_process$binding2.kPending,kRejected=_process$binding2.kRejected;if(Array.isArray(getPromiseDetails(Promise.resolve()))){getPromiseValue=(value,options)=>{const _getPromiseDetails3=getPromiseDetails(value),_getPromiseDetails4=_slicedToArray(_getPromiseDetails3,2),state=_getPromiseDetails4[0],innerValue=_getPromiseDetails4[1];if(state===kPending){return'Promise{<pending>}';}return\`Promise\${state===kRejected?'!':''}{\${options.inspect(innerValue,options)}}\`;};}}catch(notNode){/* ignore */}/* !
 * loupe
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */let nodeInspect=false;try{// eslint-disable-next-line global-require
const nodeUtil=require('util');nodeInspect=nodeUtil.inspect?nodeUtil.inspect.custom:false;}catch(noNodeInspect){nodeInspect=false;}const lineSplitRE=/\\r?\\n/;function positionToOffset(source,lineNumber,columnNumber){const lines=source.split(lineSplitRE);const nl=/\\r\\n/.test(source)?2:1;let start=0;if(lineNumber>lines.length)return source.length;for(let i=0;i<lineNumber-1;i++)start+=lines[i].length+nl;return start+columnNumber;}function offsetToLineNumber(source,offset){if(offset>source.length){throw new Error(\`offset is longer than source length! offset \${offset} > length \${source.length}\`);}const lines=source.split(lineSplitRE);const nl=/\\r\\n/.test(source)?2:1;let counted=0;let line=0;for(;line<lines.length;line++){const lineLength=lines[line].length+nl;if(counted+lineLength>=offset)break;counted+=lineLength;}return line+1;}// Copyright 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023 Simon Lydell
// License: MIT.
var LineTerminatorSequence;LineTerminatorSequence=/\\r?\\n|[\\r\\u2028\\u2029]/y;RegExp(LineTerminatorSequence.source);// src/index.ts
var reservedWords={keyword:["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"],strict:["implements","interface","let","package","private","protected","public","static","yield"]};new Set(reservedWords.keyword);new Set(reservedWords.strict);const serialize$1=(val,config,indentation,depth,refs,printer)=>{const name=val.getMockName();const nameString=name==="vi.fn()"?"":\` \${name}\`;let callsString="";if(val.mock.calls.length!==0){const indentationNext=indentation+config.indent;callsString=\` {\${config.spacingOuter}\${indentationNext}"calls": \${printer(val.mock.calls,config,indentationNext,depth,refs)}\${config.min?", ":","}\${config.spacingOuter}\${indentationNext}"results": \${printer(val.mock.results,config,indentationNext,depth,refs)}\${config.min?"":","}\${config.spacingOuter}\${indentation}}\`;}return\`[MockFunction\${nameString}]\${callsString}\`;};const test=val=>val&&!!val._isMockFunction;const plugin={serialize:serialize$1,test};const _plugins_3=plugins_1,DOMCollection=_plugins_3.DOMCollection,DOMElement=_plugins_3.DOMElement,Immutable=_plugins_3.Immutable,ReactElement=_plugins_3.ReactElement,ReactTestComponent=_plugins_3.ReactTestComponent,AsymmetricMatcher=_plugins_3.AsymmetricMatcher;let PLUGINS=[ReactTestComponent,ReactElement,DOMElement,DOMCollection,Immutable,AsymmetricMatcher,plugin];function addSerializer(plugin){PLUGINS=[plugin].concat(PLUGINS);}function getSerializers(){return PLUGINS;}function testNameToKey(testName,count){return\`\${testName} \${count}\`;}function keyToTestName(key){if(!/ \\d+$/.test(key))throw new Error("Snapshot keys must end with a number.");return key.replace(/ \\d+$/,"");}function getSnapshotData(content,options){const update=options.updateSnapshot;const data=/* @__PURE__ */Object.create(null);let snapshotContents="";let dirty=false;if(content!=null){try{snapshotContents=content;const populate=new Function("exports",snapshotContents);populate(data);}catch{}}const isInvalid=snapshotContents;if((update==="all"||update==="new")&&isInvalid)dirty=true;return{data,dirty};}function addExtraLineBreaks(string){return string.includes("\\n")?\`
\${string}
\`:string;}function removeExtraLineBreaks(string){return string.length>2&&string.startsWith("\\n")&&string.endsWith("\\n")?string.slice(1,-1):string;}const escapeRegex=true;const printFunctionName=false;function serialize(val,indent=2,formatOverrides={}){return normalizeNewlines(format_1(val,_objectSpread({escapeRegex,indent,plugins:getSerializers(),printFunctionName},formatOverrides)));}function escapeBacktickString(str){return str.replace(/\`|\\\\|\\\${/g,"\\\\$&");}function printBacktickString(str){return\`\\\`\${escapeBacktickString(str)}\\\`\`;}function normalizeNewlines(string){return string.replace(/\\r\\n|\\r/g,"\\n");}async function saveSnapshotFile(environment,snapshotData,snapshotPath){const snapshots=Object.keys(snapshotData).sort(naturalCompare$1).map(key=>\`exports[\${printBacktickString(key)}] = \${printBacktickString(normalizeNewlines(snapshotData[key]))};\`);const content=\`\${environment.getHeader()}

\${snapshots.join("\\n\\n")}
\`;const oldContent=await environment.readSnapshotFile(snapshotPath);const skipWriting=oldContent!=null&&oldContent===content;if(skipWriting)return;await environment.saveSnapshotFile(snapshotPath,content);}function prepareExpected(expected){function findStartIndent(){var _a,_b;const matchObject=/^( +)}\\s+$/m.exec(expected||"");const objectIndent=(_a=matchObject==null?void 0:matchObject[1])==null?void 0:_a.length;if(objectIndent)return objectIndent;const matchText=/^\\n( +)"/.exec(expected||"");return((_b=matchText==null?void 0:matchText[1])==null?void 0:_b.length)||0;}const startIndent=findStartIndent();let expectedTrimmed=expected==null?void 0:expected.trim();if(startIndent){expectedTrimmed=expectedTrimmed==null?void 0:expectedTrimmed.replace(new RegExp(\`^\${" ".repeat(startIndent)}\`,"gm"),"").replace(/ +}$/,"}");}return expectedTrimmed;}function deepMergeArray(target=[],source=[]){const mergedOutput=Array.from(target);source.forEach((sourceElement,index)=>{const targetElement=mergedOutput[index];if(Array.isArray(target[index])){mergedOutput[index]=deepMergeArray(target[index],sourceElement);}else if(isObject(targetElement)){mergedOutput[index]=deepMergeSnapshot(target[index],sourceElement);}else{mergedOutput[index]=sourceElement;}});return mergedOutput;}function deepMergeSnapshot(target,source){if(isObject(target)&&isObject(source)){const mergedOutput=_objectSpread({},target);Object.keys(source).forEach(key=>{if(isObject(source[key])&&!source[key].$$typeof){if(!(key in target))Object.assign(mergedOutput,{[key]:source[key]});else mergedOutput[key]=deepMergeSnapshot(target[key],source[key]);}else if(Array.isArray(source[key])){mergedOutput[key]=deepMergeArray(target[key],source[key]);}else{Object.assign(mergedOutput,{[key]:source[key]});}});return mergedOutput;}else if(Array.isArray(target)&&Array.isArray(source)){return deepMergeArray(target,source);}return target;}const comma=','.charCodeAt(0);const chars='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';const intToChar=new Uint8Array(64);// 64 possible chars.
const charToInt=new Uint8Array(128);// z is 122 in ASCII
for(let i=0;i<chars.length;i++){const c=chars.charCodeAt(i);intToChar[i]=c;charToInt[c]=i;}function decode(mappings){const state=new Int32Array(5);const decoded=[];let index=0;do{const semi=indexOf(mappings,index);const line=[];let sorted=true;let lastCol=0;state[0]=0;for(let i=index;i<semi;i++){let seg;i=decodeInteger(mappings,i,state,0);// genColumn
const col=state[0];if(col<lastCol)sorted=false;lastCol=col;if(hasMoreVlq(mappings,i,semi)){i=decodeInteger(mappings,i,state,1);// sourcesIndex
i=decodeInteger(mappings,i,state,2);// sourceLine
i=decodeInteger(mappings,i,state,3);// sourceColumn
if(hasMoreVlq(mappings,i,semi)){i=decodeInteger(mappings,i,state,4);// namesIndex
seg=[col,state[1],state[2],state[3],state[4]];}else{seg=[col,state[1],state[2],state[3]];}}else{seg=[col];}line.push(seg);}if(!sorted)sort$1(line);decoded.push(line);index=semi+1;}while(index<=mappings.length);return decoded;}function indexOf(mappings,index){const idx=mappings.indexOf(';',index);return idx===-1?mappings.length:idx;}function decodeInteger(mappings,pos,state,j){let value=0;let shift=0;let integer=0;do{const c=mappings.charCodeAt(pos++);integer=charToInt[c];value|=(integer&31)<<shift;shift+=5;}while(integer&32);const shouldNegate=value&1;value>>>=1;if(shouldNegate){value=-0x80000000|-value;}state[j]+=value;return pos;}function hasMoreVlq(mappings,i,length){if(i>=length)return false;return mappings.charCodeAt(i)!==comma;}function sort$1(line){line.sort(sortComparator$1);}function sortComparator$1(a,b){return a[0]-b[0];}// Matches the scheme of a URL, eg "http://"
const schemeRegex=/^[\\w+.-]+:\\/\\//;/**
 * Matches the parts of a URL:
 * 1. Scheme, including ":", guaranteed.
 * 2. User/password, including "@", optional.
 * 3. Host, guaranteed.
 * 4. Port, including ":", optional.
 * 5. Path, including "/", optional.
 * 6. Query, including "?", optional.
 * 7. Hash, including "#", optional.
 */const urlRegex=/^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;/**
 * File URLs are weird. They dont' need the regular \`//\` in the scheme, they may or may not start
 * with a leading \`/\`, they can have a domain (but only if they don't start with a Windows drive).
 *
 * 1. Host, optional.
 * 2. Path, which may include "/", guaranteed.
 * 3. Query, including "?", optional.
 * 4. Hash, including "#", optional.
 */const fileRegex=/^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;var UrlType;(function(UrlType){UrlType[UrlType["Empty"]=1]="Empty";UrlType[UrlType["Hash"]=2]="Hash";UrlType[UrlType["Query"]=3]="Query";UrlType[UrlType["RelativePath"]=4]="RelativePath";UrlType[UrlType["AbsolutePath"]=5]="AbsolutePath";UrlType[UrlType["SchemeRelative"]=6]="SchemeRelative";UrlType[UrlType["Absolute"]=7]="Absolute";})(UrlType||(UrlType={}));function isAbsoluteUrl(input){return schemeRegex.test(input);}function isSchemeRelativeUrl(input){return input.startsWith('//');}function isAbsolutePath(input){return input.startsWith('/');}function isFileUrl(input){return input.startsWith('file:');}function isRelative(input){return /^[.?#]/.test(input);}function parseAbsoluteUrl(input){const match=urlRegex.exec(input);return makeUrl(match[1],match[2]||'',match[3],match[4]||'',match[5]||'/',match[6]||'',match[7]||'');}function parseFileUrl(input){const match=fileRegex.exec(input);const path=match[2];return makeUrl('file:','',match[1]||'','',isAbsolutePath(path)?path:'/'+path,match[3]||'',match[4]||'');}function makeUrl(scheme,user,host,port,path,query,hash){return{scheme,user,host,port,path,query,hash,type:UrlType.Absolute};}function parseUrl(input){if(isSchemeRelativeUrl(input)){const url=parseAbsoluteUrl('http:'+input);url.scheme='';url.type=UrlType.SchemeRelative;return url;}if(isAbsolutePath(input)){const url=parseAbsoluteUrl('http://foo.com'+input);url.scheme='';url.host='';url.type=UrlType.AbsolutePath;return url;}if(isFileUrl(input))return parseFileUrl(input);if(isAbsoluteUrl(input))return parseAbsoluteUrl(input);const url=parseAbsoluteUrl('http://foo.com/'+input);url.scheme='';url.host='';url.type=input?input.startsWith('?')?UrlType.Query:input.startsWith('#')?UrlType.Hash:UrlType.RelativePath:UrlType.Empty;return url;}function stripPathFilename(path){// If a path ends with a parent directory "..", then it's a relative path with excess parent
// paths. It's not a file, so we can't strip it.
if(path.endsWith('/..'))return path;const index=path.lastIndexOf('/');return path.slice(0,index+1);}function mergePaths(url,base){normalizePath(base,base.type);// If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
// path).
if(url.path==='/'){url.path=base.path;}else{// Resolution happens relative to the base path's directory, not the file.
url.path=stripPathFilename(base.path)+url.path;}}/**
 * The path can have empty directories "//", unneeded parents "foo/..", or current directory
 * "foo/.". We need to normalize to a standard representation.
 */function normalizePath(url,type){const rel=type<=UrlType.RelativePath;const pieces=url.path.split('/');// We need to preserve the first piece always, so that we output a leading slash. The item at
// pieces[0] is an empty string.
let pointer=1;// Positive is the number of real directories we've output, used for popping a parent directory.
// Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
let positive=0;// We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
// generate \`["foo", ""]\` pieces). And, if we pop a parent directory. But once we encounter a
// real directory, we won't need to append, unless the other conditions happen again.
let addTrailingSlash=false;for(let i=1;i<pieces.length;i++){const piece=pieces[i];// An empty directory, could be a trailing slash, or just a double "//" in the path.
if(!piece){addTrailingSlash=true;continue;}// If we encounter a real directory, then we don't need to append anymore.
addTrailingSlash=false;// A current directory, which we can always drop.
if(piece==='.')continue;// A parent directory, we need to see if there are any real directories we can pop. Else, we
// have an excess of parents, and we'll need to keep the "..".
if(piece==='..'){if(positive){addTrailingSlash=true;positive--;pointer--;}else if(rel){// If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
// URL, protocol relative URL, or an absolute path, we don't need to keep excess.
pieces[pointer++]=piece;}continue;}// We've encountered a real directory. Move it to the next insertion pointer, which accounts for
// any popped or dropped directories.
pieces[pointer++]=piece;positive++;}let path='';for(let i=1;i<pointer;i++){path+='/'+pieces[i];}if(!path||addTrailingSlash&&!path.endsWith('/..')){path+='/';}url.path=path;}/**
 * Attempts to resolve \`input\` URL/path relative to \`base\`.
 */function resolve$1(input,base){if(!input&&!base)return'';const url=parseUrl(input);let inputType=url.type;if(base&&inputType!==UrlType.Absolute){const baseUrl=parseUrl(base);const baseType=baseUrl.type;switch(inputType){case UrlType.Empty:url.hash=baseUrl.hash;// fall through
case UrlType.Hash:url.query=baseUrl.query;// fall through
case UrlType.Query:case UrlType.RelativePath:mergePaths(url,baseUrl);// fall through
case UrlType.AbsolutePath:// The host, user, and port are joined, you can't copy one without the others.
url.user=baseUrl.user;url.host=baseUrl.host;url.port=baseUrl.port;// fall through
case UrlType.SchemeRelative:// The input doesn't have a schema at least, so we need to copy at least that over.
url.scheme=baseUrl.scheme;}if(baseType>inputType)inputType=baseType;}normalizePath(url,inputType);const queryHash=url.query+url.hash;switch(inputType){// This is impossible, because of the empty checks at the start of the function.
// case UrlType.Empty:
case UrlType.Hash:case UrlType.Query:return queryHash;case UrlType.RelativePath:{// The first char is always a "/", and we need it to be relative.
const path=url.path.slice(1);if(!path)return queryHash||'.';if(isRelative(base||input)&&!isRelative(path)){// If base started with a leading ".", or there is no base and input started with a ".",
// then we need to ensure that the relative path starts with a ".". We don't know if
// relative starts with a "..", though, so check before prepending.
return'./'+path+queryHash;}return path+queryHash;}case UrlType.AbsolutePath:return url.path+queryHash;default:return url.scheme+'//'+url.user+url.host+url.port+url.path+queryHash;}}function resolve(input,base){// The base is always treated as a directory, if it's not empty.
// https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327
// https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401
if(base&&!base.endsWith('/'))base+='/';return resolve$1(input,base);}/**
 * Removes everything after the last "/", but leaves the slash.
 */function stripFilename(path){if(!path)return'';const index=path.lastIndexOf('/');return path.slice(0,index+1);}const COLUMN=0;const SOURCES_INDEX=1;const SOURCE_LINE=2;const SOURCE_COLUMN=3;const NAMES_INDEX=4;function maybeSort(mappings,owned){const unsortedIndex=nextUnsortedSegmentLine(mappings,0);if(unsortedIndex===mappings.length)return mappings;// If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If
// not, we do not want to modify the consumer's input array.
if(!owned)mappings=mappings.slice();for(let i=unsortedIndex;i<mappings.length;i=nextUnsortedSegmentLine(mappings,i+1)){mappings[i]=sortSegments(mappings[i],owned);}return mappings;}function nextUnsortedSegmentLine(mappings,start){for(let i=start;i<mappings.length;i++){if(!isSorted(mappings[i]))return i;}return mappings.length;}function isSorted(line){for(let j=1;j<line.length;j++){if(line[j][COLUMN]<line[j-1][COLUMN]){return false;}}return true;}function sortSegments(line,owned){if(!owned)line=line.slice();return line.sort(sortComparator);}function sortComparator(a,b){return a[COLUMN]-b[COLUMN];}let found=false;/**
 * A binary search implementation that returns the index if a match is found.
 * If no match is found, then the left-index (the index associated with the item that comes just
 * before the desired index) is returned. To maintain proper sort order, a splice would happen at
 * the next index:
 *
 * \`\`\`js
 * const array = [1, 3];
 * const needle = 2;
 * const index = binarySearch(array, needle, (item, needle) => item - needle);
 *
 * assert.equal(index, 0);
 * array.splice(index + 1, 0, needle);
 * assert.deepEqual(array, [1, 2, 3]);
 * \`\`\`
 */function binarySearch(haystack,needle,low,high){while(low<=high){const mid=low+(high-low>>1);const cmp=haystack[mid][COLUMN]-needle;if(cmp===0){found=true;return mid;}if(cmp<0){low=mid+1;}else{high=mid-1;}}found=false;return low-1;}function upperBound(haystack,needle,index){for(let i=index+1;i<haystack.length;index=i++){if(haystack[i][COLUMN]!==needle)break;}return index;}function lowerBound(haystack,needle,index){for(let i=index-1;i>=0;index=i--){if(haystack[i][COLUMN]!==needle)break;}return index;}function memoizedState(){return{lastKey:-1,lastNeedle:-1,lastIndex:-1};}/**
 * This overly complicated beast is just to record the last tested line/column and the resulting
 * index, allowing us to skip a few tests if mappings are monotonically increasing.
 */function memoizedBinarySearch(haystack,needle,state,key){const lastKey=state.lastKey,lastNeedle=state.lastNeedle,lastIndex=state.lastIndex;let low=0;let high=haystack.length-1;if(key===lastKey){if(needle===lastNeedle){found=lastIndex!==-1&&haystack[lastIndex][COLUMN]===needle;return lastIndex;}if(needle>=lastNeedle){// lastIndex may be -1 if the previous needle was not found.
low=lastIndex===-1?0:lastIndex;}else{high=lastIndex;}}state.lastKey=key;state.lastNeedle=needle;return state.lastIndex=binarySearch(haystack,needle,low,high);}const LINE_GTR_ZERO='\`line\` must be greater than 0 (lines start at line 1)';const COL_GTR_EQ_ZERO='\`column\` must be greater than or equal to 0 (columns start at column 0)';const LEAST_UPPER_BOUND=-1;const GREATEST_LOWER_BOUND=1;/**
 * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.
 */let decodedMappings;/**
 * A higher-level API to find the source/line/column associated with a generated line/column
 * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
 * \`source-map\` library.
 */let originalPositionFor;class TraceMap{constructor(map,mapUrl){const isString=typeof map==='string';if(!isString&&map._decodedMemo)return map;const parsed=isString?JSON.parse(map):map;const version=parsed.version,file=parsed.file,names=parsed.names,sourceRoot=parsed.sourceRoot,sources=parsed.sources,sourcesContent=parsed.sourcesContent;this.version=version;this.file=file;this.names=names||[];this.sourceRoot=sourceRoot;this.sources=sources;this.sourcesContent=sourcesContent;const from=resolve(sourceRoot||'',stripFilename(mapUrl));this.resolvedSources=sources.map(s=>resolve(s||'',from));const mappings=parsed.mappings;if(typeof mappings==='string'){this._encoded=mappings;this._decoded=undefined;}else{this._encoded=undefined;this._decoded=maybeSort(mappings,isString);}this._decodedMemo=memoizedState();this._bySources=undefined;this._bySourceMemos=undefined;}}(()=>{decodedMappings=map=>{return map._decoded||(map._decoded=decode(map._encoded));};originalPositionFor=(map,{line,column,bias})=>{line--;if(line<0)throw new Error(LINE_GTR_ZERO);if(column<0)throw new Error(COL_GTR_EQ_ZERO);const decoded=decodedMappings(map);// It's common for parent source maps to have pointers to lines that have no
// mapping (like a "//# sourceMappingURL=") at the end of the child file.
if(line>=decoded.length)return OMapping(null,null,null,null);const segments=decoded[line];const index=traceSegmentInternal(segments,map._decodedMemo,line,column,bias||GREATEST_LOWER_BOUND);if(index===-1)return OMapping(null,null,null,null);const segment=segments[index];if(segment.length===1)return OMapping(null,null,null,null);const names=map.names,resolvedSources=map.resolvedSources;return OMapping(resolvedSources[segment[SOURCES_INDEX]],segment[SOURCE_LINE]+1,segment[SOURCE_COLUMN],segment.length===5?names[segment[NAMES_INDEX]]:null);};})();function OMapping(source,line,column,name){return{source,line,column,name};}function traceSegmentInternal(segments,memo,line,column,bias){let index=memoizedBinarySearch(segments,column,memo,line);if(found){index=(bias===LEAST_UPPER_BOUND?upperBound:lowerBound)(segments,column,index);}else if(bias===LEAST_UPPER_BOUND)index++;if(index===-1||index===segments.length)return-1;return index;}const CHROME_IE_STACK_REGEXP=/^\\s*at .*(\\S+:\\d+|\\(native\\))/m;const SAFARI_NATIVE_CODE_REGEXP=/^(eval@)?(\\[native code])?$/;const stackIgnorePatterns=["node:internal",/\\/packages\\/\\w+\\/dist\\//,/\\/@vitest\\/\\w+\\/dist\\//,"/vitest/dist/","/vitest/src/","/vite-node/dist/","/vite-node/src/","/node_modules/chai/","/node_modules/tinypool/","/node_modules/tinyspy/","/deps/chai.js",/__vitest_browser__/];function extractLocation(urlLike){if(!urlLike.includes(":"))return[urlLike];const regExp=/(.+?)(?::(\\d+))?(?::(\\d+))?$/;const parts=regExp.exec(urlLike.replace(/^\\(|\\)$/g,""));if(!parts)return[urlLike];let url=parts[1];if(url.startsWith("http:")||url.startsWith("https:")){const urlObj=new URL(url);url=urlObj.pathname;}if(url.startsWith("/@fs/")){url=url.slice(typeof process!=="undefined"&&process.platform==="win32"?5:4);}return[url,parts[2]||void 0,parts[3]||void 0];}function parseSingleFFOrSafariStack(raw){let line=raw.trim();if(SAFARI_NATIVE_CODE_REGEXP.test(line))return null;if(line.includes(" > eval"))line=line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,":$1");if(!line.includes("@")&&!line.includes(":"))return null;const functionNameRegex=/((.*".+"[^@]*)?[^@]*)(?:@)/;const matches=line.match(functionNameRegex);const functionName=matches&&matches[1]?matches[1]:void 0;const _extractLocation=extractLocation(line.replace(functionNameRegex,"")),_extractLocation2=_slicedToArray(_extractLocation,3),url=_extractLocation2[0],lineNumber=_extractLocation2[1],columnNumber=_extractLocation2[2];if(!url||!lineNumber||!columnNumber)return null;return{file:url,method:functionName||"",line:Number.parseInt(lineNumber),column:Number.parseInt(columnNumber)};}function parseSingleV8Stack(raw){let line=raw.trim();if(!CHROME_IE_STACK_REGEXP.test(line))return null;if(line.includes("(eval "))line=line.replace(/eval code/g,"eval").replace(/(\\(eval at [^()]*)|(,.*$)/g,"");let sanitizedLine=line.replace(/^\\s+/,"").replace(/\\(eval code/g,"(").replace(/^.*?\\s+/,"");const location=sanitizedLine.match(/ (\\(.+\\)$)/);sanitizedLine=location?sanitizedLine.replace(location[0],""):sanitizedLine;const _extractLocation3=extractLocation(location?location[1]:sanitizedLine),_extractLocation4=_slicedToArray(_extractLocation3,3),url=_extractLocation4[0],lineNumber=_extractLocation4[1],columnNumber=_extractLocation4[2];let method=location&&sanitizedLine||"";let file=url&&["eval","<anonymous>"].includes(url)?void 0:url;if(!file||!lineNumber||!columnNumber)return null;if(method.startsWith("async "))method=method.slice(6);if(file.startsWith("file://"))file=file.slice(7);file=resolve$3(file);if(method)method=method.replace(/__vite_ssr_import_\\d+__\\./g,"");return{method,file,line:Number.parseInt(lineNumber),column:Number.parseInt(columnNumber)};}function parseStacktrace(stack,options={}){const _options$ignoreStackE=options.ignoreStackEntries,ignoreStackEntries=_options$ignoreStackE===void 0?stackIgnorePatterns:_options$ignoreStackE;let stacks=!CHROME_IE_STACK_REGEXP.test(stack)?parseFFOrSafariStackTrace(stack):parseV8Stacktrace(stack);if(ignoreStackEntries.length)stacks=stacks.filter(stack2=>!ignoreStackEntries.some(p=>stack2.file.match(p)));return stacks.map(stack2=>{var _a;const map=(_a=options.getSourceMap)==null?void 0:_a.call(options,stack2.file);if(!map||typeof map!=="object"||!map.version)return stack2;const traceMap=new TraceMap(map);const _originalPositionFor=originalPositionFor(traceMap,stack2),line=_originalPositionFor.line,column=_originalPositionFor.column;if(line!=null&&column!=null)return _objectSpread(_objectSpread({},stack2),{},{line,column});return stack2;});}function parseFFOrSafariStackTrace(stack){return stack.split("\\n").map(line=>parseSingleFFOrSafariStack(line)).filter(notNullish);}function parseV8Stacktrace(stack){return stack.split("\\n").map(line=>parseSingleV8Stack(line)).filter(notNullish);}function parseErrorStacktrace(e,options={}){if(!e||isPrimitive(e))return[];if(e.stacks)return e.stacks;const stackStr=e.stack||e.stackStr||"";let stackFrames=parseStacktrace(stackStr,options);if(options.frameFilter)stackFrames=stackFrames.filter(f=>options.frameFilter(e,f)!==false);e.stacks=stackFrames;return stackFrames;}async function saveInlineSnapshots(environment,snapshots){const MagicString=(await import('./bundle-D7lcxiVj.js')).default;const files=new Set(snapshots.map(i=>i.file));await Promise.all(Array.from(files).map(async file=>{const snaps=snapshots.filter(i=>i.file===file);const code=await environment.readSnapshotFile(file);const s=new MagicString(code);for(const snap of snaps){const index=positionToOffset(code,snap.line,snap.column);replaceInlineSnap(code,s,index,snap.snapshot);}const transformed=s.toString();if(transformed!==code)await environment.saveSnapshotFile(file,transformed);}));}const startObjectRegex=/(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\\s*\\(\\s*(?:\\/\\*[\\S\\s]*\\*\\/\\s*|\\/\\/.*\\s+)*\\s*({)/m;function replaceObjectSnap(code,s,index,newSnap){let _code=code.slice(index);const startMatch=startObjectRegex.exec(_code);if(!startMatch)return false;_code=_code.slice(startMatch.index);let callEnd=getCallLastIndex(_code);if(callEnd===null)return false;callEnd+=index+startMatch.index;const shapeStart=index+startMatch.index+startMatch[0].length;const shapeEnd=getObjectShapeEndIndex(code,shapeStart);const snap=\`, \${prepareSnapString(newSnap,code,index)}\`;if(shapeEnd===callEnd){s.appendLeft(callEnd,snap);}else{s.overwrite(shapeEnd,callEnd,snap);}return true;}function getObjectShapeEndIndex(code,index){let startBraces=1;let endBraces=0;while(startBraces!==endBraces&&index<code.length){const s=code[index++];if(s==="{")startBraces++;else if(s==="}")endBraces++;}return index;}function prepareSnapString(snap,source,index){const lineNumber=offsetToLineNumber(source,index);const line=source.split(lineSplitRE)[lineNumber-1];const indent=line.match(/^\\s*/)[0]||"";const indentNext=indent.includes("	")?\`\${indent}	\`:\`\${indent}  \`;const lines=snap.trim().replace(/\\\\/g,"\\\\\\\\").split(/\\n/g);const isOneline=lines.length<=1;const quote="\`";if(isOneline)return\`\${quote}\${lines.join("\\n").replace(/\`/g,"\\\\\`").replace(/\\\${/g,"\\\\\${")}\${quote}\`;return\`\${quote}
\${lines.map(i=>i?indentNext+i:"").join("\\n").replace(/\`/g,"\\\\\`").replace(/\\\${/g,"\\\\\${")}
\${indent}\${quote}\`;}const startRegex=/(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\\s*\\(\\s*(?:\\/\\*[\\S\\s]*\\*\\/\\s*|\\/\\/.*\\s+)*\\s*[\\w_$]*(['"\`\\)])/m;function replaceInlineSnap(code,s,index,newSnap){const codeStartingAtIndex=code.slice(index);const startMatch=startRegex.exec(codeStartingAtIndex);const firstKeywordMatch=/toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot/.exec(codeStartingAtIndex);if(!startMatch||startMatch.index!==(firstKeywordMatch==null?void 0:firstKeywordMatch.index))return replaceObjectSnap(code,s,index,newSnap);const quote=startMatch[1];const startIndex=index+startMatch.index+startMatch[0].length;const snapString=prepareSnapString(newSnap,code,index);if(quote===")"){s.appendRight(startIndex-1,snapString);return true;}const quoteEndRE=new RegExp(\`(?:^|[^\\\\\\\\])\${quote}\`);const endMatch=quoteEndRE.exec(code.slice(startIndex));if(!endMatch)return false;const endIndex=startIndex+endMatch.index+endMatch[0].length;s.overwrite(startIndex-1,endIndex,snapString);return true;}const INDENTATION_REGEX=/^([^\\S\\n]*)\\S/m;function stripSnapshotIndentation(inlineSnapshot){const match=inlineSnapshot.match(INDENTATION_REGEX);if(!match||!match[1]){return inlineSnapshot;}const indentation=match[1];const lines=inlineSnapshot.split(/\\n/g);if(lines.length<=2){return inlineSnapshot;}if(lines[0].trim()!==""||lines[lines.length-1].trim()!==""){return inlineSnapshot;}for(let i=1;i<lines.length-1;i++){if(lines[i]!==""){if(lines[i].indexOf(indentation)!==0){return inlineSnapshot;}lines[i]=lines[i].substring(indentation.length);}}lines[lines.length-1]="";inlineSnapshot=lines.join("\\n");return inlineSnapshot;}async function saveRawSnapshots(environment,snapshots){await Promise.all(snapshots.map(async snap=>{if(!snap.readonly)await environment.saveSnapshotFile(snap.file,snap.snapshot);}));}class SnapshotState{constructor(testFilePath,snapshotPath,snapshotContent,options){this.testFilePath=testFilePath;this.snapshotPath=snapshotPath;const _getSnapshotData=getSnapshotData(snapshotContent,options),data=_getSnapshotData.data,dirty=_getSnapshotData.dirty;this._fileExists=snapshotContent!=null;this._initialData=data;this._snapshotData=data;this._dirty=dirty;this._inlineSnapshots=[];this._rawSnapshots=[];this._uncheckedKeys=new Set(Object.keys(this._snapshotData));this._counters=/* @__PURE__ */new Map();this.expand=options.expand||false;this.added=0;this.matched=0;this.unmatched=0;this._updateSnapshot=options.updateSnapshot;this.updated=0;this._snapshotFormat=_objectSpread({printBasicPrototype:false,escapeString:false},options.snapshotFormat);this._environment=options.snapshotEnvironment;}_counters;_dirty;_updateSnapshot;_snapshotData;_initialData;_inlineSnapshots;_rawSnapshots;_uncheckedKeys;_snapshotFormat;_environment;_fileExists;added;expand;matched;unmatched;updated;static async create(testFilePath,options){const snapshotPath=await options.snapshotEnvironment.resolvePath(testFilePath);const content=await options.snapshotEnvironment.readSnapshotFile(snapshotPath);return new SnapshotState(testFilePath,snapshotPath,content,options);}get environment(){return this._environment;}markSnapshotsAsCheckedForTest(testName){this._uncheckedKeys.forEach(uncheckedKey=>{if(keyToTestName(uncheckedKey)===testName)this._uncheckedKeys.delete(uncheckedKey);});}_inferInlineSnapshotStack(stacks){const promiseIndex=stacks.findIndex(i=>i.method.match(/__VITEST_(RESOLVES|REJECTS)__/));if(promiseIndex!==-1)return stacks[promiseIndex+3];const stackIndex=stacks.findIndex(i=>i.method.includes("__INLINE_SNAPSHOT__"));return stackIndex!==-1?stacks[stackIndex+2]:null;}_addSnapshot(key,receivedSerialized,options){this._dirty=true;if(options.isInline){const stacks=parseErrorStacktrace(options.error||new Error("snapshot"),{ignoreStackEntries:[]});const stack=this._inferInlineSnapshotStack(stacks);if(!stack){throw new Error(\`@vitest/snapshot: Couldn't infer stack frame for inline snapshot.
\${JSON.stringify(stacks)}\`);}stack.column--;this._inlineSnapshots.push(_objectSpread({snapshot:receivedSerialized},stack));}else if(options.rawSnapshot){this._rawSnapshots.push(_objectSpread(_objectSpread({},options.rawSnapshot),{},{snapshot:receivedSerialized}));}else{this._snapshotData[key]=receivedSerialized;}}clear(){this._snapshotData=this._initialData;this._counters=/* @__PURE__ */new Map();this.added=0;this.matched=0;this.unmatched=0;this.updated=0;this._dirty=false;}async save(){const hasExternalSnapshots=Object.keys(this._snapshotData).length;const hasInlineSnapshots=this._inlineSnapshots.length;const hasRawSnapshots=this._rawSnapshots.length;const isEmpty=!hasExternalSnapshots&&!hasInlineSnapshots&&!hasRawSnapshots;const status={deleted:false,saved:false};if((this._dirty||this._uncheckedKeys.size)&&!isEmpty){if(hasExternalSnapshots){await saveSnapshotFile(this._environment,this._snapshotData,this.snapshotPath);this._fileExists=true;}if(hasInlineSnapshots)await saveInlineSnapshots(this._environment,this._inlineSnapshots);if(hasRawSnapshots)await saveRawSnapshots(this._environment,this._rawSnapshots);status.saved=true;}else if(!hasExternalSnapshots&&this._fileExists){if(this._updateSnapshot==="all"){await this._environment.removeSnapshotFile(this.snapshotPath);this._fileExists=false;}status.deleted=true;}return status;}getUncheckedCount(){return this._uncheckedKeys.size||0;}getUncheckedKeys(){return Array.from(this._uncheckedKeys);}removeUncheckedKeys(){if(this._updateSnapshot==="all"&&this._uncheckedKeys.size){this._dirty=true;this._uncheckedKeys.forEach(key=>delete this._snapshotData[key]);this._uncheckedKeys.clear();}}match({testName,received,key,inlineSnapshot,isInline,error,rawSnapshot}){this._counters.set(testName,(this._counters.get(testName)||0)+1);const count=Number(this._counters.get(testName));if(!key)key=testNameToKey(testName,count);if(!(isInline&&this._snapshotData[key]!==void 0))this._uncheckedKeys.delete(key);let receivedSerialized=rawSnapshot&&typeof received==="string"?received:serialize(received,void 0,this._snapshotFormat);if(!rawSnapshot)receivedSerialized=addExtraLineBreaks(receivedSerialized);if(rawSnapshot){if(rawSnapshot.content&&rawSnapshot.content.match(/\\r\\n/)&&!receivedSerialized.match(/\\r\\n/))rawSnapshot.content=normalizeNewlines(rawSnapshot.content);}const expected=isInline?inlineSnapshot:rawSnapshot?rawSnapshot.content:this._snapshotData[key];const expectedTrimmed=prepareExpected(expected);const pass=expectedTrimmed===prepareExpected(receivedSerialized);const hasSnapshot=expected!==void 0;const snapshotIsPersisted=isInline||this._fileExists||rawSnapshot&&rawSnapshot.content!=null;if(pass&&!isInline&&!rawSnapshot){this._snapshotData[key]=receivedSerialized;}if(hasSnapshot&&this._updateSnapshot==="all"||(!hasSnapshot||!snapshotIsPersisted)&&(this._updateSnapshot==="new"||this._updateSnapshot==="all")){if(this._updateSnapshot==="all"){if(!pass){if(hasSnapshot)this.updated++;else this.added++;this._addSnapshot(key,receivedSerialized,{error,isInline,rawSnapshot});}else{this.matched++;}}else{this._addSnapshot(key,receivedSerialized,{error,isInline,rawSnapshot});this.added++;}return{actual:"",count,expected:"",key,pass:true};}else{if(!pass){this.unmatched++;return{actual:removeExtraLineBreaks(receivedSerialized),count,expected:expectedTrimmed!==void 0?removeExtraLineBreaks(expectedTrimmed):void 0,key,pass:false};}else{this.matched++;return{actual:"",count,expected:"",key,pass:true};}}}async pack(){const snapshot={filepath:this.testFilePath,added:0,fileDeleted:false,matched:0,unchecked:0,uncheckedKeys:[],unmatched:0,updated:0};const uncheckedCount=this.getUncheckedCount();const uncheckedKeys=this.getUncheckedKeys();if(uncheckedCount)this.removeUncheckedKeys();const status=await this.save();snapshot.fileDeleted=status.deleted;snapshot.added=this.added;snapshot.matched=this.matched;snapshot.unmatched=this.unmatched;snapshot.updated=this.updated;snapshot.unchecked=!status.deleted?uncheckedCount:0;snapshot.uncheckedKeys=Array.from(uncheckedKeys);return snapshot;}}function createMismatchError(message,expand,actual,expected){const error=new Error(message);Object.defineProperty(error,"actual",{value:actual,enumerable:true,configurable:true,writable:true});Object.defineProperty(error,"expected",{value:expected,enumerable:true,configurable:true,writable:true});Object.defineProperty(error,"diffOptions",{value:{expand}});return error;}class SnapshotClient{constructor(options={}){this.options=options;}filepath;name;snapshotState;snapshotStateMap=/* @__PURE__ */new Map();async startCurrentRun(filepath,name,options){var _a;this.filepath=filepath;this.name=name;if(((_a=this.snapshotState)==null?void 0:_a.testFilePath)!==filepath){await this.finishCurrentRun();if(!this.getSnapshotState(filepath)){this.snapshotStateMap.set(filepath,await SnapshotState.create(filepath,options));}this.snapshotState=this.getSnapshotState(filepath);}}getSnapshotState(filepath){return this.snapshotStateMap.get(filepath);}clearTest(){this.filepath=void 0;this.name=void 0;}skipTestSnapshots(name){var _a;(_a=this.snapshotState)==null?void 0:_a.markSnapshotsAsCheckedForTest(name);}assert(options){var _a,_b,_c,_d;const _options$filepath=options.filepath,filepath=_options$filepath===void 0?this.filepath:_options$filepath,_options$name=options.name,name=_options$name===void 0?this.name:_options$name,message=options.message,_options$isInline=options.isInline,isInline=_options$isInline===void 0?false:_options$isInline,properties=options.properties,inlineSnapshot=options.inlineSnapshot,error=options.error,errorMessage=options.errorMessage,rawSnapshot=options.rawSnapshot;let received=options.received;if(!filepath)throw new Error("Snapshot cannot be used outside of test");if(typeof properties==="object"){if(typeof received!=="object"||!received)throw new Error("Received value must be an object when the matcher has properties");try{const pass2=((_b=(_a=this.options).isEqual)==null?void 0:_b.call(_a,received,properties))??false;if(!pass2)throw createMismatchError("Snapshot properties mismatched",(_c=this.snapshotState)==null?void 0:_c.expand,received,properties);else received=deepMergeSnapshot(received,properties);}catch(err){err.message=errorMessage||"Snapshot mismatched";throw err;}}const testName=[name,...(message?[message]:[])].join(" > ");const snapshotState=this.getSnapshotState(filepath);const _snapshotState$match=snapshotState.match({testName,received,isInline,error,inlineSnapshot,rawSnapshot}),actual=_snapshotState$match.actual,expected=_snapshotState$match.expected,key=_snapshotState$match.key,pass=_snapshotState$match.pass;if(!pass)throw createMismatchError(\`Snapshot \\\`\${key||"unknown"}\\\` mismatched\`,(_d=this.snapshotState)==null?void 0:_d.expand,actual==null?void 0:actual.trim(),expected==null?void 0:expected.trim());}async assertRaw(options){if(!options.rawSnapshot)throw new Error("Raw snapshot is required");const _options$filepath2=options.filepath,filepath=_options$filepath2===void 0?this.filepath:_options$filepath2,rawSnapshot=options.rawSnapshot;if(rawSnapshot.content==null){if(!filepath)throw new Error("Snapshot cannot be used outside of test");const snapshotState=this.getSnapshotState(filepath);options.filepath||(options.filepath=filepath);rawSnapshot.file=await snapshotState.environment.resolveRawPath(filepath,rawSnapshot.file);rawSnapshot.content=(await snapshotState.environment.readSnapshotFile(rawSnapshot.file))||void 0;}return this.assert(options);}async finishCurrentRun(){if(!this.snapshotState)return null;const result=await this.snapshotState.pack();this.snapshotState=void 0;return result;}clear(){this.snapshotStateMap.clear();}}function getFullName(task,separator=" > "){return getNames(task).join(separator);}function isChildProcess(){return typeof process!=="undefined"&&!!process.send;}const RealDate=Date;let now=null;class MockDate extends RealDate{constructor(y,m,d,h,M,s,ms){super();let date;switch(arguments.length){case 0:if(now!==null)date=new RealDate(now.valueOf());else date=new RealDate();break;case 1:date=new RealDate(y);break;default:d=typeof d==="undefined"?1:d;h=h||0;M=M||0;s=s||0;ms=ms||0;date=new RealDate(y,m,d,h,M,s,ms);break;}Object.setPrototypeOf(date,MockDate.prototype);return date;}}MockDate.UTC=RealDate.UTC;MockDate.now=function(){return new MockDate().valueOf();};MockDate.parse=function(dateString){return RealDate.parse(dateString);};MockDate.toString=function(){return RealDate.toString();};function mockDate(date){const dateObj=new RealDate(date.valueOf());if(Number.isNaN(dateObj.getTime()))throw new TypeError(\`mockdate: The time set is an invalid date: \${date}\`);globalThis.Date=MockDate;now=dateObj.valueOf();}function resetDate(){globalThis.Date=RealDate;}function resetModules(modules,resetMocks=false){const skipPaths=[// Vitest
/\\/vitest\\/dist\\//,/\\/vite-node\\/dist\\//,// yarn's .store folder
/vitest-virtual-\\w+\\/dist/,// cnpm
/@vitest\\/dist/,// don't clear mocks
...(!resetMocks?[/^mock:/]:[])];modules.forEach((mod,path)=>{if(skipPaths.some(re=>re.test(path)))return;modules.invalidateModule(mod);});}function waitNextTick(){const _getSafeTimers2=getSafeTimers(),setTimeout=_getSafeTimers2.setTimeout;return new Promise(resolve=>setTimeout(resolve,0));}async function waitForImportsToResolve(){await waitNextTick();const state=getWorkerState();const promises=[];let resolvingCount=0;for(const mod of state.moduleCache.values()){if(mod.promise&&!mod.evaluated)promises.push(mod.promise);if(mod.resolving)resolvingCount++;}if(!promises.length&&!resolvingCount)return;await Promise.allSettled(promises);await waitForImportsToResolve();}function commonjsRequire(path){throw new Error('Could not dynamically require "'+path+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');}var chaiSubset={exports:{}};(function(module,exports){(function(){(function(chaiSubset){if(typeof commonjsRequire==='function'&&'object'==='object'&&'object'==='object'){return module.exports=chaiSubset;}else{return chai.use(chaiSubset);}})(function(chai,utils){var Assertion=chai.Assertion;var assertionPrototype=Assertion.prototype;Assertion.addMethod('containSubset',function(expected){var actual=utils.flag(this,'object');var showDiff=chai.config.showDiff;assertionPrototype.assert.call(this,compare(expected,actual),'expected #{act} to contain subset #{exp}','expected #{act} to not contain subset #{exp}',expected,actual,showDiff);});chai.assert.containSubset=function(val,exp,msg){new chai.Assertion(val,msg).to.be.containSubset(exp);};function compare(expected,actual){if(expected===actual){return true;}if(typeof actual!==typeof expected){return false;}if(typeof expected!=='object'||expected===null){return expected===actual;}if(!!expected&&!actual){return false;}if(Array.isArray(expected)){if(typeof actual.length!=='number'){return false;}var aa=Array.prototype.slice.call(actual);return expected.every(function(exp){return aa.some(function(act){return compare(exp,act);});});}if(expected instanceof Date){if(actual instanceof Date){return expected.getTime()===actual.getTime();}else{return false;}}return Object.keys(expected).every(function(key){var eo=expected[key];var ao=actual[key];if(typeof eo==='object'&&eo!==null&&ao!==null){return compare(eo,ao);}if(typeof eo==='function'){return eo(ao);}return ao===eo;});}});}).call(commonjsGlobal);})(chaiSubset);var chaiSubsetExports=chaiSubset.exports;var Subset=/*@__PURE__*/getDefaultExportFromCjs$1(chaiSubsetExports);const MATCHERS_OBJECT=Symbol.for("matchers-object");const JEST_MATCHERS_OBJECT=Symbol.for("$$jest-matchers-object");const GLOBAL_EXPECT=Symbol.for("expect-global");const ASYMMETRIC_MATCHERS_OBJECT=Symbol.for("asymmetric-matchers-object");if(!Object.prototype.hasOwnProperty.call(globalThis,MATCHERS_OBJECT)){const globalState=/* @__PURE__ */new WeakMap();const matchers=/* @__PURE__ */Object.create(null);const customEqualityTesters=[];const assymetricMatchers=/* @__PURE__ */Object.create(null);Object.defineProperty(globalThis,MATCHERS_OBJECT,{get:()=>globalState});Object.defineProperty(globalThis,JEST_MATCHERS_OBJECT,{configurable:true,get:()=>({state:globalState.get(globalThis[GLOBAL_EXPECT]),matchers,customEqualityTesters})});Object.defineProperty(globalThis,ASYMMETRIC_MATCHERS_OBJECT,{get:()=>assymetricMatchers});}function recordAsyncExpect(test,promise){if(test&&promise instanceof Promise){promise=promise.finally(()=>{const index=test.promises.indexOf(promise);if(index!==-1)test.promises.splice(index,1);});if(!test.promises)test.promises=[];test.promises.push(promise);}return promise;}let _client;function getSnapshotClient(){if(!_client){_client=new SnapshotClient({isEqual:(received,expected)=>{return equals(received,expected,[iterableEquality,subsetEquality]);}});}return _client;}function getError(expected,promise){if(typeof expected!=="function"){if(!promise)throw new Error(\`expected must be a function, received \${typeof expected}\`);return expected;}try{expected();}catch(e){return e;}throw new Error("snapshot function didn't throw");}const SnapshotPlugin=(chai,utils)=>{const getTestNames=test=>{var _a;if(!test)return{};return{filepath:(_a=test.file)==null?void 0:_a.filepath,name:getNames(test).slice(1).join(" > ")};};for(const key of["matchSnapshot","toMatchSnapshot"]){utils.addMethod(chai.Assertion.prototype,key,function(properties,message){const isNot=utils.flag(this,"negate");if(isNot)throw new Error(\`\${key} cannot be used with "not"\`);const expected=utils.flag(this,"object");const test=utils.flag(this,"vitest-test");if(typeof properties==="string"&&typeof message==="undefined"){message=properties;properties=void 0;}const errorMessage=utils.flag(this,"message");getSnapshotClient().assert(_objectSpread({received:expected,message,isInline:false,properties,errorMessage},getTestNames(test)));});}utils.addMethod(chai.Assertion.prototype,"toMatchFileSnapshot",function(file,message){const isNot=utils.flag(this,"negate");if(isNot)throw new Error('toMatchFileSnapshot cannot be used with "not"');const expected=utils.flag(this,"object");const test=utils.flag(this,"vitest-test");const errorMessage=utils.flag(this,"message");const promise=getSnapshotClient().assertRaw(_objectSpread({received:expected,message,isInline:false,rawSnapshot:{file},errorMessage},getTestNames(test)));return recordAsyncExpect(test,promise);});utils.addMethod(chai.Assertion.prototype,"toMatchInlineSnapshot",function __INLINE_SNAPSHOT__(properties,inlineSnapshot,message){var _a;const isNot=utils.flag(this,"negate");if(isNot)throw new Error('toMatchInlineSnapshot cannot be used with "not"');const test=utils.flag(this,"vitest-test");const isInsideEach=test&&(test.each||((_a=test.suite)==null?void 0:_a.each));if(isInsideEach)throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");const expected=utils.flag(this,"object");const error=utils.flag(this,"error");if(typeof properties==="string"){message=inlineSnapshot;inlineSnapshot=properties;properties=void 0;}if(inlineSnapshot)inlineSnapshot=stripSnapshotIndentation(inlineSnapshot);const errorMessage=utils.flag(this,"message");getSnapshotClient().assert(_objectSpread({received:expected,message,isInline:true,properties,inlineSnapshot,error,errorMessage},getTestNames(test)));});utils.addMethod(chai.Assertion.prototype,"toThrowErrorMatchingSnapshot",function(message){const isNot=utils.flag(this,"negate");if(isNot)throw new Error('toThrowErrorMatchingSnapshot cannot be used with "not"');const expected=utils.flag(this,"object");const test=utils.flag(this,"vitest-test");const promise=utils.flag(this,"promise");const errorMessage=utils.flag(this,"message");getSnapshotClient().assert(_objectSpread({received:getError(expected,promise),message,errorMessage},getTestNames(test)));});utils.addMethod(chai.Assertion.prototype,"toThrowErrorMatchingInlineSnapshot",function __INLINE_SNAPSHOT__(inlineSnapshot,message){var _a;const isNot=utils.flag(this,"negate");if(isNot)throw new Error('toThrowErrorMatchingInlineSnapshot cannot be used with "not"');const test=utils.flag(this,"vitest-test");const isInsideEach=test&&(test.each||((_a=test.suite)==null?void 0:_a.each));if(isInsideEach)throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");const expected=utils.flag(this,"object");const error=utils.flag(this,"error");const promise=utils.flag(this,"promise");const errorMessage=utils.flag(this,"message");if(inlineSnapshot)inlineSnapshot=stripSnapshotIndentation(inlineSnapshot);getSnapshotClient().assert(_objectSpread({received:getError(expected,promise),message,inlineSnapshot,isInline:true,error,errorMessage},getTestNames(test)));});utils.addMethod(chai.expect,"addSnapshotSerializer",addSerializer);};use(JestExtend);use(JestChaiExpect);use(Subset);use(SnapshotPlugin);use(JestAsymmetricMatchers);function createExpect(test){var _a;const expect$1=(value,message)=>{const _getState=getState(expect$1),assertionCalls=_getState.assertionCalls;setState({assertionCalls:assertionCalls+1,soft:false},expect$1);const assert2=expect(value,message);const _test=test||getCurrentTest();if(_test)return assert2.withTest(_test);else return assert2;};Object.assign(expect$1,expect);Object.assign(expect$1,globalThis[ASYMMETRIC_MATCHERS_OBJECT$1]);expect$1.getState=()=>getState(expect$1);expect$1.setState=state=>setState(state,expect$1);const globalState=getState(globalThis[GLOBAL_EXPECT$1])||{};setState(_objectSpread(_objectSpread({},globalState),{},{assertionCalls:0,isExpectingAssertions:false,isExpectingAssertionsError:null,expectedAssertionsNumber:null,expectedAssertionsNumberErrorGen:null,environment:getCurrentEnvironment(),testPath:test?(_a=test.suite.file)==null?void 0:_a.filepath:globalState.testPath,currentTestName:test?getFullName(test):globalState.currentTestName}),expect$1);expect$1.extend=matchers=>expect.extend(expect$1,matchers);expect$1.addEqualityTesters=customTesters=>addCustomEqualityTesters(customTesters);expect$1.soft=(...args)=>{const assert2=expect$1(...args);expect$1.setState({soft:true});return assert2;};expect$1.unreachable=message=>{assert.fail(\`expected\${message?\` "\${message}" \`:" "}not to be reached\`);};function assertions(expected){const errorGen=()=>new Error(\`expected number of assertions to be \${expected}, but got \${expect$1.getState().assertionCalls}\`);if(Error.captureStackTrace)Error.captureStackTrace(errorGen(),assertions);expect$1.setState({expectedAssertionsNumber:expected,expectedAssertionsNumberErrorGen:errorGen});}function hasAssertions(){const error=new Error("expected any number of assertion, but got none");if(Error.captureStackTrace)Error.captureStackTrace(error,hasAssertions);expect$1.setState({isExpectingAssertions:true,isExpectingAssertionsError:error});}util.addMethod(expect$1,"assertions",assertions);util.addMethod(expect$1,"hasAssertions",hasAssertions);return expect$1;}const globalExpect=createExpect();Object.defineProperty(globalThis,GLOBAL_EXPECT$1,{value:globalExpect,writable:true,configurable:true});/**
 * A reference to the global object
 *
 * @type {object} globalObject
 */var globalObject$1;/* istanbul ignore else */if(typeof commonjsGlobal!=="undefined"){// Node
globalObject$1=commonjsGlobal;}else if(typeof window!=="undefined"){// Browser
globalObject$1=window;}else{// WebWorker
globalObject$1=self;}var global$1=globalObject$1;/**
 * Is true when the environment causes an error to be thrown for accessing the
 * __proto__ property.
 *
 * This is necessary in order to support \`node --disable-proto=throw\`.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto
 *
 * @type {boolean}
 */let throwsOnProto$1;try{const object={};// eslint-disable-next-line no-proto, no-unused-expressions
object.__proto__;throwsOnProto$1=false;}catch(_){// This branch is covered when tests are run with \`--disable-proto=throw\`,
// however we can test both branches at the same time, so this is ignored
/* istanbul ignore next */throwsOnProto$1=true;}var throwsOnProto_1=throwsOnProto$1;var call=Function.call;var throwsOnProto=throwsOnProto_1;var disallowedProperties=[// ignore size because it throws from Map
"size","caller","callee","arguments"];// This branch is covered when tests are run with \`--disable-proto=throw\`,
// however we can test both branches at the same time, so this is ignored
/* istanbul ignore next */if(throwsOnProto){disallowedProperties.push("__proto__");}var copyPrototypeMethods=function copyPrototypeMethods(prototype){// eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods
return Object.getOwnPropertyNames(prototype).reduce(function(result,name){if(disallowedProperties.includes(name)){return result;}if(typeof prototype[name]!=="function"){return result;}result[name]=call.bind(prototype[name]);return result;},Object.create(null));};var copyPrototype$5=copyPrototypeMethods;var array=copyPrototype$5(Array.prototype);var every$1=array.every;/**
 * @private
 */function hasCallsLeft(callMap,spy){if(callMap[spy.id]===undefined){callMap[spy.id]=0;}return callMap[spy.id]<spy.callCount;}/**
 * @private
 */function checkAdjacentCalls(callMap,spy,index,spies){var calledBeforeNext=true;if(index!==spies.length-1){calledBeforeNext=spy.calledBefore(spies[index+1]);}if(hasCallsLeft(callMap,spy)&&calledBeforeNext){callMap[spy.id]+=1;return true;}return false;}/**
 * A Sinon proxy object (fake, spy, stub)
 *
 * @typedef {object} SinonProxy
 * @property {Function} calledBefore - A method that determines if this proxy was called before another one
 * @property {string} id - Some id
 * @property {number} callCount - Number of times this proxy has been called
 */ /**
 * Returns true when the spies have been called in the order they were supplied in
 *
 * @param  {SinonProxy[] | SinonProxy} spies An array of proxies, or several proxies as arguments
 * @returns {boolean} true when spies are called in order, false otherwise
 */function calledInOrder(spies){var callMap={};// eslint-disable-next-line no-underscore-dangle
var _spies=arguments.length>1?arguments:spies;return every$1(_spies,checkAdjacentCalls.bind(null,callMap));}var calledInOrder_1=calledInOrder;/**
 * Returns a display name for a function
 *
 * @param  {Function} func
 * @returns {string}
 */var functionName$1=function functionName(func){if(!func){return"";}try{return func.displayName||func.name||// Use function decomposition as a last resort to get function
// name. Does not rely on function decomposition to work - if it
// doesn't debugging will be slightly less informative
// (i.e. toString will say 'spy' rather than 'myFunc').
(String(func).match(/function ([^\\s(]+)/)||[])[1];}catch(e){// Stringify may fail and we might get an exception, as a last-last
// resort fall back to empty string.
return"";}};var functionName=functionName$1;/**
 * Returns a display name for a value from a constructor
 *
 * @param  {object} value A value to examine
 * @returns {(string|null)} A string or null
 */function className(value){return value.constructor&&value.constructor.name||// The next branch is for IE11 support only:
// Because the name property is not set on the prototype
// of the Function object, we finally try to grab the
// name from its definition. This will never be reached
// in node, so we are not able to test this properly.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
typeof value.constructor==="function"&&/* istanbul ignore next */functionName(value.constructor)||null;}var className_1=className;var deprecated={};/* eslint-disable no-console */(function(exports){/**
   * Returns a function that will invoke the supplied function and print a
   * deprecation warning to the console each time it is called.
   *
   * @param  {Function} func
   * @param  {string} msg
   * @returns {Function}
   */exports.wrap=function(func,msg){var wrapped=function(){exports.printWarning(msg);return func.apply(this,arguments);};if(func.prototype){wrapped.prototype=func.prototype;}return wrapped;};/**
   * Returns a string which can be supplied to \`wrap()\` to notify the user that a
   * particular part of the sinon API has been deprecated.
   *
   * @param  {string} packageName
   * @param  {string} funcName
   * @returns {string}
   */exports.defaultMsg=function(packageName,funcName){return\`\${packageName}.\${funcName} is deprecated and will be removed from the public API in a future version of \${packageName}.\`;};/**
   * Prints a warning on the console, when it exists
   *
   * @param  {string} msg
   * @returns {undefined}
   */exports.printWarning=function(msg){/* istanbul ignore next */if(typeof process==="object"&&process.emitWarning){// Emit Warnings in Node
process.emitWarning(msg);}else if(console.info){console.info(msg);}else{console.log(msg);}};})(deprecated);/**
 * Returns true when fn returns true for all members of obj.
 * This is an every implementation that works for all iterables
 *
 * @param  {object}   obj
 * @param  {Function} fn
 * @returns {boolean}
 */var every=function every(obj,fn){var pass=true;try{// eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods
obj.forEach(function(){if(!fn.apply(this,arguments)){// Throwing an error is the only way to break \`forEach\`
throw new Error();}});}catch(e){pass=false;}return pass;};var sort=array.sort;var slice=array.slice;/**
 * @private
 */function comparator(a,b){// uuid, won't ever be equal
var aCall=a.getCall(0);var bCall=b.getCall(0);var aId=aCall&&aCall.callId||-1;var bId=bCall&&bCall.callId||-1;return aId<bId?-1:1;}/**
 * A Sinon proxy object (fake, spy, stub)
 *
 * @typedef {object} SinonProxy
 * @property {Function} getCall - A method that can return the first call
 */ /**
 * Sorts an array of SinonProxy instances (fake, spy, stub) by their first call
 *
 * @param  {SinonProxy[] | SinonProxy} spies
 * @returns {SinonProxy[]}
 */function orderByFirstCall(spies){return sort(slice(spies),comparator);}var orderByFirstCall_1=orderByFirstCall;var copyPrototype$4=copyPrototypeMethods;var _function=copyPrototype$4(Function.prototype);var copyPrototype$3=copyPrototypeMethods;var map=copyPrototype$3(Map.prototype);var copyPrototype$2=copyPrototypeMethods;var object=copyPrototype$2(Object.prototype);var copyPrototype$1=copyPrototypeMethods;var set=copyPrototype$1(Set.prototype);var copyPrototype=copyPrototypeMethods;var string=copyPrototype(String.prototype);var prototypes={array:array,function:_function,map:map,object:object,set:set,string:string};var typeDetect={exports:{}};(function(module,exports){(function(global,factory){module.exports=factory();})(commonjsGlobal,function(){/* !
     * type-detect
     * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
     * MIT Licensed
     */var promiseExists=typeof Promise==='function';/* eslint-disable no-undef */var globalObject=typeof self==='object'?self:commonjsGlobal;// eslint-disable-line id-blacklist
var symbolExists=typeof Symbol!=='undefined';var mapExists=typeof Map!=='undefined';var setExists=typeof Set!=='undefined';var weakMapExists=typeof WeakMap!=='undefined';var weakSetExists=typeof WeakSet!=='undefined';var dataViewExists=typeof DataView!=='undefined';var symbolIteratorExists=symbolExists&&typeof Symbol.iterator!=='undefined';var symbolToStringTagExists=symbolExists&&typeof Symbol.toStringTag!=='undefined';var setEntriesExists=setExists&&typeof Set.prototype.entries==='function';var mapEntriesExists=mapExists&&typeof Map.prototype.entries==='function';var setIteratorPrototype=setEntriesExists&&Object.getPrototypeOf(new Set().entries());var mapIteratorPrototype=mapEntriesExists&&Object.getPrototypeOf(new Map().entries());var arrayIteratorExists=symbolIteratorExists&&typeof Array.prototype[Symbol.iterator]==='function';var arrayIteratorPrototype=arrayIteratorExists&&Object.getPrototypeOf([][Symbol.iterator]());var stringIteratorExists=symbolIteratorExists&&typeof String.prototype[Symbol.iterator]==='function';var stringIteratorPrototype=stringIteratorExists&&Object.getPrototypeOf(''[Symbol.iterator]());var toStringLeftSliceLength=8;var toStringRightSliceLength=-1;/**
     * ### typeOf (obj)
     *
     * Uses \`Object.prototype.toString\` to determine the type of an object,
     * normalising behaviour across engine versions & well optimised.
     *
     * @param {Mixed} object
     * @return {String} object type
     * @api public
     */function typeDetect(obj){/* ! Speed optimisation
       * Pre:
       *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
       *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
       *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
       *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
       *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
       * Post:
       *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
       *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
       *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
       *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
       *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
       */var typeofObj=typeof obj;if(typeofObj!=='object'){return typeofObj;}/* ! Speed optimisation
       * Pre:
       *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
       * Post:
       *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
       */if(obj===null){return'null';}/* ! Spec Conformance
       * Test: \`Object.prototype.toString.call(window)\`\`
       *  - Node === "[object global]"
       *  - Chrome === "[object global]"
       *  - Firefox === "[object Window]"
       *  - PhantomJS === "[object Window]"
       *  - Safari === "[object Window]"
       *  - IE 11 === "[object Window]"
       *  - IE Edge === "[object Window]"
       * Test: \`Object.prototype.toString.call(this)\`\`
       *  - Chrome Worker === "[object global]"
       *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
       *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
       *  - IE 11 Worker === "[object WorkerGlobalScope]"
       *  - IE Edge Worker === "[object WorkerGlobalScope]"
       */if(obj===globalObject){return'global';}/* ! Speed optimisation
       * Pre:
       *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
       * Post:
       *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
       */if(Array.isArray(obj)&&(symbolToStringTagExists===false||!(Symbol.toStringTag in obj))){return'Array';}// Not caching existence of \`window\` and related properties due to potential
// for \`window\` to be unset before tests in quasi-browser environments.
if(typeof window==='object'&&window!==null){/* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/browsers.html#location)
         * WhatWG HTML$7.7.3 - The \`Location\` interface
         * Test: \`Object.prototype.toString.call(window.location)\`\`
         *  - IE <=11 === "[object Object]"
         *  - IE Edge <=13 === "[object Object]"
         */if(typeof window.location==='object'&&obj===window.location){return'Location';}/* ! Spec Conformance
         * (https://html.spec.whatwg.org/#document)
         * WhatWG HTML$3.1.1 - The \`Document\` object
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         *       WhatWG HTML states:
         *         > For historical reasons, Window objects must also have a
         *         > writable, configurable, non-enumerable property named
         *         > HTMLDocument whose value is the Document interface object.
         * Test: \`Object.prototype.toString.call(document)\`\`
         *  - Chrome === "[object HTMLDocument]"
         *  - Firefox === "[object HTMLDocument]"
         *  - Safari === "[object HTMLDocument]"
         *  - IE <=10 === "[object Document]"
         *  - IE 11 === "[object HTMLDocument]"
         *  - IE Edge <=13 === "[object HTMLDocument]"
         */if(typeof window.document==='object'&&obj===window.document){return'Document';}if(typeof window.navigator==='object'){/* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
           * Test: \`Object.prototype.toString.call(navigator.mimeTypes)\`\`
           *  - IE <=10 === "[object MSMimeTypesCollection]"
           */if(typeof window.navigator.mimeTypes==='object'&&obj===window.navigator.mimeTypes){return'MimeTypeArray';}/* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
           * Test: \`Object.prototype.toString.call(navigator.plugins)\`\`
           *  - IE <=10 === "[object MSPluginsCollection]"
           */if(typeof window.navigator.plugins==='object'&&obj===window.navigator.plugins){return'PluginArray';}}if((typeof window.HTMLElement==='function'||typeof window.HTMLElement==='object')&&obj instanceof window.HTMLElement){/* ! Spec Conformance
          * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
          * WhatWG HTML$4.4.4 - The \`blockquote\` element - Interface \`HTMLQuoteElement\`
          * Test: \`Object.prototype.toString.call(document.createElement('blockquote'))\`\`
          *  - IE <=10 === "[object HTMLBlockElement]"
          */if(obj.tagName==='BLOCKQUOTE'){return'HTMLQuoteElement';}/* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltabledatacellelement)
           * WhatWG HTML$4.9.9 - The \`td\` element - Interface \`HTMLTableDataCellElement\`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('td'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */if(obj.tagName==='TD'){return'HTMLTableDataCellElement';}/* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltableheadercellelement)
           * WhatWG HTML$4.9.9 - The \`td\` element - Interface \`HTMLTableHeaderCellElement\`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('th'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */if(obj.tagName==='TH'){return'HTMLTableHeaderCellElement';}}}/* ! Speed optimisation
      * Pre:
      *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
      *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
      *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
      *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
      *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
      *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
      *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
      *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
      *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
      * Post:
      *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
      *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
      *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
      *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
      *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
      *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
      *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
      *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
      *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
      */var stringTag=symbolToStringTagExists&&obj[Symbol.toStringTag];if(typeof stringTag==='string'){return stringTag;}var objPrototype=Object.getPrototypeOf(obj);/* ! Speed optimisation
      * Pre:
      *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
      *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
      * Post:
      *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
      *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
      */if(objPrototype===RegExp.prototype){return'RegExp';}/* ! Speed optimisation
      * Pre:
      *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
      * Post:
      *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
      */if(objPrototype===Date.prototype){return'Date';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
       * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
       * Test: \`Object.prototype.toString.call(Promise.resolve())\`\`
       *  - Chrome <=47 === "[object Object]"
       *  - Edge <=20 === "[object Object]"
       *  - Firefox 29-Latest === "[object Promise]"
       *  - Safari 7.1-Latest === "[object Promise]"
       */if(promiseExists&&objPrototype===Promise.prototype){return'Promise';}/* ! Speed optimisation
      * Pre:
      *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
      * Post:
      *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
      */if(setExists&&objPrototype===Set.prototype){return'Set';}/* ! Speed optimisation
      * Pre:
      *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
      * Post:
      *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
      */if(mapExists&&objPrototype===Map.prototype){return'Map';}/* ! Speed optimisation
      * Pre:
      *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
      * Post:
      *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
      */if(weakSetExists&&objPrototype===WeakSet.prototype){return'WeakSet';}/* ! Speed optimisation
      * Pre:
      *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
      * Post:
      *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
      */if(weakMapExists&&objPrototype===WeakMap.prototype){return'WeakMap';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
       * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
       * Test: \`Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))\`\`
       *  - Edge <=13 === "[object Object]"
       */if(dataViewExists&&objPrototype===DataView.prototype){return'DataView';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
       * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
       * Test: \`Object.prototype.toString.call(new Map().entries())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(mapExists&&objPrototype===mapIteratorPrototype){return'Map Iterator';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
       * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
       * Test: \`Object.prototype.toString.call(new Set().entries())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(setExists&&objPrototype===setIteratorPrototype){return'Set Iterator';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
       * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
       * Test: \`Object.prototype.toString.call([][Symbol.iterator]())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(arrayIteratorExists&&objPrototype===arrayIteratorPrototype){return'Array Iterator';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
       * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
       * Test: \`Object.prototype.toString.call(''[Symbol.iterator]())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(stringIteratorExists&&objPrototype===stringIteratorPrototype){return'String Iterator';}/* ! Speed optimisation
      * Pre:
      *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
      * Post:
      *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
      */if(objPrototype===null){return'Object';}return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength,toStringRightSliceLength);}return typeDetect;});})(typeDetect);var typeDetectExports=typeDetect.exports;var type=typeDetectExports;/**
 * Returns the lower-case result of running type from type-detect on the value
 *
 * @param  {*} value
 * @returns {string}
 */var typeOf=function typeOf(value){return type(value).toLowerCase();};/**
 * Returns a string representation of the value
 *
 * @param  {*} value
 * @returns {string}
 */function valueToString(value){if(value&&value.toString){// eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods
return value.toString();}return String(value);}var valueToString_1=valueToString;var lib={global:global$1,calledInOrder:calledInOrder_1,className:className_1,deprecated:deprecated,every:every,functionName:functionName$1,orderByFirstCall:orderByFirstCall_1,prototypes:prototypes,typeOf:typeOf,valueToString:valueToString_1};const globalObject=lib.global;let timersModule;if(typeof __vitest_required__!=='undefined'){try{timersModule=__vitest_required__.timers;}catch(e){// ignored
}}/**
 * @typedef {object} IdleDeadline
 * @property {boolean} didTimeout - whether or not the callback was called before reaching the optional timeout
 * @property {function():number} timeRemaining - a floating-point value providing an estimate of the number of milliseconds remaining in the current idle period
 */ /**
 * Queues a function to be called during a browser's idle periods
 *
 * @callback RequestIdleCallback
 * @param {function(IdleDeadline)} callback
 * @param {{timeout: number}} options - an options object
 * @returns {number} the id
 */ /**
 * @callback NextTick
 * @param {VoidVarArgsFunc} callback - the callback to run
 * @param {...*} arguments - optional arguments to call the callback with
 * @returns {void}
 */ /**
 * @callback SetImmediate
 * @param {VoidVarArgsFunc} callback - the callback to run
 * @param {...*} arguments - optional arguments to call the callback with
 * @returns {NodeImmediate}
 */ /**
 * @callback VoidVarArgsFunc
 * @param {...*} callback - the callback to run
 * @returns {void}
 */ /**
 * @typedef RequestAnimationFrame
 * @property {function(number):void} requestAnimationFrame
 * @returns {number} - the id
 */ /**
 * @typedef Performance
 * @property {function(): number} now
 */ /* eslint-disable jsdoc/require-property-description */ /**
 * @typedef {object} Clock
 * @property {number} now - the current time
 * @property {Date} Date - the Date constructor
 * @property {number} loopLimit - the maximum number of timers before assuming an infinite loop
 * @property {RequestIdleCallback} requestIdleCallback
 * @property {function(number):void} cancelIdleCallback
 * @property {setTimeout} setTimeout
 * @property {clearTimeout} clearTimeout
 * @property {NextTick} nextTick
 * @property {queueMicrotask} queueMicrotask
 * @property {setInterval} setInterval
 * @property {clearInterval} clearInterval
 * @property {SetImmediate} setImmediate
 * @property {function(NodeImmediate):void} clearImmediate
 * @property {function():number} countTimers
 * @property {RequestAnimationFrame} requestAnimationFrame
 * @property {function(number):void} cancelAnimationFrame
 * @property {function():void} runMicrotasks
 * @property {function(string | number): number} tick
 * @property {function(string | number): Promise<number>} tickAsync
 * @property {function(): number} next
 * @property {function(): Promise<number>} nextAsync
 * @property {function(): number} runAll
 * @property {function(): number} runToFrame
 * @property {function(): Promise<number>} runAllAsync
 * @property {function(): number} runToLast
 * @property {function(): Promise<number>} runToLastAsync
 * @property {function(): void} reset
 * @property {function(number | Date): void} setSystemTime
 * @property {function(number): void} jump
 * @property {Performance} performance
 * @property {function(number[]): number[]} hrtime - process.hrtime (legacy)
 * @property {function(): void} uninstall Uninstall the clock.
 * @property {Function[]} methods - the methods that are faked
 * @property {boolean} [shouldClearNativeTimers] inherited from config
 * @property {{methodName:string, original:any}[] | undefined} timersModuleMethods
 */ /* eslint-enable jsdoc/require-property-description */ /**
 * Configuration object for the \`install\` method.
 *
 * @typedef {object} Config
 * @property {number|Date} [now] a number (in milliseconds) or a Date object (default epoch)
 * @property {string[]} [toFake] names of the methods that should be faked.
 * @property {number} [loopLimit] the maximum number of timers that will be run when calling runAll()
 * @property {boolean} [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false)
 * @property {number} [advanceTimeDelta] increment mocked time every <<advanceTimeDelta>> ms (default: 20ms)
 * @property {boolean} [shouldClearNativeTimers] forwards clear timer calls to native functions if they are not fakes (default: false)
 */ /* eslint-disable jsdoc/require-property-description */ /**
 * The internal structure to describe a scheduled fake timer
 *
 * @typedef {object} Timer
 * @property {Function} func
 * @property {*[]} args
 * @property {number} delay
 * @property {number} callAt
 * @property {number} createdAt
 * @property {boolean} immediate
 * @property {number} id
 * @property {Error} [error]
 */ /**
 * A Node timer
 *
 * @typedef {object} NodeImmediate
 * @property {function(): boolean} hasRef
 * @property {function(): NodeImmediate} ref
 * @property {function(): NodeImmediate} unref
 */ /* eslint-enable jsdoc/require-property-description */ /* eslint-disable complexity */ /**
 * Mocks available features in the specified global namespace.
 *
 * @param {*} _global Namespace to mock (e.g. \`window\`)
 * @returns {FakeTimers}
 */function withGlobal(_global){const maxTimeout=Math.pow(2,31)-1;//see https://heycam.github.io/webidl/#abstract-opdef-converttoint
const idCounterStart=1e12;// arbitrarily large number to avoid collisions with native timer IDs
const NOOP=function(){return undefined;};const NOOP_ARRAY=function(){return[];};const timeoutResult=_global.setTimeout(NOOP,0);const addTimerReturnsObject=typeof timeoutResult==="object";const hrtimePresent=_global.process&&typeof _global.process.hrtime==="function";const hrtimeBigintPresent=hrtimePresent&&typeof _global.process.hrtime.bigint==="function";const nextTickPresent=_global.process&&typeof _global.process.nextTick==="function";const utilPromisify=_global.process&&_global.__vitest_required__&&_global.__vitest_required__.util.promisify;const performancePresent=_global.performance&&typeof _global.performance.now==="function";const hasPerformancePrototype=_global.Performance&&(typeof _global.Performance).match(/^(function|object)$/);const hasPerformanceConstructorPrototype=_global.performance&&_global.performance.constructor&&_global.performance.constructor.prototype;const queueMicrotaskPresent=_global.hasOwnProperty("queueMicrotask");const requestAnimationFramePresent=_global.requestAnimationFrame&&typeof _global.requestAnimationFrame==="function";const cancelAnimationFramePresent=_global.cancelAnimationFrame&&typeof _global.cancelAnimationFrame==="function";const requestIdleCallbackPresent=_global.requestIdleCallback&&typeof _global.requestIdleCallback==="function";const cancelIdleCallbackPresent=_global.cancelIdleCallback&&typeof _global.cancelIdleCallback==="function";const setImmediatePresent=_global.setImmediate&&typeof _global.setImmediate==="function";const intlPresent=_global.Intl&&typeof _global.Intl==="object";_global.clearTimeout(timeoutResult);const NativeDate=_global.Date;const NativeIntl=_global.Intl;let uniqueTimerId=idCounterStart;/**
   * @param {number} num
   * @returns {boolean}
   */function isNumberFinite(num){if(Number.isFinite){return Number.isFinite(num);}return isFinite(num);}let isNearInfiniteLimit=false;/**
   * @param {Clock} clock
   * @param {number} i
   */function checkIsNearInfiniteLimit(clock,i){if(clock.loopLimit&&i===clock.loopLimit-1){isNearInfiniteLimit=true;}}/**
   *
   */function resetIsNearInfiniteLimit(){isNearInfiniteLimit=false;}/**
   * Parse strings like "01:10:00" (meaning 1 hour, 10 minutes, 0 seconds) into
   * number of milliseconds. This is used to support human-readable strings passed
   * to clock.tick()
   *
   * @param {string} str
   * @returns {number}
   */function parseTime(str){if(!str){return 0;}const strings=str.split(":");const l=strings.length;let i=l;let ms=0;let parsed;if(l>3||!/^(\\d\\d:){0,2}\\d\\d?$/.test(str)){throw new Error("tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits");}while(i--){parsed=parseInt(strings[i],10);if(parsed>=60){throw new Error(\`Invalid time \${str}\`);}ms+=parsed*Math.pow(60,l-i-1);}return ms*1000;}/**
   * Get the decimal part of the millisecond value as nanoseconds
   *
   * @param {number} msFloat the number of milliseconds
   * @returns {number} an integer number of nanoseconds in the range [0,1e6)
   *
   * Example: nanoRemainer(123.456789) -> 456789
   */function nanoRemainder(msFloat){const modulo=1e6;const remainder=msFloat*1e6%modulo;const positiveRemainder=remainder<0?remainder+modulo:remainder;return Math.floor(positiveRemainder);}/**
   * Used to grok the \`now\` parameter to createClock.
   *
   * @param {Date|number} epoch the system time
   * @returns {number}
   */function getEpoch(epoch){if(!epoch){return 0;}if(typeof epoch.getTime==="function"){return epoch.getTime();}if(typeof epoch==="number"){return epoch;}throw new TypeError("now should be milliseconds since UNIX epoch");}/**
   * @param {number} from
   * @param {number} to
   * @param {Timer} timer
   * @returns {boolean}
   */function inRange(from,to,timer){return timer&&timer.callAt>=from&&timer.callAt<=to;}/**
   * @param {Clock} clock
   * @param {Timer} job
   */function getInfiniteLoopError(clock,job){const infiniteLoopError=new Error(\`Aborting after running \${clock.loopLimit} timers, assuming an infinite loop!\`);if(!job.error){return infiniteLoopError;}// pattern never matched in Node
const computedTargetPattern=/target\\.*[<|(|[].*?[>|\\]|)]\\s*/;let clockMethodPattern=new RegExp(String(Object.keys(clock).join("|")));if(addTimerReturnsObject){// node.js environment
clockMethodPattern=new RegExp(\`\\\\s+at (Object\\\\.)?(?:\${Object.keys(clock).join("|")})\\\\s+\`);}let matchedLineIndex=-1;job.error.stack.split("\\n").some(function(line,i){// If we've matched a computed target line (e.g. setTimeout) then we
// don't need to look any further. Return true to stop iterating.
const matchedComputedTarget=line.match(computedTargetPattern);/* istanbul ignore if */if(matchedComputedTarget){matchedLineIndex=i;return true;}// If we've matched a clock method line, then there may still be
// others further down the trace. Return false to keep iterating.
const matchedClockMethod=line.match(clockMethodPattern);if(matchedClockMethod){matchedLineIndex=i;return false;}// If we haven't matched anything on this line, but we matched
// previously and set the matched line index, then we can stop.
// If we haven't matched previously, then we should keep iterating.
return matchedLineIndex>=0;});const stack=\`\${infiniteLoopError}\\n\${job.type||"Microtask"} - \${job.func.name||"anonymous"}\\n\${job.error.stack.split("\\n").slice(matchedLineIndex+1).join("\\n")}\`;try{Object.defineProperty(infiniteLoopError,"stack",{value:stack});}catch(e){// noop
}return infiniteLoopError;}/**
   * @param {Date} target
   * @param {Date} source
   * @returns {Date} the target after modifications
   */function mirrorDateProperties(target,source){let prop;for(prop in source){if(source.hasOwnProperty(prop)){target[prop]=source[prop];}}// set special now implementation
if(source.now){target.now=function now(){return target.clock.now;};}else{delete target.now;}// set special toSource implementation
if(source.toSource){target.toSource=function toSource(){return source.toSource();};}else{delete target.toSource;}// set special toString implementation
target.toString=function toString(){return source.toString();};target.prototype=source.prototype;target.parse=source.parse;target.UTC=source.UTC;target.prototype.toUTCString=source.prototype.toUTCString;target.isFake=true;return target;}//eslint-disable-next-line jsdoc/require-jsdoc
function createDate(){/**
     * @param {number} year
     * @param {number} month
     * @param {number} date
     * @param {number} hour
     * @param {number} minute
     * @param {number} second
     * @param {number} ms
     * @returns {Date}
     */function ClockDate(year,month,date,hour,minute,second,ms){// the Date constructor called as a function, ref Ecma-262 Edition 5.1, section 15.9.2.
// This remains so in the 10th edition of 2019 as well.
if(!(this instanceof ClockDate)){return new NativeDate(ClockDate.clock.now).toString();}// if Date is called as a constructor with 'new' keyword
// Defensive and verbose to avoid potential harm in passing
// explicit undefined when user does not pass argument
switch(arguments.length){case 0:return new NativeDate(ClockDate.clock.now);case 1:return new NativeDate(year);case 2:return new NativeDate(year,month);case 3:return new NativeDate(year,month,date);case 4:return new NativeDate(year,month,date,hour);case 5:return new NativeDate(year,month,date,hour,minute);case 6:return new NativeDate(year,month,date,hour,minute,second);default:return new NativeDate(year,month,date,hour,minute,second,ms);}}return mirrorDateProperties(ClockDate,NativeDate);}//eslint-disable-next-line jsdoc/require-jsdoc
function createIntl(){const ClockIntl=_objectSpread({},NativeIntl);ClockIntl.DateTimeFormat=function(...args){const realFormatter=new NativeIntl.DateTimeFormat(...args);const formatter={};["formatRange","formatRangeToParts","resolvedOptions"].forEach(method=>{formatter[method]=realFormatter[method].bind(realFormatter);});["format","formatToParts"].forEach(method=>{formatter[method]=function(date){return realFormatter[method](date||ClockIntl.clock.now);};});return formatter;};ClockIntl.DateTimeFormat.prototype=Object.create(NativeIntl.DateTimeFormat.prototype);ClockIntl.DateTimeFormat.supportedLocalesOf=NativeIntl.DateTimeFormat.supportedLocalesOf;return ClockIntl;}//eslint-disable-next-line jsdoc/require-jsdoc
function enqueueJob(clock,job){// enqueues a microtick-deferred task - ecma262/#sec-enqueuejob
if(!clock.jobs){clock.jobs=[];}clock.jobs.push(job);}//eslint-disable-next-line jsdoc/require-jsdoc
function runJobs(clock){// runs all microtick-deferred tasks - ecma262/#sec-runjobs
if(!clock.jobs){return;}for(let i=0;i<clock.jobs.length;i++){const job=clock.jobs[i];job.func.apply(null,job.args);checkIsNearInfiniteLimit(clock,i);if(clock.loopLimit&&i>clock.loopLimit){throw getInfiniteLoopError(clock,job);}}resetIsNearInfiniteLimit();clock.jobs=[];}/**
   * @param {Clock} clock
   * @param {Timer} timer
   * @returns {number} id of the created timer
   */function addTimer(clock,timer){if(timer.func===undefined){throw new Error("Callback must be provided to timer calls");}if(addTimerReturnsObject){// Node.js environment
if(typeof timer.func!=="function"){throw new TypeError(\`[ERR_INVALID_CALLBACK]: Callback must be a function. Received \${timer.func} of type \${typeof timer.func}\`);}}if(isNearInfiniteLimit){timer.error=new Error();}timer.type=timer.immediate?"Immediate":"Timeout";if(timer.hasOwnProperty("delay")){if(typeof timer.delay!=="number"){timer.delay=parseInt(timer.delay,10);}if(!isNumberFinite(timer.delay)){timer.delay=0;}timer.delay=timer.delay>maxTimeout?1:timer.delay;timer.delay=Math.max(0,timer.delay);}if(timer.hasOwnProperty("interval")){timer.type="Interval";timer.interval=timer.interval>maxTimeout?1:timer.interval;}if(timer.hasOwnProperty("animation")){timer.type="AnimationFrame";timer.animation=true;}if(timer.hasOwnProperty("idleCallback")){timer.type="IdleCallback";timer.idleCallback=true;}if(!clock.timers){clock.timers={};}timer.id=uniqueTimerId++;timer.createdAt=clock.now;timer.callAt=clock.now+(parseInt(timer.delay)||(clock.duringTick?1:0));clock.timers[timer.id]=timer;if(addTimerReturnsObject){const res={refed:true,ref:function(){this.refed=true;return res;},unref:function(){this.refed=false;return res;},hasRef:function(){return this.refed;},refresh:function(){timer.callAt=clock.now+(parseInt(timer.delay)||(clock.duringTick?1:0));// it _might_ have been removed, but if not the assignment is perfectly fine
clock.timers[timer.id]=timer;return res;},[Symbol.toPrimitive]:function(){return timer.id;}};return res;}return timer.id;}/* eslint consistent-return: "off" */ /**
   * Timer comparitor
   *
   * @param {Timer} a
   * @param {Timer} b
   * @returns {number}
   */function compareTimers(a,b){// Sort first by absolute timing
if(a.callAt<b.callAt){return-1;}if(a.callAt>b.callAt){return 1;}// Sort next by immediate, immediate timers take precedence
if(a.immediate&&!b.immediate){return-1;}if(!a.immediate&&b.immediate){return 1;}// Sort next by creation time, earlier-created timers take precedence
if(a.createdAt<b.createdAt){return-1;}if(a.createdAt>b.createdAt){return 1;}// Sort next by id, lower-id timers take precedence
if(a.id<b.id){return-1;}if(a.id>b.id){return 1;}// As timer ids are unique, no fallback \`0\` is necessary
}/**
   * @param {Clock} clock
   * @param {number} from
   * @param {number} to
   * @returns {Timer}
   */function firstTimerInRange(clock,from,to){const timers=clock.timers;let timer=null;let id,isInRange;for(id in timers){if(timers.hasOwnProperty(id)){isInRange=inRange(from,to,timers[id]);if(isInRange&&(!timer||compareTimers(timer,timers[id])===1)){timer=timers[id];}}}return timer;}/**
   * @param {Clock} clock
   * @returns {Timer}
   */function firstTimer(clock){const timers=clock.timers;let timer=null;let id;for(id in timers){if(timers.hasOwnProperty(id)){if(!timer||compareTimers(timer,timers[id])===1){timer=timers[id];}}}return timer;}/**
   * @param {Clock} clock
   * @returns {Timer}
   */function lastTimer(clock){const timers=clock.timers;let timer=null;let id;for(id in timers){if(timers.hasOwnProperty(id)){if(!timer||compareTimers(timer,timers[id])===-1){timer=timers[id];}}}return timer;}/**
   * @param {Clock} clock
   * @param {Timer} timer
   */function callTimer(clock,timer){if(typeof timer.interval==="number"){clock.timers[timer.id].callAt+=timer.interval;}else{delete clock.timers[timer.id];}if(typeof timer.func==="function"){timer.func.apply(null,timer.args);}else{/* eslint no-eval: "off" */const eval2=eval;(function(){eval2(timer.func);})();}}/**
   * Gets clear handler name for a given timer type
   *
   * @param {string} ttype
   */function getClearHandler(ttype){if(ttype==="IdleCallback"||ttype==="AnimationFrame"){return\`cancel\${ttype}\`;}return\`clear\${ttype}\`;}/**
   * Gets schedule handler name for a given timer type
   *
   * @param {string} ttype
   */function getScheduleHandler(ttype){if(ttype==="IdleCallback"||ttype==="AnimationFrame"){return\`request\${ttype}\`;}return\`set\${ttype}\`;}/**
   * Creates an anonymous function to warn only once
   */function createWarnOnce(){let calls=0;return function(msg){// eslint-disable-next-line
!calls++&&console.warn(msg);};}const warnOnce=createWarnOnce();/**
   * @param {Clock} clock
   * @param {number} timerId
   * @param {string} ttype
   */function clearTimer(clock,timerId,ttype){if(!timerId){// null appears to be allowed in most browsers, and appears to be
// relied upon by some libraries, like Bootstrap carousel
return;}if(!clock.timers){clock.timers={};}// in Node, the ID is stored as the primitive value for \`Timeout\` objects
// for \`Immediate\` objects, no ID exists, so it gets coerced to NaN
const id=Number(timerId);if(Number.isNaN(id)||id<idCounterStart){const handlerName=getClearHandler(ttype);if(clock.shouldClearNativeTimers===true){const nativeHandler=clock[\`_\${handlerName}\`];return typeof nativeHandler==="function"?nativeHandler(timerId):undefined;}warnOnce(\`FakeTimers: \${handlerName} was invoked to clear a native timer instead of one created by this library.\`+"\\nTo automatically clean-up native timers, use \`shouldClearNativeTimers\`.");}if(clock.timers.hasOwnProperty(id)){// check that the ID matches a timer of the correct type
const timer=clock.timers[id];if(timer.type===ttype||timer.type==="Timeout"&&ttype==="Interval"||timer.type==="Interval"&&ttype==="Timeout"){delete clock.timers[id];}else{const clear=getClearHandler(ttype);const schedule=getScheduleHandler(timer.type);throw new Error(\`Cannot clear timer: timer created with \${schedule}() but cleared with \${clear}()\`);}}}/**
   * @param {Clock} clock
   * @param {Config} config
   * @returns {Timer[]}
   */function uninstall(clock,config){let method,i,l;const installedHrTime="_hrtime";const installedNextTick="_nextTick";for(i=0,l=clock.methods.length;i<l;i++){method=clock.methods[i];if(method==="hrtime"&&_global.process){_global.process.hrtime=clock[installedHrTime];}else if(method==="nextTick"&&_global.process){_global.process.nextTick=clock[installedNextTick];}else if(method==="performance"){const originalPerfDescriptor=Object.getOwnPropertyDescriptor(clock,\`_\${method}\`);if(originalPerfDescriptor&&originalPerfDescriptor.get&&!originalPerfDescriptor.set){Object.defineProperty(_global,method,originalPerfDescriptor);}else if(originalPerfDescriptor.configurable){_global[method]=clock[\`_\${method}\`];}}else{if(_global[method]&&_global[method].hadOwnProperty){_global[method]=clock[\`_\${method}\`];}else{try{delete _global[method];}catch(ignore){/* eslint no-empty: "off" */}}}if(clock.timersModuleMethods!==undefined){for(let j=0;j<clock.timersModuleMethods.length;j++){const entry=clock.timersModuleMethods[j];timersModule[entry.methodName]=entry.original;}}}if(config.shouldAdvanceTime===true){_global.clearInterval(clock.attachedInterval);}// Prevent multiple executions which will completely remove these props
clock.methods=[];// return pending timers, to enable checking what timers remained on uninstall
if(!clock.timers){return[];}return Object.keys(clock.timers).map(function mapper(key){return clock.timers[key];});}/**
   * @param {object} target the target containing the method to replace
   * @param {string} method the keyname of the method on the target
   * @param {Clock} clock
   */function hijackMethod(target,method,clock){clock[method].hadOwnProperty=Object.prototype.hasOwnProperty.call(target,method);clock[\`_\${method}\`]=target[method];if(method==="Date"){const date=mirrorDateProperties(clock[method],target[method]);target[method]=date;}else if(method==="Intl"){target[method]=clock[method];}else if(method==="performance"){const originalPerfDescriptor=Object.getOwnPropertyDescriptor(target,method);// JSDOM has a read only performance field so we have to save/copy it differently
if(originalPerfDescriptor&&originalPerfDescriptor.get&&!originalPerfDescriptor.set){Object.defineProperty(clock,\`_\${method}\`,originalPerfDescriptor);const perfDescriptor=Object.getOwnPropertyDescriptor(clock,method);Object.defineProperty(target,method,perfDescriptor);}else{target[method]=clock[method];}}else{target[method]=function(){return clock[method].apply(clock,arguments);};Object.defineProperties(target[method],Object.getOwnPropertyDescriptors(clock[method]));}target[method].clock=clock;}/**
   * @param {Clock} clock
   * @param {number} advanceTimeDelta
   */function doIntervalTick(clock,advanceTimeDelta){clock.tick(advanceTimeDelta);}/**
   * @typedef {object} Timers
   * @property {setTimeout} setTimeout
   * @property {clearTimeout} clearTimeout
   * @property {setInterval} setInterval
   * @property {clearInterval} clearInterval
   * @property {Date} Date
   * @property {Intl} Intl
   * @property {SetImmediate=} setImmediate
   * @property {function(NodeImmediate): void=} clearImmediate
   * @property {function(number[]):number[]=} hrtime
   * @property {NextTick=} nextTick
   * @property {Performance=} performance
   * @property {RequestAnimationFrame=} requestAnimationFrame
   * @property {boolean=} queueMicrotask
   * @property {function(number): void=} cancelAnimationFrame
   * @property {RequestIdleCallback=} requestIdleCallback
   * @property {function(number): void=} cancelIdleCallback
   */ /** @type {Timers} */const timers={setTimeout:_global.setTimeout,clearTimeout:_global.clearTimeout,setInterval:_global.setInterval,clearInterval:_global.clearInterval,Date:_global.Date};if(setImmediatePresent){timers.setImmediate=_global.setImmediate;timers.clearImmediate=_global.clearImmediate;}if(hrtimePresent){timers.hrtime=_global.process.hrtime;}if(nextTickPresent){timers.nextTick=_global.process.nextTick;}if(performancePresent){timers.performance=_global.performance;}if(requestAnimationFramePresent){timers.requestAnimationFrame=_global.requestAnimationFrame;}if(queueMicrotaskPresent){timers.queueMicrotask=true;}if(cancelAnimationFramePresent){timers.cancelAnimationFrame=_global.cancelAnimationFrame;}if(requestIdleCallbackPresent){timers.requestIdleCallback=_global.requestIdleCallback;}if(cancelIdleCallbackPresent){timers.cancelIdleCallback=_global.cancelIdleCallback;}if(intlPresent){timers.Intl=_global.Intl;}const originalSetTimeout=_global.setImmediate||_global.setTimeout;/**
   * @param {Date|number} [start] the system time - non-integer values are floored
   * @param {number} [loopLimit] maximum number of timers that will be run when calling runAll()
   * @returns {Clock}
   */function createClock(start,loopLimit){// eslint-disable-next-line no-param-reassign
start=Math.floor(getEpoch(start));// eslint-disable-next-line no-param-reassign
loopLimit=loopLimit||1000;let nanos=0;const adjustedSystemTime=[0,0];// [millis, nanoremainder]
if(NativeDate===undefined){throw new Error("The global scope doesn't have a \`Date\` object"+" (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)");}const clock={now:start,Date:createDate(),loopLimit:loopLimit};clock.Date.clock=clock;//eslint-disable-next-line jsdoc/require-jsdoc
function getTimeToNextFrame(){return 16-(clock.now-start)%16;}//eslint-disable-next-line jsdoc/require-jsdoc
function hrtime(prev){const millisSinceStart=clock.now-adjustedSystemTime[0]-start;const secsSinceStart=Math.floor(millisSinceStart/1000);const remainderInNanos=(millisSinceStart-secsSinceStart*1e3)*1e6+nanos-adjustedSystemTime[1];if(Array.isArray(prev)){if(prev[1]>1e9){throw new TypeError("Number of nanoseconds can't exceed a billion");}const oldSecs=prev[0];let nanoDiff=remainderInNanos-prev[1];let secDiff=secsSinceStart-oldSecs;if(nanoDiff<0){nanoDiff+=1e9;secDiff-=1;}return[secDiff,nanoDiff];}return[secsSinceStart,remainderInNanos];}function fakePerformanceNow(){const hrt=hrtime();const millis=hrt[0]*1000+hrt[1]/1e6;return millis;}if(hrtimeBigintPresent){hrtime.bigint=function(){const parts=hrtime();return BigInt(parts[0])*BigInt(1e9)+BigInt(parts[1]);// eslint-disable-line
};}if(intlPresent){clock.Intl=createIntl();clock.Intl.clock=clock;}clock.requestIdleCallback=function requestIdleCallback(func,timeout){let timeToNextIdlePeriod=0;if(clock.countTimers()>0){timeToNextIdlePeriod=50;// const for now
}const result=addTimer(clock,{func:func,args:Array.prototype.slice.call(arguments,2),delay:typeof timeout==="undefined"?timeToNextIdlePeriod:Math.min(timeout,timeToNextIdlePeriod),idleCallback:true});return Number(result);};clock.cancelIdleCallback=function cancelIdleCallback(timerId){return clearTimer(clock,timerId,"IdleCallback");};clock.setTimeout=function setTimeout(func,timeout){return addTimer(clock,{func:func,args:Array.prototype.slice.call(arguments,2),delay:timeout});};if(typeof _global.Promise!=="undefined"&&utilPromisify){clock.setTimeout[utilPromisify.custom]=function promisifiedSetTimeout(timeout,arg){return new _global.Promise(function setTimeoutExecutor(resolve){addTimer(clock,{func:resolve,args:[arg],delay:timeout});});};}clock.clearTimeout=function clearTimeout(timerId){return clearTimer(clock,timerId,"Timeout");};clock.nextTick=function nextTick(func){return enqueueJob(clock,{func:func,args:Array.prototype.slice.call(arguments,1),error:isNearInfiniteLimit?new Error():null});};clock.queueMicrotask=function queueMicrotask(func){return clock.nextTick(func);// explicitly drop additional arguments
};clock.setInterval=function setInterval(func,timeout){// eslint-disable-next-line no-param-reassign
timeout=parseInt(timeout,10);return addTimer(clock,{func:func,args:Array.prototype.slice.call(arguments,2),delay:timeout,interval:timeout});};clock.clearInterval=function clearInterval(timerId){return clearTimer(clock,timerId,"Interval");};if(setImmediatePresent){clock.setImmediate=function setImmediate(func){return addTimer(clock,{func:func,args:Array.prototype.slice.call(arguments,1),immediate:true});};if(typeof _global.Promise!=="undefined"&&utilPromisify){clock.setImmediate[utilPromisify.custom]=function promisifiedSetImmediate(arg){return new _global.Promise(function setImmediateExecutor(resolve){addTimer(clock,{func:resolve,args:[arg],immediate:true});});};}clock.clearImmediate=function clearImmediate(timerId){return clearTimer(clock,timerId,"Immediate");};}clock.countTimers=function countTimers(){return Object.keys(clock.timers||{}).length+(clock.jobs||[]).length;};clock.requestAnimationFrame=function requestAnimationFrame(func){const result=addTimer(clock,{func:func,delay:getTimeToNextFrame(),get args(){return[fakePerformanceNow()];},animation:true});return Number(result);};clock.cancelAnimationFrame=function cancelAnimationFrame(timerId){return clearTimer(clock,timerId,"AnimationFrame");};clock.runMicrotasks=function runMicrotasks(){runJobs(clock);};/**
     * @param {number|string} tickValue milliseconds or a string parseable by parseTime
     * @param {boolean} isAsync
     * @param {Function} resolve
     * @param {Function} reject
     * @returns {number|undefined} will return the new \`now\` value or nothing for async
     */function doTick(tickValue,isAsync,resolve,reject){const msFloat=typeof tickValue==="number"?tickValue:parseTime(tickValue);const ms=Math.floor(msFloat);const remainder=nanoRemainder(msFloat);let nanosTotal=nanos+remainder;let tickTo=clock.now+ms;if(msFloat<0){throw new TypeError("Negative ticks are not supported");}// adjust for positive overflow
if(nanosTotal>=1e6){tickTo+=1;nanosTotal-=1e6;}nanos=nanosTotal;let tickFrom=clock.now;let previous=clock.now;// ESLint fails to detect this correctly
/* eslint-disable prefer-const */let timer,firstException,oldNow,nextPromiseTick,compensationCheck,postTimerCall;/* eslint-enable prefer-const */clock.duringTick=true;// perform microtasks
oldNow=clock.now;runJobs(clock);if(oldNow!==clock.now){// compensate for any setSystemTime() call during microtask callback
tickFrom+=clock.now-oldNow;tickTo+=clock.now-oldNow;}//eslint-disable-next-line jsdoc/require-jsdoc
function doTickInner(){// perform each timer in the requested range
timer=firstTimerInRange(clock,tickFrom,tickTo);// eslint-disable-next-line no-unmodified-loop-condition
while(timer&&tickFrom<=tickTo){if(clock.timers[timer.id]){tickFrom=timer.callAt;clock.now=timer.callAt;oldNow=clock.now;try{runJobs(clock);callTimer(clock,timer);}catch(e){firstException=firstException||e;}if(isAsync){// finish up after native setImmediate callback to allow
// all native es6 promises to process their callbacks after
// each timer fires.
originalSetTimeout(nextPromiseTick);return;}compensationCheck();}postTimerCall();}// perform process.nextTick()s again
oldNow=clock.now;runJobs(clock);if(oldNow!==clock.now){// compensate for any setSystemTime() call during process.nextTick() callback
tickFrom+=clock.now-oldNow;tickTo+=clock.now-oldNow;}clock.duringTick=false;// corner case: during runJobs new timers were scheduled which could be in the range [clock.now, tickTo]
timer=firstTimerInRange(clock,tickFrom,tickTo);if(timer){try{clock.tick(tickTo-clock.now);// do it all again - for the remainder of the requested range
}catch(e){firstException=firstException||e;}}else{// no timers remaining in the requested range: move the clock all the way to the end
clock.now=tickTo;// update nanos
nanos=nanosTotal;}if(firstException){throw firstException;}if(isAsync){resolve(clock.now);}else{return clock.now;}}nextPromiseTick=isAsync&&function(){try{compensationCheck();postTimerCall();doTickInner();}catch(e){reject(e);}};compensationCheck=function(){// compensate for any setSystemTime() call during timer callback
if(oldNow!==clock.now){tickFrom+=clock.now-oldNow;tickTo+=clock.now-oldNow;previous+=clock.now-oldNow;}};postTimerCall=function(){timer=firstTimerInRange(clock,previous,tickTo);previous=tickFrom;};return doTickInner();}/**
     * @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
     * @returns {number} will return the new \`now\` value
     */clock.tick=function tick(tickValue){return doTick(tickValue,false);};if(typeof _global.Promise!=="undefined"){/**
       * @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
       * @returns {Promise}
       */clock.tickAsync=function tickAsync(tickValue){return new _global.Promise(function(resolve,reject){originalSetTimeout(function(){try{doTick(tickValue,true,resolve,reject);}catch(e){reject(e);}});});};}clock.next=function next(){runJobs(clock);const timer=firstTimer(clock);if(!timer){return clock.now;}clock.duringTick=true;try{clock.now=timer.callAt;callTimer(clock,timer);runJobs(clock);return clock.now;}finally{clock.duringTick=false;}};if(typeof _global.Promise!=="undefined"){clock.nextAsync=function nextAsync(){return new _global.Promise(function(resolve,reject){originalSetTimeout(function(){try{const timer=firstTimer(clock);if(!timer){resolve(clock.now);return;}let err;clock.duringTick=true;clock.now=timer.callAt;try{callTimer(clock,timer);}catch(e){err=e;}clock.duringTick=false;originalSetTimeout(function(){if(err){reject(err);}else{resolve(clock.now);}});}catch(e){reject(e);}});});};}clock.runAll=function runAll(){let numTimers,i;runJobs(clock);for(i=0;i<clock.loopLimit;i++){if(!clock.timers){resetIsNearInfiniteLimit();return clock.now;}numTimers=Object.keys(clock.timers).length;if(numTimers===0){resetIsNearInfiniteLimit();return clock.now;}clock.next();checkIsNearInfiniteLimit(clock,i);}const excessJob=firstTimer(clock);throw getInfiniteLoopError(clock,excessJob);};clock.runToFrame=function runToFrame(){return clock.tick(getTimeToNextFrame());};if(typeof _global.Promise!=="undefined"){clock.runAllAsync=function runAllAsync(){return new _global.Promise(function(resolve,reject){let i=0;/**
           *
           */function doRun(){originalSetTimeout(function(){try{let numTimers;if(i<clock.loopLimit){if(!clock.timers){resetIsNearInfiniteLimit();resolve(clock.now);return;}numTimers=Object.keys(clock.timers).length;if(numTimers===0){resetIsNearInfiniteLimit();resolve(clock.now);return;}clock.next();i++;doRun();checkIsNearInfiniteLimit(clock,i);return;}const excessJob=firstTimer(clock);reject(getInfiniteLoopError(clock,excessJob));}catch(e){reject(e);}});}doRun();});};}clock.runToLast=function runToLast(){const timer=lastTimer(clock);if(!timer){runJobs(clock);return clock.now;}return clock.tick(timer.callAt-clock.now);};if(typeof _global.Promise!=="undefined"){clock.runToLastAsync=function runToLastAsync(){return new _global.Promise(function(resolve,reject){originalSetTimeout(function(){try{const timer=lastTimer(clock);if(!timer){resolve(clock.now);}resolve(clock.tickAsync(timer.callAt-clock.now));}catch(e){reject(e);}});});};}clock.reset=function reset(){nanos=0;clock.timers={};clock.jobs=[];clock.now=start;};clock.setSystemTime=function setSystemTime(systemTime){// determine time difference
const newNow=getEpoch(systemTime);const difference=newNow-clock.now;let id,timer;adjustedSystemTime[0]=adjustedSystemTime[0]+difference;adjustedSystemTime[1]=adjustedSystemTime[1]+nanos;// update 'system clock'
clock.now=newNow;nanos=0;// update timers and intervals to keep them stable
for(id in clock.timers){if(clock.timers.hasOwnProperty(id)){timer=clock.timers[id];timer.createdAt+=difference;timer.callAt+=difference;}}};/**
     * @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
     * @returns {number} will return the new \`now\` value
     */clock.jump=function jump(tickValue){const msFloat=typeof tickValue==="number"?tickValue:parseTime(tickValue);const ms=Math.floor(msFloat);for(const timer of Object.values(clock.timers)){if(clock.now+ms>timer.callAt){timer.callAt=clock.now+ms;}}clock.tick(ms);};if(performancePresent){clock.performance=Object.create(null);clock.performance.now=fakePerformanceNow;}if(hrtimePresent){clock.hrtime=hrtime;}return clock;}/* eslint-disable complexity */ /**
   * @param {Config=} [config] Optional config
   * @returns {Clock}
   */function install(config){if(arguments.length>1||config instanceof Date||Array.isArray(config)||typeof config==="number"){throw new TypeError(\`FakeTimers.install called with \${String(config)} install requires an object parameter\`);}if(_global.Date.isFake===true){// Timers are already faked; this is a problem.
// Make the user reset timers before continuing.
throw new TypeError("Can't install fake timers twice on the same global object.");}// eslint-disable-next-line no-param-reassign
config=typeof config!=="undefined"?config:{};config.shouldAdvanceTime=config.shouldAdvanceTime||false;config.advanceTimeDelta=config.advanceTimeDelta||20;config.shouldClearNativeTimers=config.shouldClearNativeTimers||false;if(config.target){throw new TypeError("config.target is no longer supported. Use \`withGlobal(target)\` instead.");}let i,l;const clock=createClock(config.now,config.loopLimit);clock.shouldClearNativeTimers=config.shouldClearNativeTimers;clock.uninstall=function(){return uninstall(clock,config);};clock.methods=config.toFake||[];if(clock.methods.length===0){// do not fake nextTick by default - GitHub#126
clock.methods=Object.keys(timers).filter(function(key){return key!=="nextTick"&&key!=="queueMicrotask";});}if(config.shouldAdvanceTime===true){const intervalTick=doIntervalTick.bind(null,clock,config.advanceTimeDelta);const intervalId=_global.setInterval(intervalTick,config.advanceTimeDelta);clock.attachedInterval=intervalId;}if(clock.methods.includes("performance")){const proto=(()=>{if(hasPerformanceConstructorPrototype){return _global.performance.constructor.prototype;}if(hasPerformancePrototype){return _global.Performance.prototype;}})();if(proto){Object.getOwnPropertyNames(proto).forEach(function(name){if(name!=="now"){clock.performance[name]=name.indexOf("getEntries")===0?NOOP_ARRAY:NOOP;}});}else if((config.toFake||[]).includes("performance")){// user explicitly tried to fake performance when not present
throw new ReferenceError("non-existent performance object cannot be faked");}}if(_global===globalObject&&timersModule){clock.timersModuleMethods=[];}for(i=0,l=clock.methods.length;i<l;i++){const nameOfMethodToReplace=clock.methods[i];if(nameOfMethodToReplace==="hrtime"){if(_global.process&&typeof _global.process.hrtime==="function"){hijackMethod(_global.process,nameOfMethodToReplace,clock);}}else if(nameOfMethodToReplace==="nextTick"){if(_global.process&&typeof _global.process.nextTick==="function"){hijackMethod(_global.process,nameOfMethodToReplace,clock);}}else{hijackMethod(_global,nameOfMethodToReplace,clock);}if(clock.timersModuleMethods!==undefined&&timersModule[nameOfMethodToReplace]){const original=timersModule[nameOfMethodToReplace];clock.timersModuleMethods.push({methodName:nameOfMethodToReplace,original:original});timersModule[nameOfMethodToReplace]=_global[nameOfMethodToReplace];}}return clock;}/* eslint-enable complexity */return{timers:timers,createClock:createClock,install:install,withGlobal:withGlobal};}/**
 * @typedef {object} FakeTimers
 * @property {Timers} timers
 * @property {createClock} createClock
 * @property {Function} install
 * @property {withGlobal} withGlobal
 */ /* eslint-enable complexity */ /** @type {FakeTimers} */const defaultImplementation=withGlobal(globalObject);defaultImplementation.timers;defaultImplementation.createClock;defaultImplementation.install;var withGlobal_1=withGlobal;class FakeTimers{_global;_clock;_fakingTime;_fakingDate;_fakeTimers;_userConfig;_now=RealDate.now;constructor({global,config}){this._userConfig=config;this._fakingDate=false;this._fakingTime=false;this._fakeTimers=withGlobal_1(global);this._global=global;}clearAllTimers(){if(this._fakingTime)this._clock.reset();}dispose(){this.useRealTimers();}runAllTimers(){if(this._checkFakeTimers())this._clock.runAll();}async runAllTimersAsync(){if(this._checkFakeTimers())await this._clock.runAllAsync();}runOnlyPendingTimers(){if(this._checkFakeTimers())this._clock.runToLast();}async runOnlyPendingTimersAsync(){if(this._checkFakeTimers())await this._clock.runToLastAsync();}advanceTimersToNextTimer(steps=1){if(this._checkFakeTimers()){for(let i=steps;i>0;i--){this._clock.next();this._clock.tick(0);if(this._clock.countTimers()===0)break;}}}async advanceTimersToNextTimerAsync(steps=1){if(this._checkFakeTimers()){for(let i=steps;i>0;i--){await this._clock.nextAsync();this._clock.tick(0);if(this._clock.countTimers()===0)break;}}}advanceTimersByTime(msToRun){if(this._checkFakeTimers())this._clock.tick(msToRun);}async advanceTimersByTimeAsync(msToRun){if(this._checkFakeTimers())await this._clock.tickAsync(msToRun);}runAllTicks(){if(this._checkFakeTimers()){this._clock.runMicrotasks();}}useRealTimers(){if(this._fakingDate){resetDate();this._fakingDate=false;}if(this._fakingTime){this._clock.uninstall();this._fakingTime=false;}}useFakeTimers(){var _a,_b,_c;if(this._fakingDate){throw new Error('"setSystemTime" was called already and date was mocked. Reset timers using \`vi.useRealTimers()\` if you want to use fake timers again.');}if(!this._fakingTime){const toFake=Object.keys(this._fakeTimers.timers).filter(timer=>timer!=="nextTick");if(((_b=(_a=this._userConfig)==null?void 0:_a.toFake)==null?void 0:_b.includes("nextTick"))&&isChildProcess())throw new Error("process.nextTick cannot be mocked inside child_process");const existingFakedMethods=(((_c=this._userConfig)==null?void 0:_c.toFake)||toFake).filter(method=>{switch(method){case"setImmediate":case"clearImmediate":return method in this._global&&this._global[method];default:return true;}});this._clock=this._fakeTimers.install(_objectSpread(_objectSpread({now:Date.now()},this._userConfig),{},{toFake:existingFakedMethods}));this._fakingTime=true;}}reset(){if(this._checkFakeTimers()){const now=this._clock.now;this._clock.reset();this._clock.setSystemTime(now);}}setSystemTime(now){if(this._fakingTime){this._clock.setSystemTime(now);}else{mockDate(now??this.getRealSystemTime());this._fakingDate=true;}}getRealSystemTime(){return this._now();}getTimerCount(){if(this._checkFakeTimers())return this._clock.countTimers();return 0;}configure(config){this._userConfig=config;}isFakeTimers(){return this._fakingTime;}_checkFakeTimers(){if(!this._fakingTime){throw new Error('Timers are not mocked. Try calling "vi.useFakeTimers()" first.');}return this._fakingTime;}}function copyStackTrace(target,source){if(source.stack!==void 0)target.stack=source.stack.replace(source.message,target.message);return target;}function waitFor(callback,options={}){const _getSafeTimers3=getSafeTimers(),setTimeout=_getSafeTimers3.setTimeout,setInterval=_getSafeTimers3.setInterval,clearTimeout=_getSafeTimers3.clearTimeout,clearInterval=_getSafeTimers3.clearInterval;const _ref12=typeof options==="number"?{timeout:options}:options,_ref12$interval=_ref12.interval,interval=_ref12$interval===void 0?50:_ref12$interval,_ref12$timeout=_ref12.timeout,timeout=_ref12$timeout===void 0?1e3:_ref12$timeout;const STACK_TRACE_ERROR=new Error("STACK_TRACE_ERROR");return new Promise((resolve,reject)=>{let lastError;let promiseStatus="idle";let timeoutId;let intervalId;const onResolve=result=>{if(timeoutId)clearTimeout(timeoutId);if(intervalId)clearInterval(intervalId);resolve(result);};const handleTimeout=()=>{let error=lastError;if(!error)error=copyStackTrace(new Error("Timed out in waitFor!"),STACK_TRACE_ERROR);reject(error);};const checkCallback=()=>{if(vi.isFakeTimers())vi.advanceTimersByTime(interval);if(promiseStatus==="pending")return;try{const result=callback();if(result!==null&&typeof result==="object"&&typeof result.then==="function"){const thenable=result;promiseStatus="pending";thenable.then(resolvedValue=>{promiseStatus="resolved";onResolve(resolvedValue);},rejectedValue=>{promiseStatus="rejected";lastError=rejectedValue;});}else{onResolve(result);return true;}}catch(error){lastError=error;}};if(checkCallback()===true)return;timeoutId=setTimeout(handleTimeout,timeout);intervalId=setInterval(checkCallback,interval);});}function waitUntil(callback,options={}){const _getSafeTimers4=getSafeTimers(),setTimeout=_getSafeTimers4.setTimeout,setInterval=_getSafeTimers4.setInterval,clearTimeout=_getSafeTimers4.clearTimeout,clearInterval=_getSafeTimers4.clearInterval;const _ref13=typeof options==="number"?{timeout:options}:options,_ref13$interval=_ref13.interval,interval=_ref13$interval===void 0?50:_ref13$interval,_ref13$timeout=_ref13.timeout,timeout=_ref13$timeout===void 0?1e3:_ref13$timeout;const STACK_TRACE_ERROR=new Error("STACK_TRACE_ERROR");return new Promise((resolve,reject)=>{let promiseStatus="idle";let timeoutId;let intervalId;const onReject=error=>{if(!error)error=copyStackTrace(new Error("Timed out in waitUntil!"),STACK_TRACE_ERROR);reject(error);};const onResolve=result=>{if(!result)return;if(timeoutId)clearTimeout(timeoutId);if(intervalId)clearInterval(intervalId);resolve(result);return true;};const checkCallback=()=>{if(vi.isFakeTimers())vi.advanceTimersByTime(interval);if(promiseStatus==="pending")return;try{const result=callback();if(result!==null&&typeof result==="object"&&typeof result.then==="function"){const thenable=result;promiseStatus="pending";thenable.then(resolvedValue=>{promiseStatus="resolved";onResolve(resolvedValue);},rejectedValue=>{promiseStatus="rejected";onReject(rejectedValue);});}else{return onResolve(result);}}catch(error){onReject(error);}};if(checkCallback()===true)return;timeoutId=setTimeout(onReject,timeout);intervalId=setInterval(checkCallback,interval);});}function createVitest(){const _mocker=typeof __vitest_mocker__!=="undefined"?__vitest_mocker__:new Proxy({},{get(_,name){throw new Error(\`Vitest mocker was not initialized in this environment. vi.\${String(name)}() is forbidden.\`);}});let _mockedDate=null;let _config=null;const workerState=getWorkerState();let _timers;const timers=()=>_timers||(_timers=new FakeTimers({global:globalThis,config:workerState.config.fakeTimers}));const _stubsGlobal=/* @__PURE__ */new Map();const _stubsEnv=/* @__PURE__ */new Map();const _envBooleans=["PROD","DEV","SSR"];const getImporter=()=>{const stackTrace=createSimpleStackTrace({stackTraceLimit:4});const importerStack=stackTrace.split("\\n")[4];const stack=parseSingleStack(importerStack);return(stack==null?void 0:stack.file)||"";};const utils={useFakeTimers(config){var _a,_b,_c,_d;if(isChildProcess()){if(((_a=config==null?void 0:config.toFake)==null?void 0:_a.includes("nextTick"))||((_d=(_c=(_b=workerState.config)==null?void 0:_b.fakeTimers)==null?void 0:_c.toFake)==null?void 0:_d.includes("nextTick"))){throw new Error('vi.useFakeTimers({ toFake: ["nextTick"] }) is not supported in node:child_process. Use --pool=threads if mocking nextTick is required.');}}if(config)timers().configure(_objectSpread(_objectSpread({},workerState.config.fakeTimers),config));else timers().configure(workerState.config.fakeTimers);timers().useFakeTimers();return utils;},isFakeTimers(){return timers().isFakeTimers();},useRealTimers(){timers().useRealTimers();_mockedDate=null;return utils;},runOnlyPendingTimers(){timers().runOnlyPendingTimers();return utils;},async runOnlyPendingTimersAsync(){await timers().runOnlyPendingTimersAsync();return utils;},runAllTimers(){timers().runAllTimers();return utils;},async runAllTimersAsync(){await timers().runAllTimersAsync();return utils;},runAllTicks(){timers().runAllTicks();return utils;},advanceTimersByTime(ms){timers().advanceTimersByTime(ms);return utils;},async advanceTimersByTimeAsync(ms){await timers().advanceTimersByTimeAsync(ms);return utils;},advanceTimersToNextTimer(){timers().advanceTimersToNextTimer();return utils;},async advanceTimersToNextTimerAsync(){await timers().advanceTimersToNextTimerAsync();return utils;},getTimerCount(){return timers().getTimerCount();},setSystemTime(time){const date=time instanceof Date?time:new Date(time);_mockedDate=date;timers().setSystemTime(date);return utils;},getMockedSystemTime(){return _mockedDate;},getRealSystemTime(){return timers().getRealSystemTime();},clearAllTimers(){timers().clearAllTimers();return utils;},// mocks
spyOn,fn,waitFor,waitUntil,hoisted(factory){assertTypes(factory,'"vi.hoisted" factory',["function"]);return factory();},mock(path,factory){const importer=getImporter();_mocker.queueMock(path,importer,factory?()=>factory(()=>_mocker.importActual(path,importer,_mocker.getMockContext().callstack)):void 0,true);},unmock(path){_mocker.queueUnmock(path,getImporter());},doMock(path,factory){const importer=getImporter();_mocker.queueMock(path,importer,factory?()=>factory(()=>_mocker.importActual(path,importer,_mocker.getMockContext().callstack)):void 0,false);},doUnmock(path){_mocker.queueUnmock(path,getImporter());},async importActual(path){return _mocker.importActual(path,getImporter(),_mocker.getMockContext().callstack);},async importMock(path){return _mocker.importMock(path,getImporter());},// this is typed in the interface so it's not necessary to type it here
mocked(item,_options={}){return item;},isMockFunction(fn2){return isMockFunction(fn2);},clearAllMocks(){mocks.forEach(spy=>spy.mockClear());return utils;},resetAllMocks(){mocks.forEach(spy=>spy.mockReset());return utils;},restoreAllMocks(){mocks.forEach(spy=>spy.mockRestore());return utils;},stubGlobal(name,value){if(!_stubsGlobal.has(name))_stubsGlobal.set(name,Object.getOwnPropertyDescriptor(globalThis,name));Object.defineProperty(globalThis,name,{value,writable:true,configurable:true,enumerable:true});return utils;},stubEnv(name,value){if(!_stubsEnv.has(name))_stubsEnv.set(name,process.env[name]);if(_envBooleans.includes(name))process.env[name]=value?"1":"";else process.env[name]=String(value);return utils;},unstubAllGlobals(){_stubsGlobal.forEach((original,name)=>{if(!original)Reflect.deleteProperty(globalThis,name);else Object.defineProperty(globalThis,name,original);});_stubsGlobal.clear();return utils;},unstubAllEnvs(){_stubsEnv.forEach((original,name)=>{if(original===void 0)delete process.env[name];else process.env[name]=original;});_stubsEnv.clear();return utils;},resetModules(){resetModules(workerState.moduleCache);return utils;},async dynamicImportSettled(){return waitForImportsToResolve();},setConfig(config){if(!_config)_config=_objectSpread({},workerState.config);Object.assign(workerState.config,config);},resetConfig(){if(_config)Object.assign(workerState.config,_config);}};return utils;}const vitest=createVitest();const vi=vitest;class Spy{called=false;mock=()=>{};method(){}}function spy(){const inst=new Spy();return vi.fn(inst.mock);}async function wait(){}exports.spy=spy;exports.wait=wait;
//# sourceMappingURL=test.js.map
"
`;

exports[`Outputs (babel) > artifacts > builds all the artifacts with rollup > umd/client.js 1`] = `
"(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define("Packemon", ["exports"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.Packemon = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.createClient = createClient;
  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
  function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  // Bundled with Packemon: https://packemon.dev
  // Platform: browser, Support: legacy, Format: umd
  var Client = /*#__PURE__*/_createClass(function Client() {
    _classCallCheck(this, Client);
    _defineProperty(this, "prop", 123);
  });
  function* gen() {}
  async function wait() {}
  async function createClient() {
    await wait();
    var _iterator = _createForOfIteratorHelper(gen()),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var iterator = _step.value;
        console.log(iterator);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return new Client();
  }
});
//# sourceMappingURL=client.js.map
"
`;

exports[`Outputs (babel) > artifacts > builds all the artifacts with rollup 1`] = `
[
  {
    "format": "lib",
    "stats": {
      "size": 195,
    },
  },
]
`;

exports[`Outputs (babel) > bundle > bundles all files into a single file with rollup > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: lib

'use strict';

function foo() {}
function bar() {}
exports.bar = bar;
exports.foo = foo;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (browser, esm) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (browser, esm) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (browser, esm) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (browser, esm) > esm/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: browser, Support: stable, Format: esm

import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
import '../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (browser, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (browser, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (browser, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (browser, lib) > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: browser, Support: stable, Format: lib

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (browser, umd) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (browser, umd) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (browser, umd) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (browser, umd) > umd/index.js 1`] = `
"(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../assets/globals-107ab52e.css", "../assets/fonts-4e5dc96c.css", "../assets/styles-b11c3a83.css"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../assets/globals-107ab52e.css"), require("../assets/fonts-4e5dc96c.css"), require("../assets/styles-b11c3a83.css"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.globals107ab52e, global.fonts4e5dc96c, global.stylesB11c3a83);
    global.projectAssets = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _globals107ab52e, _fonts4e5dc96c, _stylesB11c3a) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.button = button;
  // Bundled with Packemon: https://packemon.dev
  // Platform: browser, Support: stable, Format: umd

  function button() {}
});
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (electron, esm) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (electron, esm) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (electron, esm) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (electron, esm) > esm/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: electron, Support: stable, Format: esm

import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
import '../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (electron, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (electron, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (electron, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (electron, lib) > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: electron, Support: stable, Format: lib

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (native, esm) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (native, esm) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (native, esm) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (native, esm) > esm/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: native, Support: stable, Format: esm

import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
import '../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (native, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (native, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (native, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (native, lib) > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: native, Support: stable, Format: lib

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (node, cjs) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (node, cjs) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (node, cjs) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (node, cjs) > cjs/index.cjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: cjs

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.cjs.map
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (node, cjs) > cjs/index-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import data from './index.cjs';

export const { button } = data;"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (node, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (node, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (node, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (node, lib) > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: lib

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (node, mjs) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (node, mjs) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (node, mjs) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > bundle with assets > bundles all files and references assets (node, mjs) > mjs/index.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: mjs

import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
import '../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.mjs.map
"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > ../assets/fonts-4e5dc96c.css 2`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > ../assets/fonts-4e5dc96c.css 3`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > ../assets/globals-107ab52e.css 2`] = `
"html {
}
"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > ../assets/globals-107ab52e.css 3`] = `
"html {
}
"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > ../assets/styles-b11c3a83.css 2`] = `
".button {
}
"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > ../assets/styles-b11c3a83.css 3`] = `
".button {
}
"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > cjs/index.cjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: cjs

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.cjs.map
"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > cjs/index-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import data from './index.cjs';

export const { button } = data;"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > esm/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: esm

import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
import '../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > esm/index-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import data from './index.cjs';

export const { button } = data;"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: lib

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > bundle with assets > uses same assets across multiple formats > lib/index-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import data from './index.cjs';

export const { button } = data;"
`;

exports[`Outputs (babel) > no bundle > creates individual files for every source file > lib/index.js 1`] = `
"'use strict';

const other = require('./other.js');
function bar() {}
exports.foo = other.foo;
exports.bar = bar;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle > creates individual files for every source file > lib/not-imported.js 1`] = `
"'use strict';

function baz() {}
exports.baz = baz;
//# sourceMappingURL=not-imported.js.map
"
`;

exports[`Outputs (babel) > no bundle > creates individual files for every source file > lib/other.js 1`] = `
"'use strict';

function foo() {}
exports.foo = foo;
//# sourceMappingURL=other.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, esm) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, esm) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, esm) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, esm) > esm/button/index.js 1`] = `
"import '../../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, esm) > esm/index.js 1`] = `
"import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
export { button } from './button/index.js';
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, lib) > lib/button/index.js 1`] = `
"'use strict';

require('../../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, lib) > lib/index.js 1`] = `
"'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
const index = require('./button/index.js');
exports.button = index.button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, umd) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, umd) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, umd) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, umd) > umd/button/index.js 1`] = `
"(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../../assets/styles-b11c3a83.css"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../../assets/styles-b11c3a83.css"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.stylesB11c3a83);
    global.projectAssets = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _stylesB11c3a) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.button = button;
  function button() {}
});
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (browser, umd) > umd/index.js 1`] = `
"(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../assets/globals-107ab52e.css", "../assets/fonts-4e5dc96c.css", "./button/index.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../assets/globals-107ab52e.css"), require("../assets/fonts-4e5dc96c.css"), require("./button/index.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.globals107ab52e, global.fonts4e5dc96c, global.index);
    global.projectAssets = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _globals107ab52e, _fonts4e5dc96c, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  Object.defineProperty(_exports, "button", {
    enumerable: true,
    get: function () {
      return _index.button;
    }
  });
});
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (electron, esm) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (electron, esm) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (electron, esm) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (electron, esm) > esm/button/index.js 1`] = `
"import '../../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (electron, esm) > esm/index.js 1`] = `
"import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
export { button } from './button/index.js';
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (electron, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (electron, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (electron, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (electron, lib) > lib/button/index.js 1`] = `
"'use strict';

require('../../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (electron, lib) > lib/index.js 1`] = `
"'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
const index = require('./button/index.js');
exports.button = index.button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (native, esm) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (native, esm) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (native, esm) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (native, esm) > esm/button/index.js 1`] = `
"import '../../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (native, esm) > esm/index.js 1`] = `
"import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
export { button } from './button/index.js';
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (native, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (native, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (native, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (native, lib) > lib/button/index.js 1`] = `
"'use strict';

require('../../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (native, lib) > lib/index.js 1`] = `
"'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
const index = require('./button/index.js');
exports.button = index.button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, cjs) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, cjs) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, cjs) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, cjs) > cjs/button/index.cjs 1`] = `
"'use strict';

require('../../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.cjs.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, cjs) > cjs/index.cjs 1`] = `
"'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
const index = require('./button/index.cjs');
exports.button = index.button;
//# sourceMappingURL=index.cjs.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, cjs) > cjs/index-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import data from './index.cjs';

export const { button } = data;"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, lib) > lib/button/index.js 1`] = `
"'use strict';

require('../../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, lib) > lib/index.js 1`] = `
"'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
const index = require('./button/index.js');
exports.button = index.button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, mjs) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, mjs) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, mjs) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, mjs) > mjs/button/index.mjs 1`] = `
"import '../../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.mjs.map
"
`;

exports[`Outputs (babel) > no bundle with assets > creates individual files and references assets (node, mjs) > mjs/index.mjs 1`] = `
"import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
export { button } from './button/index.mjs';
//# sourceMappingURL=index.mjs.map
"
`;

exports[`Outputs (swc) > artifacts > builds all the artifacts with rollup > cjs/server.cjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: current, Format: cjs

'use strict';

const https = require('node:https');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const https__default = /*#__PURE__*/_interopDefault(https);
https__default.default.createServer((req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/plain'
  });
  res.write('Hello World!');
  res.end();
}).listen(8080);
//# sourceMappingURL=server.cjs.map
"
`;

exports[`Outputs (swc) > artifacts > builds all the artifacts with rollup > cjs/server-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import './server.cjs';"
`;

exports[`Outputs (swc) > artifacts > builds all the artifacts with rollup > esm/client.js 1`] = `
"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// Bundled with Packemon: https://packemon.dev
// Platform: browser, Support: legacy, Format: esm
var Client = /*#__PURE__*/_createClass(function Client() {
  _classCallCheck(this, Client);
  _defineProperty(this, "prop", 123);
});
function* gen() {}
async function wait() {}
async function createClient() {
  await wait();
  var _iterator = _createForOfIteratorHelper(gen()),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var iterator = _step.value;
      console.log(iterator);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return new Client();
}
export { createClient };
//# sourceMappingURL=client.js.map
"
`;

exports[`Outputs (swc) > artifacts > builds all the artifacts with rollup > lib/bundle-D7lcxiVj.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: native, Support: experimental, Format: lib

'use strict';

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const comma = ','.charCodeAt(0);
const semicolon = ';'.charCodeAt(0);
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const intToChar = new Uint8Array(64); // 64 possible chars.
const charToInt = new Uint8Array(128); // z is 122 in ASCII
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
// Provide a fallback for older environments.
const td = typeof TextDecoder !== 'undefined' ? /* #__PURE__ */new TextDecoder() : typeof Buffer !== 'undefined' ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = '';
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
function encode(decoded) {
  const state = new Int32Array(5);
  const bufLength = 1024 * 16;
  const subLength = bufLength - 36;
  const buf = new Uint8Array(bufLength);
  const sub = buf.subarray(0, subLength);
  let pos = 0;
  let out = '';
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) {
      if (pos === bufLength) {
        out += td.decode(buf);
        pos = 0;
      }
      buf[pos++] = semicolon;
    }
    if (line.length === 0) continue;
    state[0] = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      // We can push up to 5 ints, each int can take at most 7 chars, and we
      // may push a comma.
      if (pos > subLength) {
        out += td.decode(sub);
        buf.copyWithin(0, subLength, pos);
        pos -= subLength;
      }
      if (j > 0) buf[pos++] = comma;
      pos = encodeInteger(buf, pos, state, segment, 0); // genColumn
      if (segment.length === 1) continue;
      pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex
      pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine
      pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn
      if (segment.length === 4) continue;
      pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex
    }
  }
  return out + td.decode(buf.subarray(0, pos));
}
function encodeInteger(buf, pos, state, segment, j) {
  const next = segment[j];
  let num = next - state[j];
  state[j] = next;
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    let clamped = num & 0b011111;
    num >>>= 5;
    if (num > 0) clamped |= 0b100000;
    buf[pos++] = intToChar[clamped];
  } while (num > 0);
  return pos;
}
class BitSet {
  constructor(arg) {
    this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
  }
  add(n) {
    this.bits[n >> 5] |= 1 << (n & 31);
  }
  has(n) {
    return !!(this.bits[n >> 5] & 1 << (n & 31));
  }
}
class Chunk {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = '';
    this.outro = '';
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = '';
      this.outro = '';
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  reset() {
    this.intro = '';
    this.outro = '';
    if (this.edited) {
      this.content = this.original;
      this.storeName = false;
      this.edited = false;
    }
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = '';
    this.end = index;
    if (this.edited) {
      // after split we should save the edit content record into the correct chunk
      // to make sure sourcemap correct
      // For example:
      // '  test'.trim()
      //     split   -> '  ' + 'test'
      //   ✔️ edit    -> '' + 'test'
      //   ✖️ edit    -> 'test' + '' 
      // TODO is this block necessary?...
      newChunk.edit('', false);
      this.content = '';
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next) newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, '');
    if (this.outro.length) return true;
    const trimmed = this.content.replace(rx, '');
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit('', undefined, true);
        if (this.edited) {
          // save the change, if it has been edited
          this.edit(trimmed, this.storeName, true);
        }
      }
      return true;
    } else {
      this.edit('', undefined, true);
      this.intro = this.intro.replace(rx, '');
      if (this.intro.length) return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, '');
    if (this.intro.length) return true;
    const trimmed = this.content.replace(rx, '');
    if (trimmed.length) {
      if (trimmed !== this.content) {
        const newChunk = this.split(this.end - trimmed.length);
        if (this.edited) {
          // save the change, if it has been edited
          newChunk.edit(trimmed, this.storeName, true);
        }
        this.edit('', undefined, true);
      }
      return true;
    } else {
      this.edit('', undefined, true);
      this.outro = this.outro.replace(rx, '');
      if (this.outro.length) return true;
    }
  }
}
function getBtoa() {
  if (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {
    return str => globalThis.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === 'function') {
    return str => Buffer.from(str, 'utf-8').toString('base64');
  } else {
    return () => {
      throw new Error('Unsupported environment: \`window.btoa\` or \`Buffer\` should be supported.');
    };
  }
}
const btoa = /*#__PURE__*/getBtoa();
class SourceMap {
  constructor(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = encode(properties.mappings);
    if (typeof properties.x_google_ignoreList !== 'undefined') {
      this.x_google_ignoreList = properties.x_google_ignoreList;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
  }
}
function guessIndent(code) {
  const lines = code.split('\\n');
  const tabbed = lines.filter(line => /^\\t+/.test(line));
  const spaced = lines.filter(line => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }

  // More lines tabbed than spaced? Assume tabs, and
  // default to tabs in the case of a tie (or nothing
  // to go on)
  if (tabbed.length >= spaced.length) {
    return '\\t';
  }

  // Otherwise, we need to guess the multiple
  const min = spaced.reduce((previous, current) => {
    const numSpaces = /^ +/.exec(current)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(' ');
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\\\]/);
  const toParts = to.split(/[/\\\\]/);
  fromParts.pop(); // get dirname

  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--) fromParts[i] = '..';
  }
  return fromParts.concat(toParts).join('/');
}
const toString = Object.prototype.toString;
function isObject(thing) {
  return toString.call(thing) === '[object Object]';
}
function getLocator(source) {
  const originalLines = source.split('\\n');
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return {
      line,
      column
    };
  };
}
const wordRegex = /\\w/;
class Mappings {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const contentLengthMinusOne = content.length - 1;
      let contentLineEnd = content.indexOf('\\n', 0);
      let previousContentLineEnd = -1;
      // Loop through each line in the content and add a segment, but stop if the last line is empty,
      // else code afterwards would fill one line too many
      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
        const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment.push(nameIndex);
        }
        this.rawSegments.push(segment);
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        previousContentLineEnd = contentLineEnd;
        contentLineEnd = content.indexOf('\\n', contentLineEnd + 1);
      }
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
      this.advance(content.slice(previousContentLineEnd + 1));
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
      this.advance(content);
    }
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first = true;
    // when iterating each char, check if it's in a word boundary
    let charInHiresBoundary = false;
    while (originalCharIndex < chunk.end) {
      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
        const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (this.hires === 'boundary') {
          // in hires "boundary", group segments per word boundary than per char
          if (wordRegex.test(original[originalCharIndex])) {
            // for first char in the boundary found, start the boundary by pushing a segment
            if (!charInHiresBoundary) {
              this.rawSegments.push(segment);
              charInHiresBoundary = true;
            }
          } else {
            // for non-word char, end the boundary by pushing a segment
            this.rawSegments.push(segment);
            charInHiresBoundary = false;
          }
        } else {
          this.rawSegments.push(segment);
        }
      }
      if (original[originalCharIndex] === '\\n') {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
      } else {
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str) {
    if (!str) return;
    const lines = str.split('\\n');
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
}
const n = '\\n';
const warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
class MagicString {
  constructor(string, options = {}) {
    const chunk = new Chunk(0, string.length, string);
    Object.defineProperties(this, {
      original: {
        writable: true,
        value: string
      },
      outro: {
        writable: true,
        value: ''
      },
      intro: {
        writable: true,
        value: ''
      },
      firstChunk: {
        writable: true,
        value: chunk
      },
      lastChunk: {
        writable: true,
        value: chunk
      },
      lastSearchedChunk: {
        writable: true,
        value: chunk
      },
      byStart: {
        writable: true,
        value: {}
      },
      byEnd: {
        writable: true,
        value: {}
      },
      filename: {
        writable: true,
        value: options.filename
      },
      indentExclusionRanges: {
        writable: true,
        value: options.indentExclusionRanges
      },
      sourcemapLocations: {
        writable: true,
        value: new BitSet()
      },
      storedNames: {
        writable: true,
        value: {}
      },
      indentStr: {
        writable: true,
        value: undefined
      },
      ignoreList: {
        writable: true,
        value: options.ignoreList
      }
    });
    this.byStart[0] = chunk;
    this.byEnd[string.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== 'string') throw new TypeError('outro content must be a string');
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new MagicString(this.original, {
      filename: this.filename
    });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options) {
    options = options || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options.hires);
    const locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext(chunk => {
      const loc = locate(chunk.start);
      if (chunk.intro.length) mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length) mappings.advance(chunk.outro);
    });
    return {
      file: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,
      sources: [options.source ? getRelativePath(options.file || '', options.source) : options.file || ''],
      sourcesContent: options.includeContent ? [this.original] : undefined,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined
    };
  }
  generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
  }
  _ensureindentStr() {
    if (this.indentStr === undefined) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? '\\t' : this.indentStr;
  }
  indent(indentStr, options) {
    const pattern = /^[^\\r\\n]/gm;
    if (isObject(indentStr)) {
      options = indentStr;
      indentStr = undefined;
    }
    if (indentStr === undefined) {
      this._ensureindentStr();
      indentStr = this.indentStr || '\\t';
    }
    if (indentStr === '') return this; // noop

    options = options || {};

    // Process exclusion ranges
    const isExcluded = {};
    if (options.exclude) {
      const exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
      exclusions.forEach(exclusion => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options.indentStart !== false;
    const replacer = match => {
      if (shouldIndentNextCharacter) return \`\${indentStr}\${match}\`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === '\\n') {
              shouldIndentNextCharacter = true;
            } else if (char !== '\\r' && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  }
  insert() {
    throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
  }
  insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start, end, index) {
    if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');
    this._split(start);
    this._split(end);
    this._split(index);
    const first = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk) return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft) oldLeft.next = oldRight;
    if (oldRight) oldRight.previous = oldLeft;
    if (newLeft) newLeft.next = first;
    if (newRight) newRight.previous = last;
    if (!first.previous) this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft) this.firstChunk = first;
    if (!newRight) this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options) {
    options = options || {};
    return this.update(start, end, content, _objectSpread(_objectSpread({}, options), {}, {
      overwrite: !options.contentOnly
    }));
  }
  update(start, end, content, options) {
    if (typeof content !== 'string') throw new TypeError('replacement content must be a string');
    while (start < 0) start += this.original.length;
    while (end < 0) end += this.original.length;
    if (end > this.original.length) throw new Error('end is out of bounds');
    if (start === end) throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');
    this._split(start);
    this._split(end);
    if (options === true) {
      if (!warned.storeName) {
        console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console
        warned.storeName = true;
      }
      options = {
        storeName: true
      };
    }
    const storeName = options !== undefined ? options.storeName : false;
    const overwrite = options !== undefined ? options.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first = this.byStart[start];
    const last = this.byEnd[end];
    if (first) {
      let chunk = first;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error('Cannot overwrite across a split point');
        }
        chunk = chunk.next;
        chunk.edit('', false);
      }
      first.edit(content, storeName, !overwrite);
    } else {
      // must be inserting at the end
      const newChunk = new Chunk(start, end, '').edit(content, storeName);

      // TODO last chunk in the array may not be the last chunk, if it's moved...
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== 'string') throw new TypeError('outro content must be a string');
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    while (start < 0) start += this.original.length;
    while (end < 0) end += this.original.length;
    if (start === end) return this;
    if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
    if (start > end) throw new Error('end must be greater than start');
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = '';
      chunk.outro = '';
      chunk.edit('');
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  reset(start, end) {
    while (start < 0) start += this.original.length;
    while (end < 0) end += this.original.length;
    if (start === end) return this;
    if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
    if (start > end) throw new Error('end must be greater than start');
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.reset();
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length) return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length) return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length) return this.intro[this.intro.length - 1];
    return '';
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length) {
    while (start < 0) start += this.original.length;
    while (end < 0) end += this.original.length;
    let result = '';

    // find start chunk
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      // found end chunk before start
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start) throw new Error(\`Cannot use replaced character \${start} as slice start anchor.\`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(\`Cannot use replaced character \${end} as slice end anchor.\`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }

  // TODO deprecate this? not really very useful
  snip(start, end) {
    const clone = this.clone();
    clone.remove(0, start);
    clone.remove(end, clone.original.length);
    return clone;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index]) return;
    let chunk = this.lastSearchedChunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index)) return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      // zero-length edited chunks are a special case (overlapping replacements)
      const loc = getLocator(this.original)(index);
      throw new Error(\`Cannot split a chunk that has already been edited (\${loc.line}:\${loc.column} – "\${chunk.original}")\`);
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk) this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim('[\\\\r\\\\n]');
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || '\\\\s') + '+$');
    this.outro = this.outro.replace(rx, '');
    if (this.outro.length) return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);

      // if chunk was trimmed, we have a new lastChunk
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp('^' + (charType || '\\\\s') + '+');
    this.intro = this.intro.replace(rx, '');
    if (this.intro.length) return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        // special case...
        if (chunk === this.lastChunk) this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str) {
      if (typeof replacement === 'string') {
        return replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {
          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
          if (i === '$') return '$';
          if (i === '&') return match[0];
          const num = +i;
          if (num < match.length) return match[+i];
          return \`$\${i}\`;
        });
      } else {
        return replacement(...match, match.index, str, match.groups);
      }
    }
    function matchAll(re, str) {
      let match;
      const matches = [];
      while (match = re.exec(str)) {
        matches.push(match);
      }
      return matches;
    }
    if (searchValue.global) {
      const matches = matchAll(searchValue, this.original);
      matches.forEach(match => {
        if (match.index != null) {
          const replacement = getReplacement(match, this.original);
          if (replacement !== match[0]) {
            this.overwrite(match.index, match.index + match[0].length, replacement);
          }
        }
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null) {
        const replacement = getReplacement(match, this.original);
        if (replacement !== match[0]) {
          this.overwrite(match.index, match.index + match[0].length, replacement);
        }
      }
    }
    return this;
  }
  _replaceString(string, replacement) {
    const original = this.original;
    const index = original.indexOf(string);
    if (index !== -1) {
      this.overwrite(index, index + string.length, replacement);
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === 'string') {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string, replacement) {
    const original = this.original;
    const stringLength = string.length;
    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {
      const previous = original.slice(index, index + stringLength);
      if (previous !== replacement) this.overwrite(index, index + stringLength, replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === 'string') {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError('MagicString.prototype.replaceAll called with a non-global RegExp argument');
    }
    return this._replaceRegexp(searchValue, replacement);
  }
}
exports.SourceMap = SourceMap;
exports.default = MagicString;
//# sourceMappingURL=bundle-D7lcxiVj.js.map
"
`;

exports[`Outputs (swc) > artifacts > builds all the artifacts with rollup > lib/client.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: browser, Support: legacy, Format: lib

'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Client = /*#__PURE__*/_createClass(function Client() {
  _classCallCheck(this, Client);
  _defineProperty(this, "prop", 123);
});
function* gen() {}
async function wait() {}
async function createClient() {
  await wait();
  var _iterator = _createForOfIteratorHelper(gen()),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var iterator = _step.value;
      console.log(iterator);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return new Client();
}
exports.createClient = createClient;
//# sourceMappingURL=client.js.map
"
`;

exports[`Outputs (swc) > artifacts > builds all the artifacts with rollup > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: lib

'use strict';

const EXAMPLE = 'foo';
exports.EXAMPLE = EXAMPLE;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > artifacts > builds all the artifacts with rollup > lib/test.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: native, Support: experimental, Format: lib
'use strict';const _excluded=["maxLength"],_excluded2=["value"];function _objectWithoutProperties(source,excluded){if(source==null)return{};var target=_objectWithoutPropertiesLoose(source,excluded);var key,i;if(Object.getOwnPropertySymbols){var sourceSymbolKeys=Object.getOwnPropertySymbols(source);for(i=0;i<sourceSymbolKeys.length;i++){key=sourceSymbolKeys[i];if(excluded.indexOf(key)>=0)continue;if(!Object.prototype.propertyIsEnumerable.call(source,key))continue;target[key]=source[key];}}return target;}function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return{};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key];}return target;}function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_unsupportedIterableToArray(arr,i)||_nonIterableRest();}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o==="string")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2;}function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1;}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r;}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return;}finally{if(o)throw n;}}return a;}}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr;}function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}function _defineProperty(obj,key,value){key=_toPropertyKey(key);if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _toPropertyKey(t){var i=_toPrimitive(t,"string");return"symbol"==typeof i?i:i+"";}function _toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.");}return("string"===r?String:Number)(t);}function assertTypes(value,name,types){const receivedType=typeof value;const pass=types.includes(receivedType);if(!pass)throw new TypeError(\`\${name} value must be \${types.join(" or ")}, received "\${receivedType}"\`);}function isObject$1(item){return item!=null&&typeof item==="object"&&!Array.isArray(item);}function isFinalObj(obj){return obj===Object.prototype||obj===Function.prototype||obj===RegExp.prototype;}function getType$2(value){return Object.prototype.toString.apply(value).slice(8,-1);}function collectOwnProperties(obj,collector){const collect=typeof collector==="function"?collector:key=>collector.add(key);Object.getOwnPropertyNames(obj).forEach(collect);Object.getOwnPropertySymbols(obj).forEach(collect);}function getOwnProperties(obj){const ownProps=/* @__PURE__ */new Set();if(isFinalObj(obj))return[];collectOwnProperties(obj,ownProps);return Array.from(ownProps);}const defaultCloneOptions={forceWritable:false};function deepClone(val,options=defaultCloneOptions){const seen=/* @__PURE__ */new WeakMap();return clone(val,seen,options);}function clone(val,seen,options=defaultCloneOptions){let k,out;if(seen.has(val))return seen.get(val);if(Array.isArray(val)){out=Array(k=val.length);seen.set(val,out);while(k--)out[k]=clone(val[k],seen,options);return out;}if(Object.prototype.toString.call(val)==="[object Object]"){out=Object.create(Object.getPrototypeOf(val));seen.set(val,out);const props=getOwnProperties(val);for(const k2 of props){const descriptor=Object.getOwnPropertyDescriptor(val,k2);if(!descriptor)continue;const cloned=clone(val[k2],seen,options);if(options.forceWritable){Object.defineProperty(out,k2,{enumerable:descriptor.enumerable,configurable:true,writable:true,value:cloned});}else if("get"in descriptor){Object.defineProperty(out,k2,_objectSpread(_objectSpread({},descriptor),{},{get(){return cloned;}}));}else{Object.defineProperty(out,k2,_objectSpread(_objectSpread({},descriptor),{},{value:cloned}));}}return out;}return val;}function objectAttr(source,path,defaultValue=void 0){const paths=path.replace(/\\[(\\d+)\\]/g,".$1").split(".");let result=source;for(const p of paths){result=Object(result)[p];if(result===void 0)return defaultValue;}return result;}function createDefer(){let resolve=null;let reject=null;const p=new Promise((_resolve,_reject)=>{resolve=_resolve;reject=_reject;});p.resolve=resolve;p.reject=reject;return p;}var commonjsGlobal$1=typeof globalThis!=='undefined'?globalThis:typeof window!=='undefined'?window:typeof global!=='undefined'?global:typeof self!=='undefined'?self:{};function getDefaultExportFromCjs$2(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,'default')?x['default']:x;}function getAugmentedNamespace(n){if(n.__esModule)return n;var f=n.default;if(typeof f=="function"){var a=function a(){if(this instanceof a){return Reflect.construct(f,arguments,this.constructor);}return f.apply(this,arguments);};a.prototype=f.prototype;}else a={};Object.defineProperty(a,'__esModule',{value:true});Object.keys(n).forEach(function(k){var d=Object.getOwnPropertyDescriptor(n,k);Object.defineProperty(a,k,d.get?d:{enumerable:true,get:function(){return n[k];}});});return a;}var build$1={};var ansiStyles={exports:{}};ansiStyles.exports;(function(module){const ANSI_BACKGROUND_OFFSET=10;const wrapAnsi256=(offset=0)=>code=>\`\\u001B[\${38+offset};5;\${code}m\`;const wrapAnsi16m=(offset=0)=>(red,green,blue)=>\`\\u001B[\${38+offset};2;\${red};\${green};\${blue}m\`;function assembleStyles(){const codes=new Map();const styles={modifier:{reset:[0,0],// 21 isn't widely supported and 22 does the same thing
bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],// Bright color
blackBright:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],// Bright color
bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};// Alias bright black as gray (and grey)
styles.color.gray=styles.color.blackBright;styles.bgColor.bgGray=styles.bgColor.bgBlackBright;styles.color.grey=styles.color.blackBright;styles.bgColor.bgGrey=styles.bgColor.bgBlackBright;for(const _ref of Object.entries(styles)){var _ref2=_slicedToArray(_ref,2);const groupName=_ref2[0];const group=_ref2[1];for(const _ref3 of Object.entries(group)){var _ref4=_slicedToArray(_ref3,2);const styleName=_ref4[0];const style=_ref4[1];styles[styleName]={open:\`\\u001B[\${style[0]}m\`,close:\`\\u001B[\${style[1]}m\`};group[styleName]=styles[styleName];codes.set(style[0],style[1]);}Object.defineProperty(styles,groupName,{value:group,enumerable:false});}Object.defineProperty(styles,'codes',{value:codes,enumerable:false});styles.color.close='\\u001B[39m';styles.bgColor.close='\\u001B[49m';styles.color.ansi256=wrapAnsi256();styles.color.ansi16m=wrapAnsi16m();styles.bgColor.ansi256=wrapAnsi256(ANSI_BACKGROUND_OFFSET);styles.bgColor.ansi16m=wrapAnsi16m(ANSI_BACKGROUND_OFFSET);// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
Object.defineProperties(styles,{rgbToAnsi256:{value:(red,green,blue)=>{// We use the extended greyscale palette here, with the exception of
// black and white. normal palette only has 4 greyscale shades.
if(red===green&&green===blue){if(red<8){return 16;}if(red>248){return 231;}return Math.round((red-8)/247*24)+232;}return 16+36*Math.round(red/255*5)+6*Math.round(green/255*5)+Math.round(blue/255*5);},enumerable:false},hexToRgb:{value:hex=>{const matches=/(?<colorString>[a-f\\d]{6}|[a-f\\d]{3})/i.exec(hex.toString(16));if(!matches){return[0,0,0];}let colorString=matches.groups.colorString;if(colorString.length===3){colorString=colorString.split('').map(character=>character+character).join('');}const integer=Number.parseInt(colorString,16);return[integer>>16&0xFF,integer>>8&0xFF,integer&0xFF];},enumerable:false},hexToAnsi256:{value:hex=>styles.rgbToAnsi256(...styles.hexToRgb(hex)),enumerable:false}});return styles;}// Make the export immutable
Object.defineProperty(module,'exports',{enumerable:true,get:assembleStyles});})(ansiStyles);var ansiStylesExports=ansiStyles.exports;var collections={};Object.defineProperty(collections,'__esModule',{value:true});collections.printIteratorEntries=printIteratorEntries;collections.printIteratorValues=printIteratorValues;collections.printListItems=printListItems;collections.printObjectProperties=printObjectProperties;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */const getKeysOfEnumerableProperties=(object,compareKeys)=>{const rawKeys=Object.keys(object);const keys=compareKeys!==null?rawKeys.sort(compareKeys):rawKeys;if(Object.getOwnPropertySymbols){Object.getOwnPropertySymbols(object).forEach(symbol=>{if(Object.getOwnPropertyDescriptor(object,symbol).enumerable){keys.push(symbol);}});}return keys;};/**
 * Return entries (for example, of a map)
 * with spacing, indentation, and comma
 * without surrounding punctuation (for example, braces)
 */function printIteratorEntries(iterator,config,indentation,depth,refs,printer,// Too bad, so sad that separator for ECMAScript Map has been ' => '
// What a distracting diff if you change a data structure to/from
// ECMAScript Object or Immutable.Map/OrderedMap which use the default.
separator=': '){let result='';let width=0;let current=iterator.next();if(!current.done){result+=config.spacingOuter;const indentationNext=indentation+config.indent;while(!current.done){result+=indentationNext;if(width++===config.maxWidth){result+='…';break;}const name=printer(current.value[0],config,indentationNext,depth,refs);const value=printer(current.value[1],config,indentationNext,depth,refs);result+=name+separator+value;current=iterator.next();if(!current.done){result+=\`,\${config.spacingInner}\`;}else if(!config.min){result+=',';}}result+=config.spacingOuter+indentation;}return result;}/**
 * Return values (for example, of a set)
 * with spacing, indentation, and comma
 * without surrounding punctuation (braces or brackets)
 */function printIteratorValues(iterator,config,indentation,depth,refs,printer){let result='';let width=0;let current=iterator.next();if(!current.done){result+=config.spacingOuter;const indentationNext=indentation+config.indent;while(!current.done){result+=indentationNext;if(width++===config.maxWidth){result+='…';break;}result+=printer(current.value,config,indentationNext,depth,refs);current=iterator.next();if(!current.done){result+=\`,\${config.spacingInner}\`;}else if(!config.min){result+=',';}}result+=config.spacingOuter+indentation;}return result;}/**
 * Return items (for example, of an array)
 * with spacing, indentation, and comma
 * without surrounding punctuation (for example, brackets)
 **/function printListItems(list,config,indentation,depth,refs,printer){let result='';if(list.length){result+=config.spacingOuter;const indentationNext=indentation+config.indent;for(let i=0;i<list.length;i++){result+=indentationNext;if(i===config.maxWidth){result+='…';break;}if(i in list){result+=printer(list[i],config,indentationNext,depth,refs);}if(i<list.length-1){result+=\`,\${config.spacingInner}\`;}else if(!config.min){result+=',';}}result+=config.spacingOuter+indentation;}return result;}/**
 * Return properties of an object
 * with spacing, indentation, and comma
 * without surrounding punctuation (for example, braces)
 */function printObjectProperties(val,config,indentation,depth,refs,printer){let result='';const keys=getKeysOfEnumerableProperties(val,config.compareKeys);if(keys.length){result+=config.spacingOuter;const indentationNext=indentation+config.indent;for(let i=0;i<keys.length;i++){const key=keys[i];const name=printer(key,config,indentationNext,depth,refs);const value=printer(val[key],config,indentationNext,depth,refs);result+=\`\${indentationNext+name}: \${value}\`;if(i<keys.length-1){result+=\`,\${config.spacingInner}\`;}else if(!config.min){result+=',';}}result+=config.spacingOuter+indentation;}return result;}var AsymmetricMatcher$4={};Object.defineProperty(AsymmetricMatcher$4,'__esModule',{value:true});AsymmetricMatcher$4.test=AsymmetricMatcher$4.serialize=AsymmetricMatcher$4.default=void 0;var _collections$3=collections;var Symbol$2=globalThis['jest-symbol-do-not-touch']||globalThis.Symbol;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */const asymmetricMatcher=typeof Symbol$2==='function'&&Symbol$2.for?Symbol$2.for('jest.asymmetricMatcher'):0x1357a5;const SPACE$2=' ';const serialize$7=(val,config,indentation,depth,refs,printer)=>{const stringedValue=val.toString();if(stringedValue==='ArrayContaining'||stringedValue==='ArrayNotContaining'){if(++depth>config.maxDepth){return\`[\${stringedValue}]\`;}return\`\${stringedValue+SPACE$2}[\${(0,_collections$3.printListItems)(val.sample,config,indentation,depth,refs,printer)}]\`;}if(stringedValue==='ObjectContaining'||stringedValue==='ObjectNotContaining'){if(++depth>config.maxDepth){return\`[\${stringedValue}]\`;}return\`\${stringedValue+SPACE$2}{\${(0,_collections$3.printObjectProperties)(val.sample,config,indentation,depth,refs,printer)}}\`;}if(stringedValue==='StringMatching'||stringedValue==='StringNotMatching'){return stringedValue+SPACE$2+printer(val.sample,config,indentation,depth,refs);}if(stringedValue==='StringContaining'||stringedValue==='StringNotContaining'){return stringedValue+SPACE$2+printer(val.sample,config,indentation,depth,refs);}if(typeof val.toAsymmetricMatcher!=='function'){throw new Error(\`Asymmetric matcher \${val.constructor.name} does not implement toAsymmetricMatcher()\`);}return val.toAsymmetricMatcher();};AsymmetricMatcher$4.serialize=serialize$7;const test$7=val=>val&&val.$$typeof===asymmetricMatcher;AsymmetricMatcher$4.test=test$7;const plugin$6={serialize:serialize$7,test:test$7};var _default$7=plugin$6;AsymmetricMatcher$4.default=_default$7;var DOMCollection$3={};Object.defineProperty(DOMCollection$3,'__esModule',{value:true});DOMCollection$3.test=DOMCollection$3.serialize=DOMCollection$3.default=void 0;var _collections$2=collections;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */const SPACE$1=' ';const OBJECT_NAMES=['DOMStringMap','NamedNodeMap'];const ARRAY_REGEXP=/^(HTML\\w*Collection|NodeList)$/;const testName=name=>OBJECT_NAMES.indexOf(name)!==-1||ARRAY_REGEXP.test(name);const test$6=val=>val&&val.constructor&&!!val.constructor.name&&testName(val.constructor.name);DOMCollection$3.test=test$6;const isNamedNodeMap=collection=>collection.constructor.name==='NamedNodeMap';const serialize$6=(collection,config,indentation,depth,refs,printer)=>{const name=collection.constructor.name;if(++depth>config.maxDepth){return\`[\${name}]\`;}return(config.min?'':name+SPACE$1)+(OBJECT_NAMES.indexOf(name)!==-1?\`{\${(0,_collections$2.printObjectProperties)(isNamedNodeMap(collection)?Array.from(collection).reduce((props,attribute)=>{props[attribute.name]=attribute.value;return props;},{}):_objectSpread({},collection),config,indentation,depth,refs,printer)}}\`:\`[\${(0,_collections$2.printListItems)(Array.from(collection),config,indentation,depth,refs,printer)}]\`);};DOMCollection$3.serialize=serialize$6;const plugin$5={serialize:serialize$6,test:test$6};var _default$6=plugin$5;DOMCollection$3.default=_default$6;var DOMElement$3={};var markup={};var escapeHTML$1={};Object.defineProperty(escapeHTML$1,'__esModule',{value:true});escapeHTML$1.default=escapeHTML;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */function escapeHTML(str){return str.replace(/</g,'&lt;').replace(/>/g,'&gt;');}Object.defineProperty(markup,'__esModule',{value:true});markup.printText=markup.printProps=markup.printElementAsLeaf=markup.printElement=markup.printComment=markup.printChildren=void 0;var _escapeHTML=_interopRequireDefault$1(escapeHTML$1);function _interopRequireDefault$1(obj){return obj&&obj.__esModule?obj:{default:obj};}/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Return empty string if keys is empty.
const printProps=(keys,props,config,indentation,depth,refs,printer)=>{const indentationNext=indentation+config.indent;const colors=config.colors;return keys.map(key=>{const value=props[key];let printed=printer(value,config,indentationNext,depth,refs);if(typeof value!=='string'){if(printed.indexOf('\\n')!==-1){printed=config.spacingOuter+indentationNext+printed+config.spacingOuter+indentation;}printed=\`{\${printed}}\`;}return\`\${config.spacingInner+indentation+colors.prop.open+key+colors.prop.close}=\${colors.value.open}\${printed}\${colors.value.close}\`;}).join('');};// Return empty string if children is empty.
markup.printProps=printProps;const printChildren=(children,config,indentation,depth,refs,printer)=>children.map(child=>config.spacingOuter+indentation+(typeof child==='string'?printText(child,config):printer(child,config,indentation,depth,refs))).join('');markup.printChildren=printChildren;const printText=(text,config)=>{const contentColor=config.colors.content;return contentColor.open+(0,_escapeHTML.default)(text)+contentColor.close;};markup.printText=printText;const printComment=(comment,config)=>{const commentColor=config.colors.comment;return\`\${commentColor.open}<!--\${(0,_escapeHTML.default)(comment)}-->\${commentColor.close}\`;};// Separate the functions to format props, children, and element,
// so a plugin could override a particular function, if needed.
// Too bad, so sad: the traditional (but unnecessary) space
// in a self-closing tagColor requires a second test of printedProps.
markup.printComment=printComment;const printElement=(type,printedProps,printedChildren,config,indentation)=>{const tagColor=config.colors.tag;return\`\${tagColor.open}<\${type}\${printedProps&&tagColor.close+printedProps+config.spacingOuter+indentation+tagColor.open}\${printedChildren?\`>\${tagColor.close}\${printedChildren}\${config.spacingOuter}\${indentation}\${tagColor.open}</\${type}\`:\`\${printedProps&&!config.min?'':' '}/\`}>\${tagColor.close}\`;};markup.printElement=printElement;const printElementAsLeaf=(type,config)=>{const tagColor=config.colors.tag;return\`\${tagColor.open}<\${type}\${tagColor.close} …\${tagColor.open} />\${tagColor.close}\`;};markup.printElementAsLeaf=printElementAsLeaf;Object.defineProperty(DOMElement$3,'__esModule',{value:true});DOMElement$3.test=DOMElement$3.serialize=DOMElement$3.default=void 0;var _markup$2=markup;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */const ELEMENT_NODE=1;const TEXT_NODE=3;const COMMENT_NODE=8;const FRAGMENT_NODE=11;const ELEMENT_REGEXP=/^((HTML|SVG)\\w*)?Element$/;const testHasAttribute=val=>{try{return typeof val.hasAttribute==='function'&&val.hasAttribute('is');}catch{return false;}};const testNode=val=>{const constructorName=val.constructor.name;const nodeType=val.nodeType,tagName=val.tagName;const isCustomElement=typeof tagName==='string'&&tagName.includes('-')||testHasAttribute(val);return nodeType===ELEMENT_NODE&&(ELEMENT_REGEXP.test(constructorName)||isCustomElement)||nodeType===TEXT_NODE&&constructorName==='Text'||nodeType===COMMENT_NODE&&constructorName==='Comment'||nodeType===FRAGMENT_NODE&&constructorName==='DocumentFragment';};const test$5=val=>val?.constructor?.name&&testNode(val);DOMElement$3.test=test$5;function nodeIsText(node){return node.nodeType===TEXT_NODE;}function nodeIsComment(node){return node.nodeType===COMMENT_NODE;}function nodeIsFragment(node){return node.nodeType===FRAGMENT_NODE;}const serialize$5=(node,config,indentation,depth,refs,printer)=>{if(nodeIsText(node)){return(0,_markup$2.printText)(node.data,config);}if(nodeIsComment(node)){return(0,_markup$2.printComment)(node.data,config);}const type=nodeIsFragment(node)?'DocumentFragment':node.tagName.toLowerCase();if(++depth>config.maxDepth){return(0,_markup$2.printElementAsLeaf)(type,config);}return(0,_markup$2.printElement)(type,(0,_markup$2.printProps)(nodeIsFragment(node)?[]:Array.from(node.attributes,attr=>attr.name).sort(),nodeIsFragment(node)?{}:Array.from(node.attributes).reduce((props,attribute)=>{props[attribute.name]=attribute.value;return props;},{}),config,indentation+config.indent,depth,refs,printer),(0,_markup$2.printChildren)(Array.prototype.slice.call(node.childNodes||node.children),config,indentation+config.indent,depth,refs,printer),config,indentation);};DOMElement$3.serialize=serialize$5;const plugin$4={serialize:serialize$5,test:test$5};var _default$5=plugin$4;DOMElement$3.default=_default$5;var Immutable$3={};Object.defineProperty(Immutable$3,'__esModule',{value:true});Immutable$3.test=Immutable$3.serialize=Immutable$3.default=void 0;var _collections$1=collections;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // SENTINEL constants are from https://github.com/facebook/immutable-js
const IS_ITERABLE_SENTINEL='@@__IMMUTABLE_ITERABLE__@@';const IS_LIST_SENTINEL='@@__IMMUTABLE_LIST__@@';const IS_KEYED_SENTINEL$1='@@__IMMUTABLE_KEYED__@@';const IS_MAP_SENTINEL='@@__IMMUTABLE_MAP__@@';const IS_ORDERED_SENTINEL$1='@@__IMMUTABLE_ORDERED__@@';const IS_RECORD_SENTINEL='@@__IMMUTABLE_RECORD__@@';// immutable v4
const IS_SEQ_SENTINEL='@@__IMMUTABLE_SEQ__@@';const IS_SET_SENTINEL$1='@@__IMMUTABLE_SET__@@';const IS_STACK_SENTINEL='@@__IMMUTABLE_STACK__@@';const getImmutableName=name=>\`Immutable.\${name}\`;const printAsLeaf=name=>\`[\${name}]\`;const SPACE=' ';const LAZY='…';// Seq is lazy if it calls a method like filter
const printImmutableEntries=(val,config,indentation,depth,refs,printer,type)=>++depth>config.maxDepth?printAsLeaf(getImmutableName(type)):\`\${getImmutableName(type)+SPACE}{\${(0,_collections$1.printIteratorEntries)(val.entries(),config,indentation,depth,refs,printer)}}\`;// Record has an entries method because it is a collection in immutable v3.
// Return an iterator for Immutable Record from version v3 or v4.
function getRecordEntries(val){let i=0;return{next(){if(i<val._keys.length){const key=val._keys[i++];return{done:false,value:[key,val.get(key)]};}return{done:true,value:undefined};}};}const printImmutableRecord=(val,config,indentation,depth,refs,printer)=>{// _name property is defined only for an Immutable Record instance
// which was constructed with a second optional descriptive name arg
const name=getImmutableName(val._name||'Record');return++depth>config.maxDepth?printAsLeaf(name):\`\${name+SPACE}{\${(0,_collections$1.printIteratorEntries)(getRecordEntries(val),config,indentation,depth,refs,printer)}}\`;};const printImmutableSeq=(val,config,indentation,depth,refs,printer)=>{const name=getImmutableName('Seq');if(++depth>config.maxDepth){return printAsLeaf(name);}if(val[IS_KEYED_SENTINEL$1]){return\`\${name+SPACE}{\${// from Immutable collection of entries or from ECMAScript object
val._iter||val._object?(0,_collections$1.printIteratorEntries)(val.entries(),config,indentation,depth,refs,printer):LAZY}}\`;}return\`\${name+SPACE}[\${val._iter||// from Immutable collection of values
val._array||// from ECMAScript array
val._collection||// from ECMAScript collection in immutable v4
val._iterable// from ECMAScript collection in immutable v3
?(0,_collections$1.printIteratorValues)(val.values(),config,indentation,depth,refs,printer):LAZY}]\`;};const printImmutableValues=(val,config,indentation,depth,refs,printer,type)=>++depth>config.maxDepth?printAsLeaf(getImmutableName(type)):\`\${getImmutableName(type)+SPACE}[\${(0,_collections$1.printIteratorValues)(val.values(),config,indentation,depth,refs,printer)}]\`;const serialize$4=(val,config,indentation,depth,refs,printer)=>{if(val[IS_MAP_SENTINEL]){return printImmutableEntries(val,config,indentation,depth,refs,printer,val[IS_ORDERED_SENTINEL$1]?'OrderedMap':'Map');}if(val[IS_LIST_SENTINEL]){return printImmutableValues(val,config,indentation,depth,refs,printer,'List');}if(val[IS_SET_SENTINEL$1]){return printImmutableValues(val,config,indentation,depth,refs,printer,val[IS_ORDERED_SENTINEL$1]?'OrderedSet':'Set');}if(val[IS_STACK_SENTINEL]){return printImmutableValues(val,config,indentation,depth,refs,printer,'Stack');}if(val[IS_SEQ_SENTINEL]){return printImmutableSeq(val,config,indentation,depth,refs,printer);}// For compatibility with immutable v3 and v4, let record be the default.
return printImmutableRecord(val,config,indentation,depth,refs,printer);};// Explicitly comparing sentinel properties to true avoids false positive
// when mock identity-obj-proxy returns the key as the value for any key.
Immutable$3.serialize=serialize$4;const test$4=val=>val&&(val[IS_ITERABLE_SENTINEL]===true||val[IS_RECORD_SENTINEL]===true);Immutable$3.test=test$4;const plugin$3={serialize:serialize$4,test:test$4};var _default$4=plugin$3;Immutable$3.default=_default$4;var ReactElement$3={};var reactIs={exports:{}};var reactIs_production_min={};/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactIs_production_min;function requireReactIs_production_min(){if(hasRequiredReactIs_production_min)return reactIs_production_min;hasRequiredReactIs_production_min=1;var b=Symbol.for("react.element"),c=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),e=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),g=Symbol.for("react.provider"),h=Symbol.for("react.context"),k=Symbol.for("react.server_context"),l=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),n=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),t=Symbol.for("react.offscreen"),u;u=Symbol.for("react.module.reference");function v(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r;}}case c:return r;}}}reactIs_production_min.ContextConsumer=h;reactIs_production_min.ContextProvider=g;reactIs_production_min.Element=b;reactIs_production_min.ForwardRef=l;reactIs_production_min.Fragment=d;reactIs_production_min.Lazy=q;reactIs_production_min.Memo=p;reactIs_production_min.Portal=c;reactIs_production_min.Profiler=f;reactIs_production_min.StrictMode=e;reactIs_production_min.Suspense=m;reactIs_production_min.SuspenseList=n;reactIs_production_min.isAsyncMode=function(){return!1;};reactIs_production_min.isConcurrentMode=function(){return!1;};reactIs_production_min.isContextConsumer=function(a){return v(a)===h;};reactIs_production_min.isContextProvider=function(a){return v(a)===g;};reactIs_production_min.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===b;};reactIs_production_min.isForwardRef=function(a){return v(a)===l;};reactIs_production_min.isFragment=function(a){return v(a)===d;};reactIs_production_min.isLazy=function(a){return v(a)===q;};reactIs_production_min.isMemo=function(a){return v(a)===p;};reactIs_production_min.isPortal=function(a){return v(a)===c;};reactIs_production_min.isProfiler=function(a){return v(a)===f;};reactIs_production_min.isStrictMode=function(a){return v(a)===e;};reactIs_production_min.isSuspense=function(a){return v(a)===m;};reactIs_production_min.isSuspenseList=function(a){return v(a)===n;};reactIs_production_min.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||"object"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1;};reactIs_production_min.typeOf=v;return reactIs_production_min;}var reactIs_development={};/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactIs_development;function requireReactIs_development(){if(hasRequiredReactIs_development)return reactIs_development;hasRequiredReactIs_development=1;if(process.env.NODE_ENV!=="production"){(function(){// -----------------------------------------------------------------------------
var enableScopeAPI=false;// Experimental Create Event Handle API.
var enableCacheElement=false;var enableTransitionTracing=false;// No known bugs, but needs performance testing
var enableLegacyHidden=false;// Enables unstable_avoidThisFallback feature in Fiber
// stuff. Intended to enable React core members to more easily debug scheduling
// issues in DEV builds.
var enableDebugTracing=false;// Track which Fiber(s) schedule render work.
// ATTENTION
var REACT_ELEMENT_TYPE=Symbol.for('react.element');var REACT_PORTAL_TYPE=Symbol.for('react.portal');var REACT_FRAGMENT_TYPE=Symbol.for('react.fragment');var REACT_STRICT_MODE_TYPE=Symbol.for('react.strict_mode');var REACT_PROFILER_TYPE=Symbol.for('react.profiler');var REACT_PROVIDER_TYPE=Symbol.for('react.provider');var REACT_CONTEXT_TYPE=Symbol.for('react.context');var REACT_SERVER_CONTEXT_TYPE=Symbol.for('react.server_context');var REACT_FORWARD_REF_TYPE=Symbol.for('react.forward_ref');var REACT_SUSPENSE_TYPE=Symbol.for('react.suspense');var REACT_SUSPENSE_LIST_TYPE=Symbol.for('react.suspense_list');var REACT_MEMO_TYPE=Symbol.for('react.memo');var REACT_LAZY_TYPE=Symbol.for('react.lazy');var REACT_OFFSCREEN_TYPE=Symbol.for('react.offscreen');var REACT_MODULE_REFERENCE;{REACT_MODULE_REFERENCE=Symbol.for('react.module.reference');}function isValidElementType(type){if(typeof type==='string'||typeof type==='function'){return true;}// Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).
if(type===REACT_FRAGMENT_TYPE||type===REACT_PROFILER_TYPE||enableDebugTracing||type===REACT_STRICT_MODE_TYPE||type===REACT_SUSPENSE_TYPE||type===REACT_SUSPENSE_LIST_TYPE||enableLegacyHidden||type===REACT_OFFSCREEN_TYPE||enableScopeAPI||enableCacheElement||enableTransitionTracing){return true;}if(typeof type==='object'&&type!==null){if(type.$$typeof===REACT_LAZY_TYPE||type.$$typeof===REACT_MEMO_TYPE||type.$$typeof===REACT_PROVIDER_TYPE||type.$$typeof===REACT_CONTEXT_TYPE||type.$$typeof===REACT_FORWARD_REF_TYPE||// This needs to include all possible module reference object
// types supported by any Flight configuration anywhere since
// we don't know which Flight build this will end up being used
// with.
type.$$typeof===REACT_MODULE_REFERENCE||type.getModuleId!==undefined){return true;}}return false;}function typeOf(object){if(typeof object==='object'&&object!==null){var $$typeof=object.$$typeof;switch($$typeof){case REACT_ELEMENT_TYPE:var type=object.type;switch(type){case REACT_FRAGMENT_TYPE:case REACT_PROFILER_TYPE:case REACT_STRICT_MODE_TYPE:case REACT_SUSPENSE_TYPE:case REACT_SUSPENSE_LIST_TYPE:return type;default:var $$typeofType=type&&type.$$typeof;switch($$typeofType){case REACT_SERVER_CONTEXT_TYPE:case REACT_CONTEXT_TYPE:case REACT_FORWARD_REF_TYPE:case REACT_LAZY_TYPE:case REACT_MEMO_TYPE:case REACT_PROVIDER_TYPE:return $$typeofType;default:return $$typeof;}}case REACT_PORTAL_TYPE:return $$typeof;}}return undefined;}var ContextConsumer=REACT_CONTEXT_TYPE;var ContextProvider=REACT_PROVIDER_TYPE;var Element=REACT_ELEMENT_TYPE;var ForwardRef=REACT_FORWARD_REF_TYPE;var Fragment=REACT_FRAGMENT_TYPE;var Lazy=REACT_LAZY_TYPE;var Memo=REACT_MEMO_TYPE;var Portal=REACT_PORTAL_TYPE;var Profiler=REACT_PROFILER_TYPE;var StrictMode=REACT_STRICT_MODE_TYPE;var Suspense=REACT_SUSPENSE_TYPE;var SuspenseList=REACT_SUSPENSE_LIST_TYPE;var hasWarnedAboutDeprecatedIsAsyncMode=false;var hasWarnedAboutDeprecatedIsConcurrentMode=false;// AsyncMode should be deprecated
function isAsyncMode(object){{if(!hasWarnedAboutDeprecatedIsAsyncMode){hasWarnedAboutDeprecatedIsAsyncMode=true;// Using console['warn'] to evade Babel and ESLint
console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, '+'and will be removed in React 18+.');}}return false;}function isConcurrentMode(object){{if(!hasWarnedAboutDeprecatedIsConcurrentMode){hasWarnedAboutDeprecatedIsConcurrentMode=true;// Using console['warn'] to evade Babel and ESLint
console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, '+'and will be removed in React 18+.');}}return false;}function isContextConsumer(object){return typeOf(object)===REACT_CONTEXT_TYPE;}function isContextProvider(object){return typeOf(object)===REACT_PROVIDER_TYPE;}function isElement(object){return typeof object==='object'&&object!==null&&object.$$typeof===REACT_ELEMENT_TYPE;}function isForwardRef(object){return typeOf(object)===REACT_FORWARD_REF_TYPE;}function isFragment(object){return typeOf(object)===REACT_FRAGMENT_TYPE;}function isLazy(object){return typeOf(object)===REACT_LAZY_TYPE;}function isMemo(object){return typeOf(object)===REACT_MEMO_TYPE;}function isPortal(object){return typeOf(object)===REACT_PORTAL_TYPE;}function isProfiler(object){return typeOf(object)===REACT_PROFILER_TYPE;}function isStrictMode(object){return typeOf(object)===REACT_STRICT_MODE_TYPE;}function isSuspense(object){return typeOf(object)===REACT_SUSPENSE_TYPE;}function isSuspenseList(object){return typeOf(object)===REACT_SUSPENSE_LIST_TYPE;}reactIs_development.ContextConsumer=ContextConsumer;reactIs_development.ContextProvider=ContextProvider;reactIs_development.Element=Element;reactIs_development.ForwardRef=ForwardRef;reactIs_development.Fragment=Fragment;reactIs_development.Lazy=Lazy;reactIs_development.Memo=Memo;reactIs_development.Portal=Portal;reactIs_development.Profiler=Profiler;reactIs_development.StrictMode=StrictMode;reactIs_development.Suspense=Suspense;reactIs_development.SuspenseList=SuspenseList;reactIs_development.isAsyncMode=isAsyncMode;reactIs_development.isConcurrentMode=isConcurrentMode;reactIs_development.isContextConsumer=isContextConsumer;reactIs_development.isContextProvider=isContextProvider;reactIs_development.isElement=isElement;reactIs_development.isForwardRef=isForwardRef;reactIs_development.isFragment=isFragment;reactIs_development.isLazy=isLazy;reactIs_development.isMemo=isMemo;reactIs_development.isPortal=isPortal;reactIs_development.isProfiler=isProfiler;reactIs_development.isStrictMode=isStrictMode;reactIs_development.isSuspense=isSuspense;reactIs_development.isSuspenseList=isSuspenseList;reactIs_development.isValidElementType=isValidElementType;reactIs_development.typeOf=typeOf;})();}return reactIs_development;}if(process.env.NODE_ENV==='production'){reactIs.exports=requireReactIs_production_min();}else{reactIs.exports=requireReactIs_development();}var reactIsExports=reactIs.exports;Object.defineProperty(ReactElement$3,'__esModule',{value:true});ReactElement$3.test=ReactElement$3.serialize=ReactElement$3.default=void 0;var ReactIs=_interopRequireWildcard(reactIsExports);var _markup$1=markup;function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!=='function')return null;var cacheBabelInterop=new WeakMap();var cacheNodeInterop=new WeakMap();return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj;}if(obj===null||typeof obj!=='object'&&typeof obj!=='function'){return{default:obj};}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj);}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!=='default'&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}newObj.default=obj;if(cache){cache.set(obj,newObj);}return newObj;}/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Given element.props.children, or subtree during recursive traversal,
// return flattened array of children.
const getChildren=(arg,children=[])=>{if(Array.isArray(arg)){arg.forEach(item=>{getChildren(item,children);});}else if(arg!=null&&arg!==false){children.push(arg);}return children;};const getType$1=element=>{const type=element.type;if(typeof type==='string'){return type;}if(typeof type==='function'){return type.displayName||type.name||'Unknown';}if(ReactIs.isFragment(element)){return'React.Fragment';}if(ReactIs.isSuspense(element)){return'React.Suspense';}if(typeof type==='object'&&type!==null){if(ReactIs.isContextProvider(element)){return'Context.Provider';}if(ReactIs.isContextConsumer(element)){return'Context.Consumer';}if(ReactIs.isForwardRef(element)){if(type.displayName){return type.displayName;}const functionName=type.render.displayName||type.render.name||'';return functionName!==''?\`ForwardRef(\${functionName})\`:'ForwardRef';}if(ReactIs.isMemo(element)){const functionName=type.displayName||type.type.displayName||type.type.name||'';return functionName!==''?\`Memo(\${functionName})\`:'Memo';}}return'UNDEFINED';};const getPropKeys$1=element=>{const props=element.props;return Object.keys(props).filter(key=>key!=='children'&&props[key]!==undefined).sort();};const serialize$3=(element,config,indentation,depth,refs,printer)=>++depth>config.maxDepth?(0,_markup$1.printElementAsLeaf)(getType$1(element),config):(0,_markup$1.printElement)(getType$1(element),(0,_markup$1.printProps)(getPropKeys$1(element),element.props,config,indentation+config.indent,depth,refs,printer),(0,_markup$1.printChildren)(getChildren(element.props.children),config,indentation+config.indent,depth,refs,printer),config,indentation);ReactElement$3.serialize=serialize$3;const test$3=val=>val!=null&&ReactIs.isElement(val);ReactElement$3.test=test$3;const plugin$2={serialize:serialize$3,test:test$3};var _default$3=plugin$2;ReactElement$3.default=_default$3;var ReactTestComponent$3={};Object.defineProperty(ReactTestComponent$3,'__esModule',{value:true});ReactTestComponent$3.test=ReactTestComponent$3.serialize=ReactTestComponent$3.default=void 0;var _markup=markup;var Symbol$1=globalThis['jest-symbol-do-not-touch']||globalThis.Symbol;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Child can be \`number\` in Stack renderer but not in Fiber renderer.
const testSymbol=typeof Symbol$1==='function'&&Symbol$1.for?Symbol$1.for('react.test.json'):0xea71357;const getPropKeys=object=>{const props=object.props;return props?Object.keys(props).filter(key=>props[key]!==undefined).sort():[];};const serialize$2=(object,config,indentation,depth,refs,printer)=>++depth>config.maxDepth?(0,_markup.printElementAsLeaf)(object.type,config):(0,_markup.printElement)(object.type,object.props?(0,_markup.printProps)(getPropKeys(object),object.props,config,indentation+config.indent,depth,refs,printer):'',object.children?(0,_markup.printChildren)(object.children,config,indentation+config.indent,depth,refs,printer):'',config,indentation);ReactTestComponent$3.serialize=serialize$2;const test$2=val=>val&&val.$$typeof===testSymbol;ReactTestComponent$3.test=test$2;const plugin$1={serialize:serialize$2,test:test$2};var _default$2=plugin$1;ReactTestComponent$3.default=_default$2;Object.defineProperty(build$1,'__esModule',{value:true});build$1.default=build$1.DEFAULT_OPTIONS=void 0;var format_1=build$1.format=format$1;var plugins_1=build$1.plugins=void 0;var _ansiStyles=_interopRequireDefault(ansiStylesExports);var _collections=collections;var _AsymmetricMatcher=_interopRequireDefault(AsymmetricMatcher$4);var _DOMCollection=_interopRequireDefault(DOMCollection$3);var _DOMElement=_interopRequireDefault(DOMElement$3);var _Immutable=_interopRequireDefault(Immutable$3);var _ReactElement=_interopRequireDefault(ReactElement$3);var _ReactTestComponent=_interopRequireDefault(ReactTestComponent$3);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ /* eslint-disable local/ban-types-eventually */const toString$2=Object.prototype.toString;const toISOString=Date.prototype.toISOString;const errorToString=Error.prototype.toString;const regExpToString=RegExp.prototype.toString;/**
 * Explicitly comparing typeof constructor to function avoids undefined as name
 * when mock identity-obj-proxy returns the key as the value for any key.
 */const getConstructorName$1=val=>typeof val.constructor==='function'&&val.constructor.name||'Object';/* global window */ /** Is val is equal to global window object? Works even if it does not exist :) */const isWindow=val=>typeof window!=='undefined'&&val===window;const SYMBOL_REGEXP=/^Symbol\\((.*)\\)(.*)$/;const NEWLINE_REGEXP=/\\n/gi;class PrettyFormatPluginError extends Error{constructor(message,stack){super(message);this.stack=stack;this.name=this.constructor.name;}}function isToStringedArrayType(toStringed){return toStringed==='[object Array]'||toStringed==='[object ArrayBuffer]'||toStringed==='[object DataView]'||toStringed==='[object Float32Array]'||toStringed==='[object Float64Array]'||toStringed==='[object Int8Array]'||toStringed==='[object Int16Array]'||toStringed==='[object Int32Array]'||toStringed==='[object Uint8Array]'||toStringed==='[object Uint8ClampedArray]'||toStringed==='[object Uint16Array]'||toStringed==='[object Uint32Array]';}function printNumber(val){return Object.is(val,-0)?'-0':String(val);}function printBigInt(val){return String(\`\${val}n\`);}function printFunction(val,printFunctionName){if(!printFunctionName){return'[Function]';}return\`[Function \${val.name||'anonymous'}]\`;}function printSymbol(val){return String(val).replace(SYMBOL_REGEXP,'Symbol($1)');}function printError(val){return\`[\${errorToString.call(val)}]\`;}/**
 * The first port of call for printing an object, handles most of the
 * data-types in JS.
 */function printBasicValue(val,printFunctionName,escapeRegex,escapeString){if(val===true||val===false){return\`\${val}\`;}if(val===undefined){return'undefined';}if(val===null){return'null';}const typeOf=typeof val;if(typeOf==='number'){return printNumber(val);}if(typeOf==='bigint'){return printBigInt(val);}if(typeOf==='string'){if(escapeString){return\`"\${val.replace(/"|\\\\/g,'\\\\$&')}"\`;}return\`"\${val}"\`;}if(typeOf==='function'){return printFunction(val,printFunctionName);}if(typeOf==='symbol'){return printSymbol(val);}const toStringed=toString$2.call(val);if(toStringed==='[object WeakMap]'){return'WeakMap {}';}if(toStringed==='[object WeakSet]'){return'WeakSet {}';}if(toStringed==='[object Function]'||toStringed==='[object GeneratorFunction]'){return printFunction(val,printFunctionName);}if(toStringed==='[object Symbol]'){return printSymbol(val);}if(toStringed==='[object Date]'){return isNaN(+val)?'Date { NaN }':toISOString.call(val);}if(toStringed==='[object Error]'){return printError(val);}if(toStringed==='[object RegExp]'){if(escapeRegex){// https://github.com/benjamingr/RegExp.escape/blob/main/polyfill.js
return regExpToString.call(val).replace(/[\\\\^$*+?.()|[\\]{}]/g,'\\\\$&');}return regExpToString.call(val);}if(val instanceof Error){return printError(val);}return null;}/**
 * Handles more complex objects ( such as objects with circular references.
 * maps and sets etc )
 */function printComplexValue(val,config,indentation,depth,refs,hasCalledToJSON){if(refs.indexOf(val)!==-1){return'[Circular]';}refs=refs.slice();refs.push(val);const hitMaxDepth=++depth>config.maxDepth;const min=config.min;if(config.callToJSON&&!hitMaxDepth&&val.toJSON&&typeof val.toJSON==='function'&&!hasCalledToJSON){return printer(val.toJSON(),config,indentation,depth,refs,true);}const toStringed=toString$2.call(val);if(toStringed==='[object Arguments]'){return hitMaxDepth?'[Arguments]':\`\${min?'':'Arguments '}[\${(0,_collections.printListItems)(val,config,indentation,depth,refs,printer)}]\`;}if(isToStringedArrayType(toStringed)){return hitMaxDepth?\`[\${val.constructor.name}]\`:\`\${min?'':!config.printBasicPrototype&&val.constructor.name==='Array'?'':\`\${val.constructor.name} \`}[\${(0,_collections.printListItems)(val,config,indentation,depth,refs,printer)}]\`;}if(toStringed==='[object Map]'){return hitMaxDepth?'[Map]':\`Map {\${(0,_collections.printIteratorEntries)(val.entries(),config,indentation,depth,refs,printer,' => ')}}\`;}if(toStringed==='[object Set]'){return hitMaxDepth?'[Set]':\`Set {\${(0,_collections.printIteratorValues)(val.values(),config,indentation,depth,refs,printer)}}\`;}// Avoid failure to serialize global window object in jsdom test environment.
// For example, not even relevant if window is prop of React element.
return hitMaxDepth||isWindow(val)?\`[\${getConstructorName$1(val)}]\`:\`\${min?'':!config.printBasicPrototype&&getConstructorName$1(val)==='Object'?'':\`\${getConstructorName$1(val)} \`}{\${(0,_collections.printObjectProperties)(val,config,indentation,depth,refs,printer)}}\`;}function isNewPlugin(plugin){return plugin.serialize!=null;}function printPlugin(plugin,val,config,indentation,depth,refs){let printed;try{printed=isNewPlugin(plugin)?plugin.serialize(val,config,indentation,depth,refs,printer):plugin.print(val,valChild=>printer(valChild,config,indentation,depth,refs),str=>{const indentationNext=indentation+config.indent;return indentationNext+str.replace(NEWLINE_REGEXP,\`\\n\${indentationNext}\`);},{edgeSpacing:config.spacingOuter,min:config.min,spacing:config.spacingInner},config.colors);}catch(error){throw new PrettyFormatPluginError(error.message,error.stack);}if(typeof printed!=='string'){throw new Error(\`pretty-format: Plugin must return type "string" but instead returned "\${typeof printed}".\`);}return printed;}function findPlugin(plugins,val){for(let p=0;p<plugins.length;p++){try{if(plugins[p].test(val)){return plugins[p];}}catch(error){throw new PrettyFormatPluginError(error.message,error.stack);}}return null;}function printer(val,config,indentation,depth,refs,hasCalledToJSON){const plugin=findPlugin(config.plugins,val);if(plugin!==null){return printPlugin(plugin,val,config,indentation,depth,refs);}const basicResult=printBasicValue(val,config.printFunctionName,config.escapeRegex,config.escapeString);if(basicResult!==null){return basicResult;}return printComplexValue(val,config,indentation,depth,refs,hasCalledToJSON);}const DEFAULT_THEME={comment:'gray',content:'reset',prop:'yellow',tag:'cyan',value:'green'};const DEFAULT_THEME_KEYS=Object.keys(DEFAULT_THEME);// could be replaced by \`satisfies\` operator in the future: https://github.com/microsoft/TypeScript/issues/47920
const toOptionsSubtype=options=>options;const DEFAULT_OPTIONS=toOptionsSubtype({callToJSON:true,compareKeys:undefined,escapeRegex:false,escapeString:true,highlight:false,indent:2,maxDepth:Infinity,maxWidth:Infinity,min:false,plugins:[],printBasicPrototype:true,printFunctionName:true,theme:DEFAULT_THEME});build$1.DEFAULT_OPTIONS=DEFAULT_OPTIONS;function validateOptions(options){Object.keys(options).forEach(key=>{if(!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS,key)){throw new Error(\`pretty-format: Unknown option "\${key}".\`);}});if(options.min&&options.indent!==undefined&&options.indent!==0){throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');}if(options.theme!==undefined){if(options.theme===null){throw new Error('pretty-format: Option "theme" must not be null.');}if(typeof options.theme!=='object'){throw new Error(\`pretty-format: Option "theme" must be of type "object" but instead received "\${typeof options.theme}".\`);}}}const getColorsHighlight=options=>DEFAULT_THEME_KEYS.reduce((colors,key)=>{const value=options.theme&&options.theme[key]!==undefined?options.theme[key]:DEFAULT_THEME[key];const color=value&&_ansiStyles.default[value];if(color&&typeof color.close==='string'&&typeof color.open==='string'){colors[key]=color;}else{throw new Error(\`pretty-format: Option "theme" has a key "\${key}" whose value "\${value}" is undefined in ansi-styles.\`);}return colors;},Object.create(null));const getColorsEmpty=()=>DEFAULT_THEME_KEYS.reduce((colors,key)=>{colors[key]={close:'',open:''};return colors;},Object.create(null));const getPrintFunctionName=options=>options?.printFunctionName??DEFAULT_OPTIONS.printFunctionName;const getEscapeRegex=options=>options?.escapeRegex??DEFAULT_OPTIONS.escapeRegex;const getEscapeString=options=>options?.escapeString??DEFAULT_OPTIONS.escapeString;const getConfig=options=>({callToJSON:options?.callToJSON??DEFAULT_OPTIONS.callToJSON,colors:options?.highlight?getColorsHighlight(options):getColorsEmpty(),compareKeys:typeof options?.compareKeys==='function'||options?.compareKeys===null?options.compareKeys:DEFAULT_OPTIONS.compareKeys,escapeRegex:getEscapeRegex(options),escapeString:getEscapeString(options),indent:options?.min?'':createIndent(options?.indent??DEFAULT_OPTIONS.indent),maxDepth:options?.maxDepth??DEFAULT_OPTIONS.maxDepth,maxWidth:options?.maxWidth??DEFAULT_OPTIONS.maxWidth,min:options?.min??DEFAULT_OPTIONS.min,plugins:options?.plugins??DEFAULT_OPTIONS.plugins,printBasicPrototype:options?.printBasicPrototype??true,printFunctionName:getPrintFunctionName(options),spacingInner:options?.min?' ':'\\n',spacingOuter:options?.min?'':'\\n'});function createIndent(indent){return new Array(indent+1).join(' ');}/**
 * Returns a presentation string of your \`val\` object
 * @param val any potential JavaScript object
 * @param options Custom settings
 */function format$1(val,options){if(options){validateOptions(options);if(options.plugins){const plugin=findPlugin(options.plugins,val);if(plugin!==null){return printPlugin(plugin,val,getConfig(options),'',0,[]);}}}const basicResult=printBasicValue(val,getPrintFunctionName(options),getEscapeRegex(options),getEscapeString(options));if(basicResult!==null){return basicResult;}return printComplexValue(val,getConfig(options),'',0,[]);}const plugins={AsymmetricMatcher:_AsymmetricMatcher.default,DOMCollection:_DOMCollection.default,DOMElement:_DOMElement.default,Immutable:_Immutable.default,ReactElement:_ReactElement.default,ReactTestComponent:_ReactTestComponent.default};plugins_1=build$1.plugins=plugins;var _default$1=format$1;build$1.default=_default$1;const ansiColors={bold:['1','22'],dim:['2','22'],italic:['3','23'],underline:['4','24'],// 5 & 6 are blinking
inverse:['7','27'],hidden:['8','28'],strike:['9','29'],// 10-20 are fonts
// 21-29 are resets for 1-9
black:['30','39'],red:['31','39'],green:['32','39'],yellow:['33','39'],blue:['34','39'],magenta:['35','39'],cyan:['36','39'],white:['37','39'],brightblack:['30;1','39'],brightred:['31;1','39'],brightgreen:['32;1','39'],brightyellow:['33;1','39'],brightblue:['34;1','39'],brightmagenta:['35;1','39'],brightcyan:['36;1','39'],brightwhite:['37;1','39'],grey:['90','39']};const styles={special:'cyan',number:'yellow',bigint:'yellow',boolean:'yellow',undefined:'grey',null:'bold',string:'green',symbol:'green',date:'magenta',regexp:'red'};const truncator='…';function colorise(value,styleType){const color=ansiColors[styles[styleType]]||ansiColors[styleType];if(!color){return String(value);}return\`\\u001b[\${color[0]}m\${String(value)}\\u001b[\${color[1]}m\`;}function normaliseOptions({showHidden=false,depth=2,colors=false,customInspect=true,showProxy=false,maxArrayLength=Infinity,breakLength=Infinity,seen=[],// eslint-disable-next-line no-shadow
truncate=Infinity,stylize=String}={}){const options={showHidden:Boolean(showHidden),depth:Number(depth),colors:Boolean(colors),customInspect:Boolean(customInspect),showProxy:Boolean(showProxy),maxArrayLength:Number(maxArrayLength),breakLength:Number(breakLength),truncate:Number(truncate),seen,stylize};if(options.colors){options.stylize=colorise;}return options;}function truncate(string,length,tail=truncator){string=String(string);const tailLength=tail.length;const stringLength=string.length;if(tailLength>length&&stringLength>tailLength){return tail;}if(stringLength>length&&stringLength>tailLength){return\`\${string.slice(0,length-tailLength)}\${tail}\`;}return string;}// eslint-disable-next-line complexity
function inspectList(list,options,inspectItem,separator=', '){inspectItem=inspectItem||options.inspect;const size=list.length;if(size===0)return'';const originalLength=options.truncate;let output='';let peek='';let truncated='';for(let i=0;i<size;i+=1){const last=i+1===list.length;const secondToLast=i+2===list.length;truncated=\`\${truncator}(\${list.length-i})\`;const value=list[i];// If there is more than one remaining we need to account for a separator of \`, \`
options.truncate=originalLength-output.length-(last?0:separator.length);const string=peek||inspectItem(value,options)+(last?'':separator);const nextLength=output.length+string.length;const truncatedLength=nextLength+truncated.length;// If this is the last element, and adding it would
// take us over length, but adding the truncator wouldn't - then break now
if(last&&nextLength>originalLength&&output.length+truncated.length<=originalLength){break;}// If this isn't the last or second to last element to scan,
// but the string is already over length then break here
if(!last&&!secondToLast&&truncatedLength>originalLength){break;}// Peek at the next string to determine if we should
// break early before adding this item to the output
peek=last?'':inspectItem(list[i+1],options)+(secondToLast?'':separator);// If we have one element left, but this element and
// the next takes over length, the break early
if(!last&&secondToLast&&truncatedLength>originalLength&&nextLength+peek.length>originalLength){break;}output+=string;// If the next element takes us to length -
// but there are more after that, then we should truncate now
if(!last&&!secondToLast&&nextLength+peek.length>=originalLength){truncated=\`\${truncator}(\${list.length-i-1})\`;break;}truncated='';}return\`\${output}\${truncated}\`;}function quoteComplexKey(key){if(key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)){return key;}return JSON.stringify(key).replace(/'/g,"\\\\'").replace(/\\\\"/g,'"').replace(/(^"|"$)/g,"'");}function inspectProperty([key,value],options){options.truncate-=2;if(typeof key==='string'){key=quoteComplexKey(key);}else if(typeof key!=='number'){key=\`[\${options.inspect(key,options)}]\`;}options.truncate-=key.length;value=options.inspect(value,options);return\`\${key}: \${value}\`;}function inspectArray(array,options){// Object.keys will always output the Array indices first, so we can slice by
// \`array.length\` to get non-index properties
const nonIndexProperties=Object.keys(array).slice(array.length);if(!array.length&&!nonIndexProperties.length)return'[]';options.truncate-=4;const listContents=inspectList(array,options);options.truncate-=listContents.length;let propertyContents='';if(nonIndexProperties.length){propertyContents=inspectList(nonIndexProperties.map(key=>[key,array[key]]),options,inspectProperty);}return\`[ \${listContents}\${propertyContents?\`, \${propertyContents}\`:''} ]\`;}/* !
 * Chai - getFuncName utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .getFuncName(constructorFn)
 *
 * Returns the name of a function.
 * When a non-function instance is passed, returns \`null\`.
 * This also includes a polyfill function if \`aFunc.name\` is not defined.
 *
 * @name getFuncName
 * @param {Function} funct
 * @namespace Utils
 * @api public
 */var toString$1=Function.prototype.toString;var functionNameMatch=/\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\s\\(\\/]+)/;var maxFunctionSourceLength=512;function getFuncName(aFunc){if(typeof aFunc!=='function'){return null;}var name='';if(typeof Function.prototype.name==='undefined'&&typeof aFunc.name==='undefined'){// eslint-disable-next-line prefer-reflect
var functionSource=toString$1.call(aFunc);// To avoid unconstrained resource consumption due to pathalogically large function names,
// we limit the available return value to be less than 512 characters.
if(functionSource.indexOf('(')>maxFunctionSourceLength){return name;}// Here we run a polyfill if Function does not support the \`name\` property and if aFunc.name is not defined
var match=functionSource.match(functionNameMatch);if(match){name=match[1];}}else{// If we've got a \`name\` property we just use it
name=aFunc.name;}return name;}var getFuncName_1=getFuncName;const getFuncName$1=/*@__PURE__*/getDefaultExportFromCjs$2(getFuncName_1);const getArrayName=array=>{// We need to special case Node.js' Buffers, which report to be Uint8Array
if(typeof Buffer==='function'&&array instanceof Buffer){return'Buffer';}if(array[Symbol.toStringTag]){return array[Symbol.toStringTag];}return getFuncName$1(array.constructor);};function inspectTypedArray(array,options){const name=getArrayName(array);options.truncate-=name.length+4;// Object.keys will always output the Array indices first, so we can slice by
// \`array.length\` to get non-index properties
const nonIndexProperties=Object.keys(array).slice(array.length);if(!array.length&&!nonIndexProperties.length)return\`\${name}[]\`;// As we know TypedArrays only contain Unsigned Integers, we can skip inspecting each one and simply
// stylise the toString() value of them
let output='';for(let i=0;i<array.length;i++){const string=\`\${options.stylize(truncate(array[i],options.truncate),'number')}\${i===array.length-1?'':', '}\`;options.truncate-=string.length;if(array[i]!==array.length&&options.truncate<=3){output+=\`\${truncator}(\${array.length-array[i]+1})\`;break;}output+=string;}let propertyContents='';if(nonIndexProperties.length){propertyContents=inspectList(nonIndexProperties.map(key=>[key,array[key]]),options,inspectProperty);}return\`\${name}[ \${output}\${propertyContents?\`, \${propertyContents}\`:''} ]\`;}function inspectDate(dateObject,options){const stringRepresentation=dateObject.toJSON();if(stringRepresentation===null){return'Invalid Date';}const split=stringRepresentation.split('T');const date=split[0];// If we need to - truncate the time portion, but never the date
return options.stylize(\`\${date}T\${truncate(split[1],options.truncate-date.length-1)}\`,'date');}function inspectFunction(func,options){const name=getFuncName$1(func);if(!name){return options.stylize('[Function]','special');}return options.stylize(\`[Function \${truncate(name,options.truncate-11)}]\`,'special');}function inspectMapEntry([key,value],options){options.truncate-=4;key=options.inspect(key,options);options.truncate-=key.length;value=options.inspect(value,options);return\`\${key} => \${value}\`;}// IE11 doesn't support \`map.entries()\`
function mapToEntries(map){const entries=[];map.forEach((value,key)=>{entries.push([key,value]);});return entries;}function inspectMap(map,options){const size=map.size-1;if(size<=0){return'Map{}';}options.truncate-=7;return\`Map{ \${inspectList(mapToEntries(map),options,inspectMapEntry)} }\`;}const isNaN$2=Number.isNaN||(i=>i!==i);// eslint-disable-line no-self-compare
function inspectNumber(number,options){if(isNaN$2(number)){return options.stylize('NaN','number');}if(number===Infinity){return options.stylize('Infinity','number');}if(number===-Infinity){return options.stylize('-Infinity','number');}if(number===0){return options.stylize(1/number===Infinity?'+0':'-0','number');}return options.stylize(truncate(number,options.truncate),'number');}function inspectBigInt(number,options){let nums=truncate(number.toString(),options.truncate-1);if(nums!==truncator)nums+='n';return options.stylize(nums,'bigint');}function inspectRegExp(value,options){const flags=value.toString().split('/')[2];const sourceLength=options.truncate-(2+flags.length);const source=value.source;return options.stylize(\`/\${truncate(source,sourceLength)}/\${flags}\`,'regexp');}// IE11 doesn't support \`Array.from(set)\`
function arrayFromSet(set){const values=[];set.forEach(value=>{values.push(value);});return values;}function inspectSet(set,options){if(set.size===0)return'Set{}';options.truncate-=7;return\`Set{ \${inspectList(arrayFromSet(set),options)} }\`;}const stringEscapeChars=new RegExp("['\\\\u0000-\\\\u001f\\\\u007f-\\\\u009f\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5"+'\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]','g');const escapeCharacters={'\\b':'\\\\b','\\t':'\\\\t','\\n':'\\\\n','\\f':'\\\\f','\\r':'\\\\r',"'":"\\\\'",'\\\\':'\\\\\\\\'};const hex=16;const unicodeLength=4;function escape(char){return escapeCharacters[char]||\`\\\\u\${\`0000\${char.charCodeAt(0).toString(hex)}\`.slice(-unicodeLength)}\`;}function inspectString(string,options){if(stringEscapeChars.test(string)){string=string.replace(stringEscapeChars,escape);}return options.stylize(\`'\${truncate(string,options.truncate-2)}'\`,'string');}function inspectSymbol(value){if('description'in Symbol.prototype){return value.description?\`Symbol(\${value.description})\`:'Symbol()';}return value.toString();}let getPromiseValue$1=()=>'Promise{…}';try{const _process$binding=process.binding('util'),getPromiseDetails=_process$binding.getPromiseDetails,kPending=_process$binding.kPending,kRejected=_process$binding.kRejected;if(Array.isArray(getPromiseDetails(Promise.resolve()))){getPromiseValue$1=(value,options)=>{const _getPromiseDetails=getPromiseDetails(value),_getPromiseDetails2=_slicedToArray(_getPromiseDetails,2),state=_getPromiseDetails2[0],innerValue=_getPromiseDetails2[1];if(state===kPending){return'Promise{<pending>}';}return\`Promise\${state===kRejected?'!':''}{\${options.inspect(innerValue,options)}}\`;};}}catch(notNode){/* ignore */}const inspectPromise=getPromiseValue$1;function inspectObject$1(object,options){const properties=Object.getOwnPropertyNames(object);const symbols=Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(object):[];if(properties.length===0&&symbols.length===0){return'{}';}options.truncate-=4;options.seen=options.seen||[];if(options.seen.indexOf(object)>=0){return'[Circular]';}options.seen.push(object);const propertyContents=inspectList(properties.map(key=>[key,object[key]]),options,inspectProperty);const symbolContents=inspectList(symbols.map(key=>[key,object[key]]),options,inspectProperty);options.seen.pop();let sep='';if(propertyContents&&symbolContents){sep=', ';}return\`{ \${propertyContents}\${sep}\${symbolContents} }\`;}const toStringTag=typeof Symbol!=='undefined'&&Symbol.toStringTag?Symbol.toStringTag:false;function inspectClass(value,options){let name='';if(toStringTag&&toStringTag in value){name=value[toStringTag];}name=name||getFuncName$1(value.constructor);// Babel transforms anonymous classes to the name \`_class\`
if(!name||name==='_class'){name='<Anonymous Class>';}options.truncate-=name.length;return\`\${name}\${inspectObject$1(value,options)}\`;}function inspectArguments(args,options){if(args.length===0)return'Arguments[]';options.truncate-=13;return\`Arguments[ \${inspectList(args,options)} ]\`;}const errorKeys=['stack','line','column','name','message','fileName','lineNumber','columnNumber','number','description'];function inspectObject(error,options){const properties=Object.getOwnPropertyNames(error).filter(key=>errorKeys.indexOf(key)===-1);const name=error.name;options.truncate-=name.length;let message='';if(typeof error.message==='string'){message=truncate(error.message,options.truncate);}else{properties.unshift('message');}message=message?\`: \${message}\`:'';options.truncate-=message.length+5;const propertyContents=inspectList(properties.map(key=>[key,error[key]]),options,inspectProperty);return\`\${name}\${message}\${propertyContents?\` { \${propertyContents} }\`:''}\`;}function inspectAttribute([key,value],options){options.truncate-=3;if(!value){return\`\${options.stylize(key,'yellow')}\`;}return\`\${options.stylize(key,'yellow')}=\${options.stylize(\`"\${value}"\`,'string')}\`;}function inspectHTMLCollection(collection,options){// eslint-disable-next-line no-use-before-define
return inspectList(collection,options,inspectHTML,'\\n');}function inspectHTML(element,options){const properties=element.getAttributeNames();const name=element.tagName.toLowerCase();const head=options.stylize(\`<\${name}\`,'special');const headClose=options.stylize(\`>\`,'special');const tail=options.stylize(\`</\${name}>\`,'special');options.truncate-=name.length*2+5;let propertyContents='';if(properties.length>0){propertyContents+=' ';propertyContents+=inspectList(properties.map(key=>[key,element.getAttribute(key)]),options,inspectAttribute,' ');}options.truncate-=propertyContents.length;const truncate=options.truncate;let children=inspectHTMLCollection(element.children,options);if(children&&children.length>truncate){children=\`\${truncator}(\${element.children.length})\`;}return\`\${head}\${propertyContents}\${headClose}\${children}\${tail}\`;}/* !
 * loupe
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */const symbolsSupported=typeof Symbol==='function'&&typeof Symbol.for==='function';const chaiInspect=symbolsSupported?Symbol.for('chai/inspect'):'@@chai/inspect';let nodeInspect$1=false;try{// eslint-disable-next-line global-require
const nodeUtil=require('util');nodeInspect$1=nodeUtil.inspect?nodeUtil.inspect.custom:false;}catch(noNodeInspect){nodeInspect$1=false;}function FakeMap$1(){// eslint-disable-next-line prefer-template
this.key='chai/loupe__'+Math.random()+Date.now();}FakeMap$1.prototype={// eslint-disable-next-line object-shorthand
get:function get(key){return key[this.key];},// eslint-disable-next-line object-shorthand
has:function has(key){return this.key in key;},// eslint-disable-next-line object-shorthand
set:function set(key,value){if(Object.isExtensible(key)){Object.defineProperty(key,this.key,{// eslint-disable-next-line object-shorthand
value:value,configurable:true});}}};const constructorMap=new(typeof WeakMap==='function'?WeakMap:FakeMap$1)();const stringTagMap={};const baseTypesMap={undefined:(value,options)=>options.stylize('undefined','undefined'),null:(value,options)=>options.stylize(null,'null'),boolean:(value,options)=>options.stylize(value,'boolean'),Boolean:(value,options)=>options.stylize(value,'boolean'),number:inspectNumber,Number:inspectNumber,bigint:inspectBigInt,BigInt:inspectBigInt,string:inspectString,String:inspectString,function:inspectFunction,Function:inspectFunction,symbol:inspectSymbol,// A Symbol polyfill will return \`Symbol\` not \`symbol\` from typedetect
Symbol:inspectSymbol,Array:inspectArray,Date:inspectDate,Map:inspectMap,Set:inspectSet,RegExp:inspectRegExp,Promise:inspectPromise,// WeakSet, WeakMap are totally opaque to us
WeakSet:(value,options)=>options.stylize('WeakSet{…}','special'),WeakMap:(value,options)=>options.stylize('WeakMap{…}','special'),Arguments:inspectArguments,Int8Array:inspectTypedArray,Uint8Array:inspectTypedArray,Uint8ClampedArray:inspectTypedArray,Int16Array:inspectTypedArray,Uint16Array:inspectTypedArray,Int32Array:inspectTypedArray,Uint32Array:inspectTypedArray,Float32Array:inspectTypedArray,Float64Array:inspectTypedArray,Generator:()=>'',DataView:()=>'',ArrayBuffer:()=>'',Error:inspectObject,HTMLCollection:inspectHTMLCollection,NodeList:inspectHTMLCollection};// eslint-disable-next-line complexity
const inspectCustom=(value,options,type)=>{if(chaiInspect in value&&typeof value[chaiInspect]==='function'){return value[chaiInspect](options);}if(nodeInspect$1&&nodeInspect$1 in value&&typeof value[nodeInspect$1]==='function'){return value[nodeInspect$1](options.depth,options);}if('inspect'in value&&typeof value.inspect==='function'){return value.inspect(options.depth,options);}if('constructor'in value&&constructorMap.has(value.constructor)){return constructorMap.get(value.constructor)(value,options);}if(stringTagMap[type]){return stringTagMap[type](value,options);}return'';};const toString=Object.prototype.toString;// eslint-disable-next-line complexity
function inspect$4(value,options){options=normaliseOptions(options);options.inspect=inspect$4;const _options2=options,customInspect=_options2.customInspect;let type=value===null?'null':typeof value;if(type==='object'){type=toString.call(value).slice(8,-1);}// If it is a base value that we already support, then use Loupe's inspector
if(baseTypesMap[type]){return baseTypesMap[type](value,options);}// If \`options.customInspect\` is set to true then try to use the custom inspector
if(customInspect&&value){const output=inspectCustom(value,options,type);if(output){if(typeof output==='string')return output;return inspect$4(output,options);}}const proto=value?Object.getPrototypeOf(value):false;// If it's a plain Object then use Loupe's inspector
if(proto===Object.prototype||proto===null){return inspectObject$1(value,options);}// Specifically account for HTMLElements
// eslint-disable-next-line no-undef
if(value&&typeof HTMLElement==='function'&&value instanceof HTMLElement){return inspectHTML(value,options);}if('constructor'in value){// If it is a class, inspect it like an object but add the constructor name
if(value.constructor!==Object){return inspectClass(value,options);}// If it is an object with an anonymous prototype, display it as an object.
return inspectObject$1(value,options);}// last chance to check if it's an object
if(value===Object(value)){return inspectObject$1(value,options);}// We have run out of options! Just stringify the value
return options.stylize(String(value),type);}function registerConstructor(constructor,inspector){if(constructorMap.has(constructor)){return false;}constructorMap.set(constructor,inspector);return true;}function registerStringTag(stringTag,inspector){if(stringTag in stringTagMap){return false;}stringTagMap[stringTag]=inspector;return true;}const custom=chaiInspect;const loupe$1=/*#__PURE__*/Object.freeze({__proto__:null,custom,default:inspect$4,inspect:inspect$4,registerConstructor,registerStringTag});const _plugins_=plugins_1,AsymmetricMatcher$3=_plugins_.AsymmetricMatcher,DOMCollection$2=_plugins_.DOMCollection,DOMElement$2=_plugins_.DOMElement,Immutable$2=_plugins_.Immutable,ReactElement$2=_plugins_.ReactElement,ReactTestComponent$2=_plugins_.ReactTestComponent;const PLUGINS$2=[ReactTestComponent$2,ReactElement$2,DOMElement$2,DOMCollection$2,Immutable$2,AsymmetricMatcher$3];function stringify(object,maxDepth=10,_ref5={}){let maxLength=_ref5.maxLength,options=_objectWithoutProperties(_ref5,_excluded);const MAX_LENGTH=maxLength??1e4;let result;try{result=format_1(object,_objectSpread({maxDepth,escapeString:false,// min: true,
plugins:PLUGINS$2},options));}catch{result=format_1(object,_objectSpread({callToJSON:false,maxDepth,escapeString:false,// min: true,
plugins:PLUGINS$2},options));}return result.length>=MAX_LENGTH&&maxDepth>1?stringify(object,Math.floor(maxDepth/2)):result;}const formatRegExp=/%[sdjifoOcj%]/g;function format(...args){if(typeof args[0]!=="string"){const objects=[];for(let i2=0;i2<args.length;i2++)objects.push(inspect$3(args[i2],{depth:0,colors:false,compact:3}));return objects.join(" ");}const len=args.length;let i=1;const template=args[0];let str=String(template).replace(formatRegExp,x=>{if(x==="%%")return"%";if(i>=len)return x;switch(x){case"%s":{const value=args[i++];if(typeof value==="bigint")return\`\${value.toString()}n\`;if(typeof value==="number"&&value===0&&1/value<0)return"-0";if(typeof value==="object"&&value!==null)return inspect$3(value,{depth:0,colors:false,compact:3});return String(value);}case"%d":{const value=args[i++];if(typeof value==="bigint")return\`\${value.toString()}n\`;return Number(value).toString();}case"%i":{const value=args[i++];if(typeof value==="bigint")return\`\${value.toString()}n\`;return Number.parseInt(String(value)).toString();}case"%f":return Number.parseFloat(String(args[i++])).toString();case"%o":return inspect$3(args[i++],{showHidden:true,showProxy:true});case"%O":return inspect$3(args[i++]);case"%c":{i++;return"";}case"%j":try{return JSON.stringify(args[i++]);}catch(err){const m=err.message;if(// chromium
m.includes("circular structure")||m.includes("cyclic structures")||m.includes("cyclic object"))return"[Circular]";throw err;}default:return x;}});for(let x=args[i];i<len;x=args[++i]){if(x===null||typeof x!=="object")str+=\` \${x}\`;else str+=\` \${inspect$3(x)}\`;}return str;}function inspect$3(obj,options={}){if(options.truncate===0)options.truncate=Number.POSITIVE_INFINITY;return inspect$4(obj,options);}function objDisplay$2(obj,options={}){if(typeof options.truncate==="undefined")options.truncate=40;const str=inspect$3(obj,options);const type=Object.prototype.toString.call(obj);if(options.truncate&&str.length>=options.truncate){if(type==="[object Function]"){const fn=obj;return!fn.name?"[Function]":\`[Function: \${fn.name}]\`;}else if(type==="[object Array]"){return\`[ Array(\${obj.length}) ]\`;}else if(type==="[object Object]"){const keys=Object.keys(obj);const kstr=keys.length>2?\`\${keys.splice(0,2).join(", ")}, ...\`:keys.join(", ");return\`{ Object (\${kstr}) }\`;}else{return str;}}return str;}const SAFE_TIMERS_SYMBOL=Symbol("vitest:SAFE_TIMERS");const SAFE_COLORS_SYMBOL=Symbol("vitest:SAFE_COLORS");const colorsMap={bold:["\\x1B[1m","\\x1B[22m","\\x1B[22m\\x1B[1m"],dim:["\\x1B[2m","\\x1B[22m","\\x1B[22m\\x1B[2m"],italic:["\\x1B[3m","\\x1B[23m"],underline:["\\x1B[4m","\\x1B[24m"],inverse:["\\x1B[7m","\\x1B[27m"],hidden:["\\x1B[8m","\\x1B[28m"],strikethrough:["\\x1B[9m","\\x1B[29m"],black:["\\x1B[30m","\\x1B[39m"],red:["\\x1B[31m","\\x1B[39m"],green:["\\x1B[32m","\\x1B[39m"],yellow:["\\x1B[33m","\\x1B[39m"],blue:["\\x1B[34m","\\x1B[39m"],magenta:["\\x1B[35m","\\x1B[39m"],cyan:["\\x1B[36m","\\x1B[39m"],white:["\\x1B[37m","\\x1B[39m"],gray:["\\x1B[90m","\\x1B[39m"],bgBlack:["\\x1B[40m","\\x1B[49m"],bgRed:["\\x1B[41m","\\x1B[49m"],bgGreen:["\\x1B[42m","\\x1B[49m"],bgYellow:["\\x1B[43m","\\x1B[49m"],bgBlue:["\\x1B[44m","\\x1B[49m"],bgMagenta:["\\x1B[45m","\\x1B[49m"],bgCyan:["\\x1B[46m","\\x1B[49m"],bgWhite:["\\x1B[47m","\\x1B[49m"]};const colorsEntries=Object.entries(colorsMap);function string$1(str){return String(str);}string$1.open="";string$1.close="";const defaultColors=/* @__PURE__ */colorsEntries.reduce((acc,[key])=>{acc[key]=string$1;return acc;},{isColorSupported:false});function getColors(){return globalThis[SAFE_COLORS_SYMBOL]||defaultColors;}function getSafeTimers(){const _ref6=globalThis[SAFE_TIMERS_SYMBOL]||globalThis,safeSetTimeout=_ref6.setTimeout,safeSetInterval=_ref6.setInterval,safeClearInterval=_ref6.clearInterval,safeClearTimeout=_ref6.clearTimeout,safeSetImmediate=_ref6.setImmediate,safeClearImmediate=_ref6.clearImmediate;const _ref7=globalThis[SAFE_TIMERS_SYMBOL]||globalThis.process||{nextTick:cb=>cb()},safeNextTick=_ref7.nextTick;return{nextTick:safeNextTick,setTimeout:safeSetTimeout,setInterval:safeSetInterval,clearInterval:safeClearInterval,clearTimeout:safeClearTimeout,setImmediate:safeSetImmediate,clearImmediate:safeClearImmediate};}function createSimpleStackTrace(options){const _ref8=options||{},_ref8$message=_ref8.message,message=_ref8$message===void 0?"error":_ref8$message,_ref8$stackTraceLimit=_ref8.stackTraceLimit,stackTraceLimit=_ref8$stackTraceLimit===void 0?1:_ref8$stackTraceLimit;const limit=Error.stackTraceLimit;const prepareStackTrace=Error.prepareStackTrace;Error.stackTraceLimit=stackTraceLimit;Error.prepareStackTrace=e=>e.stack;const err=new Error(message);const stackTrace=err.stack||"";Error.prepareStackTrace=prepareStackTrace;Error.stackTraceLimit=limit;return stackTrace;}// Copyright 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023 Simon Lydell
// License: MIT.
var LineTerminatorSequence$1;LineTerminatorSequence$1=/\\r?\\n|[\\r\\u2028\\u2029]/y;RegExp(LineTerminatorSequence$1.source);// src/index.ts
var reservedWords$1={keyword:["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"],strict:["implements","interface","let","package","private","protected","public","static","yield"]};new Set(reservedWords$1.keyword);new Set(reservedWords$1.strict);var build={};Object.defineProperty(build,'__esModule',{value:true});var _default=build.default=diffSequence;/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ // This diff-sequences package implements the linear space variation in
// An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers
// Relationship in notation between Myers paper and this package:
// A is a
// N is aLength, aEnd - aStart, and so on
// x is aIndex, aFirst, aLast, and so on
// B is b
// M is bLength, bEnd - bStart, and so on
// y is bIndex, bFirst, bLast, and so on
// Δ = N - M is negative of baDeltaLength = bLength - aLength
// D is d
// k is kF
// k + Δ is kF = kR - baDeltaLength
// V is aIndexesF or aIndexesR (see comment below about Indexes type)
// index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)
// starting point in forward direction (0, 0) is (-1, -1)
// starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)
// The “edit graph” for sequences a and b corresponds to items:
// in a on the horizontal axis
// in b on the vertical axis
//
// Given a-coordinate of a point in a diagonal, you can compute b-coordinate.
//
// Forward diagonals kF:
// zero diagonal intersects top left corner
// positive diagonals intersect top edge
// negative diagonals insersect left edge
//
// Reverse diagonals kR:
// zero diagonal intersects bottom right corner
// positive diagonals intersect right edge
// negative diagonals intersect bottom edge
// The graph contains a directed acyclic graph of edges:
// horizontal: delete an item from a
// vertical: insert an item from b
// diagonal: common item in a and b
//
// The algorithm solves dual problems in the graph analogy:
// Find longest common subsequence: path with maximum number of diagonal edges
// Find shortest edit script: path with minimum number of non-diagonal edges
// Input callback function compares items at indexes in the sequences.
// Output callback function receives the number of adjacent items
// and starting indexes of each common subsequence.
// Either original functions or wrapped to swap indexes if graph is transposed.
// Indexes in sequence a of last point of forward or reverse paths in graph.
// Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.
// This package indexes by iF and iR which are greater than or equal to zero.
// and also updates the index arrays in place to cut memory in half.
// kF = 2 * iF - d
// kR = d - 2 * iR
// Division of index intervals in sequences a and b at the middle change.
// Invariant: intervals do not have common items at the start or end.
const pkg='diff-sequences';// for error messages
const NOT_YET_SET=0;// small int instead of undefined to avoid deopt in V8
// Return the number of common items that follow in forward direction.
// The length of what Myers paper calls a “snake” in a forward path.
const countCommonItemsF=(aIndex,aEnd,bIndex,bEnd,isCommon)=>{let nCommon=0;while(aIndex<aEnd&&bIndex<bEnd&&isCommon(aIndex,bIndex)){aIndex+=1;bIndex+=1;nCommon+=1;}return nCommon;};// Return the number of common items that precede in reverse direction.
// The length of what Myers paper calls a “snake” in a reverse path.
const countCommonItemsR=(aStart,aIndex,bStart,bIndex,isCommon)=>{let nCommon=0;while(aStart<=aIndex&&bStart<=bIndex&&isCommon(aIndex,bIndex)){aIndex-=1;bIndex-=1;nCommon+=1;}return nCommon;};// A simple function to extend forward paths from (d - 1) to d changes
// when forward and reverse paths cannot yet overlap.
const extendPathsF=(d,aEnd,bEnd,bF,isCommon,aIndexesF,iMaxF// return the value because optimization might decrease it
)=>{// Unroll the first iteration.
let iF=0;let kF=-d;// kF = 2 * iF - d
let aFirst=aIndexesF[iF];// in first iteration always insert
let aIndexPrev1=aFirst;// prev value of [iF - 1] in next iteration
aIndexesF[iF]+=countCommonItemsF(aFirst+1,aEnd,bF+aFirst-kF+1,bEnd,isCommon);// Optimization: skip diagonals in which paths cannot ever overlap.
const nF=d<iMaxF?d:iMaxF;// The diagonals kF are odd when d is odd and even when d is even.
for(iF+=1,kF+=2;iF<=nF;iF+=1,kF+=2){// To get first point of path segment, move one change in forward direction
// from last point of previous path segment in an adjacent diagonal.
// In last possible iteration when iF === d and kF === d always delete.
if(iF!==d&&aIndexPrev1<aIndexesF[iF]){aFirst=aIndexesF[iF];// vertical to insert from b
}else{aFirst=aIndexPrev1+1;// horizontal to delete from a
if(aEnd<=aFirst){// Optimization: delete moved past right of graph.
return iF-1;}}// To get last point of path segment, move along diagonal of common items.
aIndexPrev1=aIndexesF[iF];aIndexesF[iF]=aFirst+countCommonItemsF(aFirst+1,aEnd,bF+aFirst-kF+1,bEnd,isCommon);}return iMaxF;};// A simple function to extend reverse paths from (d - 1) to d changes
// when reverse and forward paths cannot yet overlap.
const extendPathsR=(d,aStart,bStart,bR,isCommon,aIndexesR,iMaxR// return the value because optimization might decrease it
)=>{// Unroll the first iteration.
let iR=0;let kR=d;// kR = d - 2 * iR
let aFirst=aIndexesR[iR];// in first iteration always insert
let aIndexPrev1=aFirst;// prev value of [iR - 1] in next iteration
aIndexesR[iR]-=countCommonItemsR(aStart,aFirst-1,bStart,bR+aFirst-kR-1,isCommon);// Optimization: skip diagonals in which paths cannot ever overlap.
const nR=d<iMaxR?d:iMaxR;// The diagonals kR are odd when d is odd and even when d is even.
for(iR+=1,kR-=2;iR<=nR;iR+=1,kR-=2){// To get first point of path segment, move one change in reverse direction
// from last point of previous path segment in an adjacent diagonal.
// In last possible iteration when iR === d and kR === -d always delete.
if(iR!==d&&aIndexesR[iR]<aIndexPrev1){aFirst=aIndexesR[iR];// vertical to insert from b
}else{aFirst=aIndexPrev1-1;// horizontal to delete from a
if(aFirst<aStart){// Optimization: delete moved past left of graph.
return iR-1;}}// To get last point of path segment, move along diagonal of common items.
aIndexPrev1=aIndexesR[iR];aIndexesR[iR]=aFirst-countCommonItemsR(aStart,aFirst-1,bStart,bR+aFirst-kR-1,isCommon);}return iMaxR;};// A complete function to extend forward paths from (d - 1) to d changes.
// Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.
const extendOverlappablePathsF=(d,aStart,aEnd,bStart,bEnd,isCommon,aIndexesF,iMaxF,aIndexesR,iMaxR,division// update prop values if return true
)=>{const bF=bStart-aStart;// bIndex = bF + aIndex - kF
const aLength=aEnd-aStart;const bLength=bEnd-bStart;const baDeltaLength=bLength-aLength;// kF = kR - baDeltaLength
// Range of diagonals in which forward and reverse paths might overlap.
const kMinOverlapF=-baDeltaLength-(d-1);// -(d - 1) <= kR
const kMaxOverlapF=-baDeltaLength+(d-1);// kR <= (d - 1)
let aIndexPrev1=NOT_YET_SET;// prev value of [iF - 1] in next iteration
// Optimization: skip diagonals in which paths cannot ever overlap.
const nF=d<iMaxF?d:iMaxF;// The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.
for(let iF=0,kF=-d;iF<=nF;iF+=1,kF+=2){// To get first point of path segment, move one change in forward direction
// from last point of previous path segment in an adjacent diagonal.
// In first iteration when iF === 0 and kF === -d always insert.
// In last possible iteration when iF === d and kF === d always delete.
const insert=iF===0||iF!==d&&aIndexPrev1<aIndexesF[iF];const aLastPrev=insert?aIndexesF[iF]:aIndexPrev1;const aFirst=insert?aLastPrev// vertical to insert from b
:aLastPrev+1;// horizontal to delete from a
// To get last point of path segment, move along diagonal of common items.
const bFirst=bF+aFirst-kF;const nCommonF=countCommonItemsF(aFirst+1,aEnd,bFirst+1,bEnd,isCommon);const aLast=aFirst+nCommonF;aIndexPrev1=aIndexesF[iF];aIndexesF[iF]=aLast;if(kMinOverlapF<=kF&&kF<=kMaxOverlapF){// Solve for iR of reverse path with (d - 1) changes in diagonal kF:
// kR = kF + baDeltaLength
// kR = (d - 1) - 2 * iR
const iR=(d-1-(kF+baDeltaLength))/2;// If this forward path overlaps the reverse path in this diagonal,
// then this is the middle change of the index intervals.
if(iR<=iMaxR&&aIndexesR[iR]-1<=aLast){// Unlike the Myers algorithm which finds only the middle “snake”
// this package can find two common subsequences per division.
// Last point of previous path segment is on an adjacent diagonal.
const bLastPrev=bF+aLastPrev-(insert?kF+1:kF-1);// Because of invariant that intervals preceding the middle change
// cannot have common items at the end,
// move in reverse direction along a diagonal of common items.
const nCommonR=countCommonItemsR(aStart,aLastPrev,bStart,bLastPrev,isCommon);const aIndexPrevFirst=aLastPrev-nCommonR;const bIndexPrevFirst=bLastPrev-nCommonR;const aEndPreceding=aIndexPrevFirst+1;const bEndPreceding=bIndexPrevFirst+1;division.nChangePreceding=d-1;if(d-1===aEndPreceding+bEndPreceding-aStart-bStart){// Optimization: number of preceding changes in forward direction
// is equal to number of items in preceding interval,
// therefore it cannot contain any common items.
division.aEndPreceding=aStart;division.bEndPreceding=bStart;}else{division.aEndPreceding=aEndPreceding;division.bEndPreceding=bEndPreceding;}division.nCommonPreceding=nCommonR;if(nCommonR!==0){division.aCommonPreceding=aEndPreceding;division.bCommonPreceding=bEndPreceding;}division.nCommonFollowing=nCommonF;if(nCommonF!==0){division.aCommonFollowing=aFirst+1;division.bCommonFollowing=bFirst+1;}const aStartFollowing=aLast+1;const bStartFollowing=bFirst+nCommonF+1;division.nChangeFollowing=d-1;if(d-1===aEnd+bEnd-aStartFollowing-bStartFollowing){// Optimization: number of changes in reverse direction
// is equal to number of items in following interval,
// therefore it cannot contain any common items.
division.aStartFollowing=aEnd;division.bStartFollowing=bEnd;}else{division.aStartFollowing=aStartFollowing;division.bStartFollowing=bStartFollowing;}return true;}}}return false;};// A complete function to extend reverse paths from (d - 1) to d changes.
// Return true if a path overlaps forward path of d changes in its diagonal.
const extendOverlappablePathsR=(d,aStart,aEnd,bStart,bEnd,isCommon,aIndexesF,iMaxF,aIndexesR,iMaxR,division// update prop values if return true
)=>{const bR=bEnd-aEnd;// bIndex = bR + aIndex - kR
const aLength=aEnd-aStart;const bLength=bEnd-bStart;const baDeltaLength=bLength-aLength;// kR = kF + baDeltaLength
// Range of diagonals in which forward and reverse paths might overlap.
const kMinOverlapR=baDeltaLength-d;// -d <= kF
const kMaxOverlapR=baDeltaLength+d;// kF <= d
let aIndexPrev1=NOT_YET_SET;// prev value of [iR - 1] in next iteration
// Optimization: skip diagonals in which paths cannot ever overlap.
const nR=d<iMaxR?d:iMaxR;// The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.
for(let iR=0,kR=d;iR<=nR;iR+=1,kR-=2){// To get first point of path segment, move one change in reverse direction
// from last point of previous path segment in an adjacent diagonal.
// In first iteration when iR === 0 and kR === d always insert.
// In last possible iteration when iR === d and kR === -d always delete.
const insert=iR===0||iR!==d&&aIndexesR[iR]<aIndexPrev1;const aLastPrev=insert?aIndexesR[iR]:aIndexPrev1;const aFirst=insert?aLastPrev// vertical to insert from b
:aLastPrev-1;// horizontal to delete from a
// To get last point of path segment, move along diagonal of common items.
const bFirst=bR+aFirst-kR;const nCommonR=countCommonItemsR(aStart,aFirst-1,bStart,bFirst-1,isCommon);const aLast=aFirst-nCommonR;aIndexPrev1=aIndexesR[iR];aIndexesR[iR]=aLast;if(kMinOverlapR<=kR&&kR<=kMaxOverlapR){// Solve for iF of forward path with d changes in diagonal kR:
// kF = kR - baDeltaLength
// kF = 2 * iF - d
const iF=(d+(kR-baDeltaLength))/2;// If this reverse path overlaps the forward path in this diagonal,
// then this is a middle change of the index intervals.
if(iF<=iMaxF&&aLast-1<=aIndexesF[iF]){const bLast=bFirst-nCommonR;division.nChangePreceding=d;if(d===aLast+bLast-aStart-bStart){// Optimization: number of changes in reverse direction
// is equal to number of items in preceding interval,
// therefore it cannot contain any common items.
division.aEndPreceding=aStart;division.bEndPreceding=bStart;}else{division.aEndPreceding=aLast;division.bEndPreceding=bLast;}division.nCommonPreceding=nCommonR;if(nCommonR!==0){// The last point of reverse path segment is start of common subsequence.
division.aCommonPreceding=aLast;division.bCommonPreceding=bLast;}division.nChangeFollowing=d-1;if(d===1){// There is no previous path segment.
division.nCommonFollowing=0;division.aStartFollowing=aEnd;division.bStartFollowing=bEnd;}else{// Unlike the Myers algorithm which finds only the middle “snake”
// this package can find two common subsequences per division.
// Last point of previous path segment is on an adjacent diagonal.
const bLastPrev=bR+aLastPrev-(insert?kR-1:kR+1);// Because of invariant that intervals following the middle change
// cannot have common items at the start,
// move in forward direction along a diagonal of common items.
const nCommonF=countCommonItemsF(aLastPrev,aEnd,bLastPrev,bEnd,isCommon);division.nCommonFollowing=nCommonF;if(nCommonF!==0){// The last point of reverse path segment is start of common subsequence.
division.aCommonFollowing=aLastPrev;division.bCommonFollowing=bLastPrev;}const aStartFollowing=aLastPrev+nCommonF;// aFirstPrev
const bStartFollowing=bLastPrev+nCommonF;// bFirstPrev
if(d-1===aEnd+bEnd-aStartFollowing-bStartFollowing){// Optimization: number of changes in forward direction
// is equal to number of items in following interval,
// therefore it cannot contain any common items.
division.aStartFollowing=aEnd;division.bStartFollowing=bEnd;}else{division.aStartFollowing=aStartFollowing;division.bStartFollowing=bStartFollowing;}}return true;}}}return false;};// Given index intervals and input function to compare items at indexes,
// divide at the middle change.
//
// DO NOT CALL if start === end, because interval cannot contain common items
// and because this function will throw the “no overlap” error.
const divide=(nChange,aStart,aEnd,bStart,bEnd,isCommon,aIndexesF,aIndexesR,division// output
)=>{const bF=bStart-aStart;// bIndex = bF + aIndex - kF
const bR=bEnd-aEnd;// bIndex = bR + aIndex - kR
const aLength=aEnd-aStart;const bLength=bEnd-bStart;// Because graph has square or portrait orientation,
// length difference is minimum number of items to insert from b.
// Corresponding forward and reverse diagonals in graph
// depend on length difference of the sequences:
// kF = kR - baDeltaLength
// kR = kF + baDeltaLength
const baDeltaLength=bLength-aLength;// Optimization: max diagonal in graph intersects corner of shorter side.
let iMaxF=aLength;let iMaxR=aLength;// Initialize no changes yet in forward or reverse direction:
aIndexesF[0]=aStart-1;// at open start of interval, outside closed start
aIndexesR[0]=aEnd;// at open end of interval
if(baDeltaLength%2===0){// The number of changes in paths is 2 * d if length difference is even.
const dMin=(nChange||baDeltaLength)/2;const dMax=(aLength+bLength)/2;for(let d=1;d<=dMax;d+=1){iMaxF=extendPathsF(d,aEnd,bEnd,bF,isCommon,aIndexesF,iMaxF);if(d<dMin){iMaxR=extendPathsR(d,aStart,bStart,bR,isCommon,aIndexesR,iMaxR);}else if(// If a reverse path overlaps a forward path in the same diagonal,
// return a division of the index intervals at the middle change.
extendOverlappablePathsR(d,aStart,aEnd,bStart,bEnd,isCommon,aIndexesF,iMaxF,aIndexesR,iMaxR,division)){return;}}}else{// The number of changes in paths is 2 * d - 1 if length difference is odd.
const dMin=((nChange||baDeltaLength)+1)/2;const dMax=(aLength+bLength+1)/2;// Unroll first half iteration so loop extends the relevant pairs of paths.
// Because of invariant that intervals have no common items at start or end,
// and limitation not to call divide with empty intervals,
// therefore it cannot be called if a forward path with one change
// would overlap a reverse path with no changes, even if dMin === 1.
let d=1;iMaxF=extendPathsF(d,aEnd,bEnd,bF,isCommon,aIndexesF,iMaxF);for(d+=1;d<=dMax;d+=1){iMaxR=extendPathsR(d-1,aStart,bStart,bR,isCommon,aIndexesR,iMaxR);if(d<dMin){iMaxF=extendPathsF(d,aEnd,bEnd,bF,isCommon,aIndexesF,iMaxF);}else if(// If a forward path overlaps a reverse path in the same diagonal,
// return a division of the index intervals at the middle change.
extendOverlappablePathsF(d,aStart,aEnd,bStart,bEnd,isCommon,aIndexesF,iMaxF,aIndexesR,iMaxR,division)){return;}}}/* istanbul ignore next */throw new Error(\`\${pkg}: no overlap aStart=\${aStart} aEnd=\${aEnd} bStart=\${bStart} bEnd=\${bEnd}\`);};// Given index intervals and input function to compare items at indexes,
// return by output function the number of adjacent items and starting indexes
// of each common subsequence. Divide and conquer with only linear space.
//
// The index intervals are half open [start, end) like array slice method.
// DO NOT CALL if start === end, because interval cannot contain common items
// and because divide function will throw the “no overlap” error.
const findSubsequences=(nChange,aStart,aEnd,bStart,bEnd,transposed,callbacks,aIndexesF,aIndexesR,division// temporary memory, not input nor output
)=>{if(bEnd-bStart<aEnd-aStart){// Transpose graph so it has portrait instead of landscape orientation.
// Always compare shorter to longer sequence for consistency and optimization.
transposed=!transposed;if(transposed&&callbacks.length===1){// Lazily wrap callback functions to swap args if graph is transposed.
const _callbacks$=callbacks[0],foundSubsequence=_callbacks$.foundSubsequence,isCommon=_callbacks$.isCommon;callbacks[1]={foundSubsequence:(nCommon,bCommon,aCommon)=>{foundSubsequence(nCommon,aCommon,bCommon);},isCommon:(bIndex,aIndex)=>isCommon(aIndex,bIndex)};}const tStart=aStart;const tEnd=aEnd;aStart=bStart;aEnd=bEnd;bStart=tStart;bEnd=tEnd;}const _callbacks=callbacks[transposed?1:0],foundSubsequence=_callbacks.foundSubsequence,isCommon=_callbacks.isCommon;// Divide the index intervals at the middle change.
divide(nChange,aStart,aEnd,bStart,bEnd,isCommon,aIndexesF,aIndexesR,division);const nChangePreceding=division.nChangePreceding,aEndPreceding=division.aEndPreceding,bEndPreceding=division.bEndPreceding,nCommonPreceding=division.nCommonPreceding,aCommonPreceding=division.aCommonPreceding,bCommonPreceding=division.bCommonPreceding,nCommonFollowing=division.nCommonFollowing,aCommonFollowing=division.aCommonFollowing,bCommonFollowing=division.bCommonFollowing,nChangeFollowing=division.nChangeFollowing,aStartFollowing=division.aStartFollowing,bStartFollowing=division.bStartFollowing;// Unless either index interval is empty, they might contain common items.
if(aStart<aEndPreceding&&bStart<bEndPreceding){// Recursely find and return common subsequences preceding the division.
findSubsequences(nChangePreceding,aStart,aEndPreceding,bStart,bEndPreceding,transposed,callbacks,aIndexesF,aIndexesR,division);}// Return common subsequences that are adjacent to the middle change.
if(nCommonPreceding!==0){foundSubsequence(nCommonPreceding,aCommonPreceding,bCommonPreceding);}if(nCommonFollowing!==0){foundSubsequence(nCommonFollowing,aCommonFollowing,bCommonFollowing);}// Unless either index interval is empty, they might contain common items.
if(aStartFollowing<aEnd&&bStartFollowing<bEnd){// Recursely find and return common subsequences following the division.
findSubsequences(nChangeFollowing,aStartFollowing,aEnd,bStartFollowing,bEnd,transposed,callbacks,aIndexesF,aIndexesR,division);}};const validateLength=(name,arg)=>{if(typeof arg!=='number'){throw new TypeError(\`\${pkg}: \${name} typeof \${typeof arg} is not a number\`);}if(!Number.isSafeInteger(arg)){throw new RangeError(\`\${pkg}: \${name} value \${arg} is not a safe integer\`);}if(arg<0){throw new RangeError(\`\${pkg}: \${name} value \${arg} is a negative integer\`);}};const validateCallback=(name,arg)=>{const type=typeof arg;if(type!=='function'){throw new TypeError(\`\${pkg}: \${name} typeof \${type} is not a function\`);}};// Compare items in two sequences to find a longest common subsequence.
// Given lengths of sequences and input function to compare items at indexes,
// return by output function the number of adjacent items and starting indexes
// of each common subsequence.
function diffSequence(aLength,bLength,isCommon,foundSubsequence){validateLength('aLength',aLength);validateLength('bLength',bLength);validateCallback('isCommon',isCommon);validateCallback('foundSubsequence',foundSubsequence);// Count common items from the start in the forward direction.
const nCommonF=countCommonItemsF(0,aLength,0,bLength,isCommon);if(nCommonF!==0){foundSubsequence(nCommonF,0,0);}// Unless both sequences consist of common items only,
// find common items in the half-trimmed index intervals.
if(aLength!==nCommonF||bLength!==nCommonF){// Invariant: intervals do not have common items at the start.
// The start of an index interval is closed like array slice method.
const aStart=nCommonF;const bStart=nCommonF;// Count common items from the end in the reverse direction.
const nCommonR=countCommonItemsR(aStart,aLength-1,bStart,bLength-1,isCommon);// Invariant: intervals do not have common items at the end.
// The end of an index interval is open like array slice method.
const aEnd=aLength-nCommonR;const bEnd=bLength-nCommonR;// Unless one sequence consists of common items only,
// therefore the other trimmed index interval consists of changes only,
// find common items in the trimmed index intervals.
const nCommonFR=nCommonF+nCommonR;if(aLength!==nCommonFR&&bLength!==nCommonFR){const nChange=0;// number of change items is not yet known
const transposed=false;// call the original unwrapped functions
const callbacks=[{foundSubsequence,isCommon}];// Indexes in sequence a of last points in furthest reaching paths
// from outside the start at top left in the forward direction:
const aIndexesF=[NOT_YET_SET];// from the end at bottom right in the reverse direction:
const aIndexesR=[NOT_YET_SET];// Initialize one object as output of all calls to divide function.
const division={aCommonFollowing:NOT_YET_SET,aCommonPreceding:NOT_YET_SET,aEndPreceding:NOT_YET_SET,aStartFollowing:NOT_YET_SET,bCommonFollowing:NOT_YET_SET,bCommonPreceding:NOT_YET_SET,bEndPreceding:NOT_YET_SET,bStartFollowing:NOT_YET_SET,nChangeFollowing:NOT_YET_SET,nChangePreceding:NOT_YET_SET,nCommonFollowing:NOT_YET_SET,nCommonPreceding:NOT_YET_SET};// Find and return common subsequences in the trimmed index intervals.
findSubsequences(nChange,aStart,aEnd,bStart,bEnd,transposed,callbacks,aIndexesF,aIndexesR,division);}if(nCommonR!==0){foundSubsequence(nCommonR,aEnd,bEnd);}}}function getType(value){if(value===void 0){return"undefined";}else if(value===null){return"null";}else if(Array.isArray(value)){return"array";}else if(typeof value==="boolean"){return"boolean";}else if(typeof value==="function"){return"function";}else if(typeof value==="number"){return"number";}else if(typeof value==="string"){return"string";}else if(typeof value==="bigint"){return"bigint";}else if(typeof value==="object"){if(value!=null){if(value.constructor===RegExp)return"regexp";else if(value.constructor===Map)return"map";else if(value.constructor===Set)return"set";else if(value.constructor===Date)return"date";}return"object";}else if(typeof value==="symbol"){return"symbol";}throw new Error(\`value of unknown type: \${value}\`);}const DIFF_DELETE=-1;const DIFF_INSERT=1;const DIFF_EQUAL=0;class Diff{0;1;constructor(op,text){this[0]=op;this[1]=text;}}const NO_DIFF_MESSAGE="Compared values have no visual difference.";const SIMILAR_MESSAGE="Compared values serialize to the same structure.\\nPrinting internal object structure without calling \`toJSON\` instead.";function formatTrailingSpaces(line,trailingSpaceFormatter){return line.replace(/\\s+$/,match=>trailingSpaceFormatter(match));}function printDiffLine(line,isFirstOrLast,color,indicator,trailingSpaceFormatter,emptyFirstOrLastLinePlaceholder){return line.length!==0?color(\`\${indicator} \${formatTrailingSpaces(line,trailingSpaceFormatter)}\`):indicator!==" "?color(indicator):isFirstOrLast&&emptyFirstOrLastLinePlaceholder.length!==0?color(\`\${indicator} \${emptyFirstOrLastLinePlaceholder}\`):"";}function printDeleteLine(line,isFirstOrLast,{aColor,aIndicator,changeLineTrailingSpaceColor,emptyFirstOrLastLinePlaceholder}){return printDiffLine(line,isFirstOrLast,aColor,aIndicator,changeLineTrailingSpaceColor,emptyFirstOrLastLinePlaceholder);}function printInsertLine(line,isFirstOrLast,{bColor,bIndicator,changeLineTrailingSpaceColor,emptyFirstOrLastLinePlaceholder}){return printDiffLine(line,isFirstOrLast,bColor,bIndicator,changeLineTrailingSpaceColor,emptyFirstOrLastLinePlaceholder);}function printCommonLine(line,isFirstOrLast,{commonColor,commonIndicator,commonLineTrailingSpaceColor,emptyFirstOrLastLinePlaceholder}){return printDiffLine(line,isFirstOrLast,commonColor,commonIndicator,commonLineTrailingSpaceColor,emptyFirstOrLastLinePlaceholder);}function createPatchMark(aStart,aEnd,bStart,bEnd,{patchColor}){return patchColor(\`@@ -\${aStart+1},\${aEnd-aStart} +\${bStart+1},\${bEnd-bStart} @@\`);}function joinAlignedDiffsNoExpand(diffs,options){const iLength=diffs.length;const nContextLines=options.contextLines;const nContextLines2=nContextLines+nContextLines;let jLength=iLength;let hasExcessAtStartOrEnd=false;let nExcessesBetweenChanges=0;let i=0;while(i!==iLength){const iStart=i;while(i!==iLength&&diffs[i][0]===DIFF_EQUAL)i+=1;if(iStart!==i){if(iStart===0){if(i>nContextLines){jLength-=i-nContextLines;hasExcessAtStartOrEnd=true;}}else if(i===iLength){const n=i-iStart;if(n>nContextLines){jLength-=n-nContextLines;hasExcessAtStartOrEnd=true;}}else{const n=i-iStart;if(n>nContextLines2){jLength-=n-nContextLines2;nExcessesBetweenChanges+=1;}}}while(i!==iLength&&diffs[i][0]!==DIFF_EQUAL)i+=1;}const hasPatch=nExcessesBetweenChanges!==0||hasExcessAtStartOrEnd;if(nExcessesBetweenChanges!==0)jLength+=nExcessesBetweenChanges+1;else if(hasExcessAtStartOrEnd)jLength+=1;const jLast=jLength-1;const lines=[];let jPatchMark=0;if(hasPatch)lines.push("");let aStart=0;let bStart=0;let aEnd=0;let bEnd=0;const pushCommonLine=line=>{const j=lines.length;lines.push(printCommonLine(line,j===0||j===jLast,options));aEnd+=1;bEnd+=1;};const pushDeleteLine=line=>{const j=lines.length;lines.push(printDeleteLine(line,j===0||j===jLast,options));aEnd+=1;};const pushInsertLine=line=>{const j=lines.length;lines.push(printInsertLine(line,j===0||j===jLast,options));bEnd+=1;};i=0;while(i!==iLength){let iStart=i;while(i!==iLength&&diffs[i][0]===DIFF_EQUAL)i+=1;if(iStart!==i){if(iStart===0){if(i>nContextLines){iStart=i-nContextLines;aStart=iStart;bStart=iStart;aEnd=aStart;bEnd=bStart;}for(let iCommon=iStart;iCommon!==i;iCommon+=1)pushCommonLine(diffs[iCommon][1]);}else if(i===iLength){const iEnd=i-iStart>nContextLines?iStart+nContextLines:i;for(let iCommon=iStart;iCommon!==iEnd;iCommon+=1)pushCommonLine(diffs[iCommon][1]);}else{const nCommon=i-iStart;if(nCommon>nContextLines2){const iEnd=iStart+nContextLines;for(let iCommon=iStart;iCommon!==iEnd;iCommon+=1)pushCommonLine(diffs[iCommon][1]);lines[jPatchMark]=createPatchMark(aStart,aEnd,bStart,bEnd,options);jPatchMark=lines.length;lines.push("");const nOmit=nCommon-nContextLines2;aStart=aEnd+nOmit;bStart=bEnd+nOmit;aEnd=aStart;bEnd=bStart;for(let iCommon=i-nContextLines;iCommon!==i;iCommon+=1)pushCommonLine(diffs[iCommon][1]);}else{for(let iCommon=iStart;iCommon!==i;iCommon+=1)pushCommonLine(diffs[iCommon][1]);}}}while(i!==iLength&&diffs[i][0]===DIFF_DELETE){pushDeleteLine(diffs[i][1]);i+=1;}while(i!==iLength&&diffs[i][0]===DIFF_INSERT){pushInsertLine(diffs[i][1]);i+=1;}}if(hasPatch)lines[jPatchMark]=createPatchMark(aStart,aEnd,bStart,bEnd,options);return lines.join("\\n");}function joinAlignedDiffsExpand(diffs,options){return diffs.map((diff,i,diffs2)=>{const line=diff[1];const isFirstOrLast=i===0||i===diffs2.length-1;switch(diff[0]){case DIFF_DELETE:return printDeleteLine(line,isFirstOrLast,options);case DIFF_INSERT:return printInsertLine(line,isFirstOrLast,options);default:return printCommonLine(line,isFirstOrLast,options);}}).join("\\n");}const noColor=string=>string;const DIFF_CONTEXT_DEFAULT=5;const DIFF_TRUNCATE_THRESHOLD_DEFAULT=0;function getDefaultOptions(){const c=getColors();return{aAnnotation:"Expected",aColor:c.green,aIndicator:"-",bAnnotation:"Received",bColor:c.red,bIndicator:"+",changeColor:c.inverse,changeLineTrailingSpaceColor:noColor,commonColor:c.dim,commonIndicator:" ",commonLineTrailingSpaceColor:noColor,compareKeys:void 0,contextLines:DIFF_CONTEXT_DEFAULT,emptyFirstOrLastLinePlaceholder:"",expand:true,includeChangeCounts:false,omitAnnotationLines:false,patchColor:c.yellow,truncateThreshold:DIFF_TRUNCATE_THRESHOLD_DEFAULT,truncateAnnotation:"... Diff result is truncated",truncateAnnotationColor:noColor};}function getCompareKeys(compareKeys){return compareKeys&&typeof compareKeys==="function"?compareKeys:void 0;}function getContextLines(contextLines){return typeof contextLines==="number"&&Number.isSafeInteger(contextLines)&&contextLines>=0?contextLines:DIFF_CONTEXT_DEFAULT;}function normalizeDiffOptions(options={}){return _objectSpread(_objectSpread(_objectSpread({},getDefaultOptions()),options),{},{compareKeys:getCompareKeys(options.compareKeys),contextLines:getContextLines(options.contextLines)});}function isEmptyString(lines){return lines.length===1&&lines[0].length===0;}function countChanges(diffs){let a=0;let b=0;diffs.forEach(diff2=>{switch(diff2[0]){case DIFF_DELETE:a+=1;break;case DIFF_INSERT:b+=1;break;}});return{a,b};}function printAnnotation({aAnnotation,aColor,aIndicator,bAnnotation,bColor,bIndicator,includeChangeCounts,omitAnnotationLines},changeCounts){if(omitAnnotationLines)return"";let aRest="";let bRest="";if(includeChangeCounts){const aCount=String(changeCounts.a);const bCount=String(changeCounts.b);const baAnnotationLengthDiff=bAnnotation.length-aAnnotation.length;const aAnnotationPadding=" ".repeat(Math.max(0,baAnnotationLengthDiff));const bAnnotationPadding=" ".repeat(Math.max(0,-baAnnotationLengthDiff));const baCountLengthDiff=bCount.length-aCount.length;const aCountPadding=" ".repeat(Math.max(0,baCountLengthDiff));const bCountPadding=" ".repeat(Math.max(0,-baCountLengthDiff));aRest=\`\${aAnnotationPadding}  \${aIndicator} \${aCountPadding}\${aCount}\`;bRest=\`\${bAnnotationPadding}  \${bIndicator} \${bCountPadding}\${bCount}\`;}const a=\`\${aIndicator} \${aAnnotation}\${aRest}\`;const b=\`\${bIndicator} \${bAnnotation}\${bRest}\`;return\`\${aColor(a)}
\${bColor(b)}

\`;}function printDiffLines(diffs,truncated,options){return printAnnotation(options,countChanges(diffs))+(options.expand?joinAlignedDiffsExpand(diffs,options):joinAlignedDiffsNoExpand(diffs,options))+(truncated?options.truncateAnnotationColor(\`
\${options.truncateAnnotation}\`):"");}function diffLinesUnified(aLines,bLines,options){const normalizedOptions=normalizeDiffOptions(options);const _diffLinesRaw=diffLinesRaw(isEmptyString(aLines)?[]:aLines,isEmptyString(bLines)?[]:bLines,normalizedOptions),_diffLinesRaw2=_slicedToArray(_diffLinesRaw,2),diffs=_diffLinesRaw2[0],truncated=_diffLinesRaw2[1];return printDiffLines(diffs,truncated,normalizedOptions);}function diffLinesUnified2(aLinesDisplay,bLinesDisplay,aLinesCompare,bLinesCompare,options){if(isEmptyString(aLinesDisplay)&&isEmptyString(aLinesCompare)){aLinesDisplay=[];aLinesCompare=[];}if(isEmptyString(bLinesDisplay)&&isEmptyString(bLinesCompare)){bLinesDisplay=[];bLinesCompare=[];}if(aLinesDisplay.length!==aLinesCompare.length||bLinesDisplay.length!==bLinesCompare.length){return diffLinesUnified(aLinesDisplay,bLinesDisplay,options);}const _diffLinesRaw3=diffLinesRaw(aLinesCompare,bLinesCompare,options),_diffLinesRaw4=_slicedToArray(_diffLinesRaw3,2),diffs=_diffLinesRaw4[0],truncated=_diffLinesRaw4[1];let aIndex=0;let bIndex=0;diffs.forEach(diff2=>{switch(diff2[0]){case DIFF_DELETE:diff2[1]=aLinesDisplay[aIndex];aIndex+=1;break;case DIFF_INSERT:diff2[1]=bLinesDisplay[bIndex];bIndex+=1;break;default:diff2[1]=bLinesDisplay[bIndex];aIndex+=1;bIndex+=1;}});return printDiffLines(diffs,truncated,normalizeDiffOptions(options));}function diffLinesRaw(aLines,bLines,options){const truncate=(options==null?void 0:options.truncateThreshold)??false;const truncateThreshold=Math.max(Math.floor((options==null?void 0:options.truncateThreshold)??0),0);const aLength=truncate?Math.min(aLines.length,truncateThreshold):aLines.length;const bLength=truncate?Math.min(bLines.length,truncateThreshold):bLines.length;const truncated=aLength!==aLines.length||bLength!==bLines.length;const isCommon=(aIndex2,bIndex2)=>aLines[aIndex2]===bLines[bIndex2];const diffs=[];let aIndex=0;let bIndex=0;const foundSubsequence=(nCommon,aCommon,bCommon)=>{for(;aIndex!==aCommon;aIndex+=1)diffs.push(new Diff(DIFF_DELETE,aLines[aIndex]));for(;bIndex!==bCommon;bIndex+=1)diffs.push(new Diff(DIFF_INSERT,bLines[bIndex]));for(;nCommon!==0;nCommon-=1,aIndex+=1,bIndex+=1)diffs.push(new Diff(DIFF_EQUAL,bLines[bIndex]));};const diffSequences=_default.default||_default;diffSequences(aLength,bLength,isCommon,foundSubsequence);for(;aIndex!==aLength;aIndex+=1)diffs.push(new Diff(DIFF_DELETE,aLines[aIndex]));for(;bIndex!==bLength;bIndex+=1)diffs.push(new Diff(DIFF_INSERT,bLines[bIndex]));return[diffs,truncated];}function getCommonMessage(message,options){const _normalizeDiffOptions=normalizeDiffOptions(options),commonColor=_normalizeDiffOptions.commonColor;return commonColor(message);}const _plugins_2=plugins_1,AsymmetricMatcher$2=_plugins_2.AsymmetricMatcher,DOMCollection$1=_plugins_2.DOMCollection,DOMElement$1=_plugins_2.DOMElement,Immutable$1=_plugins_2.Immutable,ReactElement$1=_plugins_2.ReactElement,ReactTestComponent$1=_plugins_2.ReactTestComponent;const PLUGINS$1=[ReactTestComponent$1,ReactElement$1,DOMElement$1,DOMCollection$1,Immutable$1,AsymmetricMatcher$2];const FORMAT_OPTIONS={plugins:PLUGINS$1};const FALLBACK_FORMAT_OPTIONS={callToJSON:false,maxDepth:10,plugins:PLUGINS$1};function diff(a,b,options){if(Object.is(a,b))return"";const aType=getType(a);let expectedType=aType;let omitDifference=false;if(aType==="object"&&typeof a.asymmetricMatch==="function"){if(a.$$typeof!==Symbol.for("jest.asymmetricMatcher")){return null;}if(typeof a.getExpectedType!=="function"){return null;}expectedType=a.getExpectedType();omitDifference=expectedType==="string";}if(expectedType!==getType(b)){const _normalizeDiffOptions2=normalizeDiffOptions(options),aAnnotation=_normalizeDiffOptions2.aAnnotation,aColor=_normalizeDiffOptions2.aColor,aIndicator=_normalizeDiffOptions2.aIndicator,bAnnotation=_normalizeDiffOptions2.bAnnotation,bColor=_normalizeDiffOptions2.bColor,bIndicator=_normalizeDiffOptions2.bIndicator;const formatOptions=getFormatOptions(FALLBACK_FORMAT_OPTIONS,options);const aDisplay=format_1(a,formatOptions);const bDisplay=format_1(b,formatOptions);const aDiff=\`\${aColor(\`\${aIndicator} \${aAnnotation}:\`)} 
\${aDisplay}\`;const bDiff=\`\${bColor(\`\${bIndicator} \${bAnnotation}:\`)} 
\${bDisplay}\`;return\`\${aDiff}

\${bDiff}\`;}if(omitDifference)return null;switch(aType){case"string":return diffLinesUnified(a.split("\\n"),b.split("\\n"),options);case"boolean":case"number":return comparePrimitive(a,b,options);case"map":return compareObjects(sortMap(a),sortMap(b),options);case"set":return compareObjects(sortSet(a),sortSet(b),options);default:return compareObjects(a,b,options);}}function comparePrimitive(a,b,options){const aFormat=format_1(a,FORMAT_OPTIONS);const bFormat=format_1(b,FORMAT_OPTIONS);return aFormat===bFormat?"":diffLinesUnified(aFormat.split("\\n"),bFormat.split("\\n"),options);}function sortMap(map){return new Map(Array.from(map.entries()).sort());}function sortSet(set){return new Set(Array.from(set.values()).sort());}function compareObjects(a,b,options){let difference;let hasThrown=false;try{const formatOptions=getFormatOptions(FORMAT_OPTIONS,options);difference=getObjectsDifference(a,b,formatOptions,options);}catch{hasThrown=true;}const noDiffMessage=getCommonMessage(NO_DIFF_MESSAGE,options);if(difference===void 0||difference===noDiffMessage){const formatOptions=getFormatOptions(FALLBACK_FORMAT_OPTIONS,options);difference=getObjectsDifference(a,b,formatOptions,options);if(difference!==noDiffMessage&&!hasThrown){difference=\`\${getCommonMessage(SIMILAR_MESSAGE,options)}

\${difference}\`;}}return difference;}function getFormatOptions(formatOptions,options){const _normalizeDiffOptions3=normalizeDiffOptions(options),compareKeys=_normalizeDiffOptions3.compareKeys;return _objectSpread(_objectSpread({},formatOptions),{},{compareKeys});}function getObjectsDifference(a,b,formatOptions,options){const formatOptionsZeroIndent=_objectSpread(_objectSpread({},formatOptions),{},{indent:0});const aCompare=format_1(a,formatOptionsZeroIndent);const bCompare=format_1(b,formatOptionsZeroIndent);if(aCompare===bCompare){return getCommonMessage(NO_DIFF_MESSAGE,options);}else{const aDisplay=format_1(a,formatOptions);const bDisplay=format_1(b,formatOptions);return diffLinesUnified2(aDisplay.split("\\n"),bDisplay.split("\\n"),aCompare.split("\\n"),bCompare.split("\\n"),options);}}const IS_RECORD_SYMBOL="@@__IMMUTABLE_RECORD__@@";const IS_COLLECTION_SYMBOL="@@__IMMUTABLE_ITERABLE__@@";function isImmutable(v){return v&&(v[IS_COLLECTION_SYMBOL]||v[IS_RECORD_SYMBOL]);}const OBJECT_PROTO=Object.getPrototypeOf({});function getUnserializableMessage(err){if(err instanceof Error)return\`<unserializable>: \${err.message}\`;if(typeof err==="string")return\`<unserializable>: \${err}\`;return"<unserializable>";}function serializeError(val,seen=/* @__PURE__ */new WeakMap()){if(!val||typeof val==="string")return val;if(typeof val==="function")return\`Function<\${val.name||"anonymous"}>\`;if(typeof val==="symbol")return val.toString();if(typeof val!=="object")return val;if(isImmutable(val))return serializeError(val.toJSON(),seen);if(val instanceof Promise||val.constructor&&val.constructor.prototype==="AsyncFunction")return"Promise";if(typeof Element!=="undefined"&&val instanceof Element)return val.tagName;if(typeof val.asymmetricMatch==="function")return\`\${val.toString()} \${format(val.sample)}\`;if(typeof val.toJSON==="function")return val.toJSON();if(seen.has(val))return seen.get(val);if(Array.isArray(val)){const clone=new Array(val.length);seen.set(val,clone);val.forEach((e,i)=>{try{clone[i]=serializeError(e,seen);}catch(err){clone[i]=getUnserializableMessage(err);}});return clone;}else{const clone=/* @__PURE__ */Object.create(null);seen.set(val,clone);let obj=val;while(obj&&obj!==OBJECT_PROTO){Object.getOwnPropertyNames(obj).forEach(key=>{if(key in clone)return;try{clone[key]=serializeError(val[key],seen);}catch(err){delete clone[key];clone[key]=getUnserializableMessage(err);}});obj=Object.getPrototypeOf(obj);}return clone;}}function normalizeErrorMessage(message){return message.replace(/__(vite_ssr_import|vi_import)_\\d+__\\./g,"");}function processError(err,diffOptions){if(!err||typeof err!=="object")return{message:err};if(err.stack)err.stackStr=String(err.stack);if(err.name)err.nameStr=String(err.name);if(err.showDiff||err.showDiff===void 0&&err.expected!==void 0&&err.actual!==void 0){const clonedActual=deepClone(err.actual,{forceWritable:true});const clonedExpected=deepClone(err.expected,{forceWritable:true});const _replaceAsymmetricMat=replaceAsymmetricMatcher(clonedActual,clonedExpected),replacedActual=_replaceAsymmetricMat.replacedActual,replacedExpected=_replaceAsymmetricMat.replacedExpected;err.diff=diff(replacedExpected,replacedActual,_objectSpread(_objectSpread({},diffOptions),err.diffOptions));}if(typeof err.expected!=="string")err.expected=stringify(err.expected,10);if(typeof err.actual!=="string")err.actual=stringify(err.actual,10);try{if(typeof err.message==="string")err.message=normalizeErrorMessage(err.message);if(typeof err.cause==="object"&&typeof err.cause.message==="string")err.cause.message=normalizeErrorMessage(err.cause.message);}catch{}try{return serializeError(err);}catch(e){return serializeError(new Error(\`Failed to fully serialize error: \${e==null?void 0:e.message}
Inner error message: \${err==null?void 0:err.message}\`));}}function isAsymmetricMatcher(data){const type=getType$2(data);return type==="Object"&&typeof data.asymmetricMatch==="function";}function isReplaceable(obj1,obj2){const obj1Type=getType$2(obj1);const obj2Type=getType$2(obj2);return obj1Type===obj2Type&&(obj1Type==="Object"||obj1Type==="Array");}function replaceAsymmetricMatcher(actual,expected,actualReplaced=/* @__PURE__ */new WeakSet(),expectedReplaced=/* @__PURE__ */new WeakSet()){if(!isReplaceable(actual,expected))return{replacedActual:actual,replacedExpected:expected};if(actualReplaced.has(actual)||expectedReplaced.has(expected))return{replacedActual:actual,replacedExpected:expected};actualReplaced.add(actual);expectedReplaced.add(expected);getOwnProperties(expected).forEach(key=>{const expectedValue=expected[key];const actualValue=actual[key];if(isAsymmetricMatcher(expectedValue)){if(expectedValue.asymmetricMatch(actualValue))actual[key]=expectedValue;}else if(isAsymmetricMatcher(actualValue)){if(actualValue.asymmetricMatch(expectedValue))expected[key]=actualValue;}else if(isReplaceable(actualValue,expectedValue)){const replaced=replaceAsymmetricMatcher(actualValue,expectedValue,actualReplaced,expectedReplaced);actual[key]=replaced.replacedActual;expected[key]=replaced.replacedExpected;}});return{replacedActual:actual,replacedExpected:expected};}function createChainable(keys,fn){function create(context){const chain2=function(...args){return fn.apply(context,args);};Object.assign(chain2,fn);chain2.withContext=()=>chain2.bind(context);chain2.setContext=(key,value)=>{context[key]=value;};chain2.mergeContext=ctx=>{Object.assign(context,ctx);};for(const key of keys){Object.defineProperty(chain2,key,{get(){return create(_objectSpread(_objectSpread({},context),{},{[key]:true}));}});}return chain2;}const chain=create({});chain.fn=fn;return chain;}function getNames(task){const names=[task.name];let current=task;while((current==null?void 0:current.suite)||(current==null?void 0:current.file)){current=current.suite||current.file;if(current==null?void 0:current.name)names.unshift(current.name);}return names;}const _DRIVE_LETTER_START_RE=/^[A-Za-z]:\\//;function normalizeWindowsPath$1(input=""){if(!input){return input;}return input.replace(/\\\\/g,"/").replace(_DRIVE_LETTER_START_RE,r=>r.toUpperCase());}const _IS_ABSOLUTE_RE$1=/^[/\\\\](?![/\\\\])|^[/\\\\]{2}(?!\\.)|^[A-Za-z]:[/\\\\]/;function cwd$1(){if(typeof process!=="undefined"&&typeof process.cwd==="function"){return process.cwd().replace(/\\\\/g,"/");}return"/";}const resolve$3=function(...arguments_){arguments_=arguments_.map(argument=>normalizeWindowsPath$1(argument));let resolvedPath="";let resolvedAbsolute=false;for(let index=arguments_.length-1;index>=-1&&!resolvedAbsolute;index--){const path=index>=0?arguments_[index]:cwd$1();if(!path||path.length===0){continue;}resolvedPath=\`\${path}/\${resolvedPath}\`;resolvedAbsolute=isAbsolute$1(path);}resolvedPath=normalizeString$1(resolvedPath,!resolvedAbsolute);if(resolvedAbsolute&&!isAbsolute$1(resolvedPath)){return\`/\${resolvedPath}\`;}return resolvedPath.length>0?resolvedPath:".";};function normalizeString$1(path,allowAboveRoot){let res="";let lastSegmentLength=0;let lastSlash=-1;let dots=0;let char=null;for(let index=0;index<=path.length;++index){if(index<path.length){char=path[index];}else if(char==="/"){break;}else{char="/";}if(char==="/"){if(lastSlash===index-1||dots===1);else if(dots===2){if(res.length<2||lastSegmentLength!==2||res[res.length-1]!=="."||res[res.length-2]!=="."){if(res.length>2){const lastSlashIndex=res.lastIndexOf("/");if(lastSlashIndex===-1){res="";lastSegmentLength=0;}else{res=res.slice(0,lastSlashIndex);lastSegmentLength=res.length-1-res.lastIndexOf("/");}lastSlash=index;dots=0;continue;}else if(res.length>0){res="";lastSegmentLength=0;lastSlash=index;dots=0;continue;}}if(allowAboveRoot){res+=res.length>0?"/..":"..";lastSegmentLength=2;}}else{if(res.length>0){res+=\`/\${path.slice(lastSlash+1,index)}\`;}else{res=path.slice(lastSlash+1,index);}lastSegmentLength=index-lastSlash-1;}lastSlash=index;dots=0;}else if(char==="."&&dots!==-1){++dots;}else{dots=-1;}}return res;}const isAbsolute$1=function(p){return _IS_ABSOLUTE_RE$1.test(p);};function normalizeWindowsPath(input=""){if(!input||!input.includes("\\\\")){return input;}return input.replace(/\\\\/g,"/");}const _IS_ABSOLUTE_RE=/^[/\\\\](?![/\\\\])|^[/\\\\]{2}(?!\\.)|^[A-Za-z]:[/\\\\]/;function cwd(){if(typeof process!=="undefined"){return process.cwd().replace(/\\\\/g,"/");}return"/";}const resolve$2=function(...arguments_){arguments_=arguments_.map(argument=>normalizeWindowsPath(argument));let resolvedPath="";let resolvedAbsolute=false;for(let index=arguments_.length-1;index>=-1&&!resolvedAbsolute;index--){const path=index>=0?arguments_[index]:cwd();if(!path||path.length===0){continue;}resolvedPath=\`\${path}/\${resolvedPath}\`;resolvedAbsolute=isAbsolute(path);}resolvedPath=normalizeString(resolvedPath,!resolvedAbsolute);if(resolvedAbsolute&&!isAbsolute(resolvedPath)){return\`/\${resolvedPath}\`;}return resolvedPath.length>0?resolvedPath:".";};function normalizeString(path,allowAboveRoot){let res="";let lastSegmentLength=0;let lastSlash=-1;let dots=0;let char=null;for(let index=0;index<=path.length;++index){if(index<path.length){char=path[index];}else if(char==="/"){break;}else{char="/";}if(char==="/"){if(lastSlash===index-1||dots===1);else if(dots===2){if(res.length<2||lastSegmentLength!==2||res[res.length-1]!=="."||res[res.length-2]!=="."){if(res.length>2){const lastSlashIndex=res.lastIndexOf("/");if(lastSlashIndex===-1){res="";lastSegmentLength=0;}else{res=res.slice(0,lastSlashIndex);lastSegmentLength=res.length-1-res.lastIndexOf("/");}lastSlash=index;dots=0;continue;}else if(res.length>0){res="";lastSegmentLength=0;lastSlash=index;dots=0;continue;}}if(allowAboveRoot){res+=res.length>0?"/..":"..";lastSegmentLength=2;}}else{if(res.length>0){res+=\`/\${path.slice(lastSlash+1,index)}\`;}else{res=path.slice(lastSlash+1,index);}lastSegmentLength=index-lastSlash-1;}lastSlash=index;dots=0;}else if(char==="."&&dots!==-1){++dots;}else{dots=-1;}}return res;}const isAbsolute=function(p){return _IS_ABSOLUTE_RE.test(p);};const chars$1='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';const intToChar$1=new Uint8Array(64);// 64 possible chars.
const charToInt$1=new Uint8Array(128);// z is 122 in ASCII
for(let i=0;i<chars$1.length;i++){const c=chars$1.charCodeAt(i);intToChar$1[i]=c;charToInt$1[c]=i;}var UrlType$1;(function(UrlType){UrlType[UrlType["Empty"]=1]="Empty";UrlType[UrlType["Hash"]=2]="Hash";UrlType[UrlType["Query"]=3]="Query";UrlType[UrlType["RelativePath"]=4]="RelativePath";UrlType[UrlType["AbsolutePath"]=5]="AbsolutePath";UrlType[UrlType["SchemeRelative"]=6]="SchemeRelative";UrlType[UrlType["Absolute"]=7]="Absolute";})(UrlType$1||(UrlType$1={}));const CHROME_IE_STACK_REGEXP$1=/^\\s*at .*(\\S+:\\d+|\\(native\\))/m;const SAFARI_NATIVE_CODE_REGEXP$1=/^(eval@)?(\\[native code])?$/;function extractLocation$1(urlLike){if(!urlLike.includes(":"))return[urlLike];const regExp=/(.+?)(?::(\\d+))?(?::(\\d+))?$/;const parts=regExp.exec(urlLike.replace(/^\\(|\\)$/g,""));if(!parts)return[urlLike];let url=parts[1];if(url.startsWith("http:")||url.startsWith("https:")){const urlObj=new URL(url);url=urlObj.pathname;}if(url.startsWith("/@fs/")){url=url.slice(typeof process!=="undefined"&&process.platform==="win32"?5:4);}return[url,parts[2]||void 0,parts[3]||void 0];}function parseSingleFFOrSafariStack$1(raw){let line=raw.trim();if(SAFARI_NATIVE_CODE_REGEXP$1.test(line))return null;if(line.includes(" > eval"))line=line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,":$1");if(!line.includes("@")&&!line.includes(":"))return null;const functionNameRegex=/((.*".+"[^@]*)?[^@]*)(?:@)/;const matches=line.match(functionNameRegex);const functionName=matches&&matches[1]?matches[1]:void 0;const _extractLocation$=extractLocation$1(line.replace(functionNameRegex,"")),_extractLocation$2=_slicedToArray(_extractLocation$,3),url=_extractLocation$2[0],lineNumber=_extractLocation$2[1],columnNumber=_extractLocation$2[2];if(!url||!lineNumber||!columnNumber)return null;return{file:url,method:functionName||"",line:Number.parseInt(lineNumber),column:Number.parseInt(columnNumber)};}function parseSingleStack(raw){const line=raw.trim();if(!CHROME_IE_STACK_REGEXP$1.test(line))return parseSingleFFOrSafariStack$1(line);return parseSingleV8Stack$1(line);}function parseSingleV8Stack$1(raw){let line=raw.trim();if(!CHROME_IE_STACK_REGEXP$1.test(line))return null;if(line.includes("(eval "))line=line.replace(/eval code/g,"eval").replace(/(\\(eval at [^()]*)|(,.*$)/g,"");let sanitizedLine=line.replace(/^\\s+/,"").replace(/\\(eval code/g,"(").replace(/^.*?\\s+/,"");const location=sanitizedLine.match(/ (\\(.+\\)$)/);sanitizedLine=location?sanitizedLine.replace(location[0],""):sanitizedLine;const _extractLocation$3=extractLocation$1(location?location[1]:sanitizedLine),_extractLocation$4=_slicedToArray(_extractLocation$3,3),url=_extractLocation$4[0],lineNumber=_extractLocation$4[1],columnNumber=_extractLocation$4[2];let method=location&&sanitizedLine||"";let file=url&&["eval","<anonymous>"].includes(url)?void 0:url;if(!file||!lineNumber||!columnNumber)return null;if(method.startsWith("async "))method=method.slice(6);if(file.startsWith("file://"))file=file.slice(7);file=resolve$2(file);if(method)method=method.replace(/__vite_ssr_import_\\d+__\\./g,"");return{method,file,line:Number.parseInt(lineNumber),column:Number.parseInt(columnNumber)};}const fnMap=/* @__PURE__ */new WeakMap();const fixtureMap=/* @__PURE__ */new WeakMap();const hooksMap=/* @__PURE__ */new WeakMap();function setFn(key,fn){fnMap.set(key,fn);}function setFixture(key,fixture){fixtureMap.set(key,fixture);}function getFixture(key){return fixtureMap.get(key);}function setHooks(key,hooks){hooksMap.set(key,hooks);}function getHooks(key){return hooksMap.get(key);}class PendingError extends Error{constructor(message,task){super(message);this.message=message;this.taskId=task.id;}code="VITEST_PENDING";taskId;}const collectorContext={tasks:[],currentSuite:null};function collectTask(task){var _a;(_a=collectorContext.currentSuite)==null?void 0:_a.tasks.push(task);}async function runWithSuite(suite,fn){const prev=collectorContext.currentSuite;collectorContext.currentSuite=suite;await fn();collectorContext.currentSuite=prev;}function withTimeout(fn,timeout,isHook=false){if(timeout<=0||timeout===Number.POSITIVE_INFINITY)return fn;const _getSafeTimers=getSafeTimers(),setTimeout=_getSafeTimers.setTimeout,clearTimeout=_getSafeTimers.clearTimeout;return(...args)=>{return Promise.race([fn(...args),new Promise((resolve,reject)=>{var _a;const timer=setTimeout(()=>{clearTimeout(timer);reject(new Error(makeTimeoutMsg(isHook,timeout)));},timeout);(_a=timer.unref)==null?void 0:_a.call(timer);})]);};}function createTestContext(test,runner){var _a;const context=function(){throw new Error("done() callback is deprecated, use promise instead");};context.task=test;context.skip=()=>{test.pending=true;throw new PendingError("test is skipped; abort execution",test);};context.onTestFailed=fn=>{test.onFailed||(test.onFailed=[]);test.onFailed.push(fn);};context.onTestFinished=fn=>{test.onFinished||(test.onFinished=[]);test.onFinished.push(fn);};return((_a=runner.extendTaskContext)==null?void 0:_a.call(runner,context))||context;}function makeTimeoutMsg(isHook,timeout){return\`\${isHook?"Hook":"Test"} timed out in \${timeout}ms.
If this is a long-running \${isHook?"hook":"test"}, pass a timeout value as the last argument or configure it globally with "\${isHook?"hookTimeout":"testTimeout"}".\`;}function mergeContextFixtures(fixtures,context={}){const fixtureOptionKeys=["auto"];const fixtureArray=Object.entries(fixtures).map(([prop,value])=>{const fixtureItem={value};if(Array.isArray(value)&&value.length>=2&&isObject$1(value[1])&&Object.keys(value[1]).some(key=>fixtureOptionKeys.includes(key))){Object.assign(fixtureItem,value[1]);fixtureItem.value=value[0];}fixtureItem.prop=prop;fixtureItem.isFn=typeof fixtureItem.value==="function";return fixtureItem;});if(Array.isArray(context.fixtures))context.fixtures=context.fixtures.concat(fixtureArray);else context.fixtures=fixtureArray;fixtureArray.forEach(fixture=>{if(fixture.isFn){const usedProps=getUsedProps(fixture.value);if(usedProps.length)fixture.deps=context.fixtures.filter(({prop})=>prop!==fixture.prop&&usedProps.includes(prop));}});return context;}const fixtureValueMaps=/* @__PURE__ */new Map();const cleanupFnArrayMap=/* @__PURE__ */new Map();function withFixtures(fn,testContext){return hookContext=>{const context=hookContext||testContext;if(!context)return fn({});const fixtures=getFixture(context);if(!(fixtures==null?void 0:fixtures.length))return fn(context);const usedProps=getUsedProps(fn);const hasAutoFixture=fixtures.some(({auto})=>auto);if(!usedProps.length&&!hasAutoFixture)return fn(context);if(!fixtureValueMaps.get(context))fixtureValueMaps.set(context,/* @__PURE__ */new Map());const fixtureValueMap=fixtureValueMaps.get(context);if(!cleanupFnArrayMap.has(context))cleanupFnArrayMap.set(context,[]);const cleanupFnArray=cleanupFnArrayMap.get(context);const usedFixtures=fixtures.filter(({prop,auto})=>auto||usedProps.includes(prop));const pendingFixtures=resolveDeps(usedFixtures);if(!pendingFixtures.length)return fn(context);async function resolveFixtures(){for(const fixture of pendingFixtures){if(fixtureValueMap.has(fixture))continue;const resolvedValue=fixture.isFn?await resolveFixtureFunction(fixture.value,context,cleanupFnArray):fixture.value;context[fixture.prop]=resolvedValue;fixtureValueMap.set(fixture,resolvedValue);cleanupFnArray.unshift(()=>{fixtureValueMap.delete(fixture);});}}return resolveFixtures().then(()=>fn(context));};}async function resolveFixtureFunction(fixtureFn,context,cleanupFnArray){const useFnArgPromise=createDefer();let isUseFnArgResolved=false;const fixtureReturn=fixtureFn(context,async useFnArg=>{isUseFnArgResolved=true;useFnArgPromise.resolve(useFnArg);const useReturnPromise=createDefer();cleanupFnArray.push(async()=>{useReturnPromise.resolve();await fixtureReturn;});await useReturnPromise;}).catch(e=>{if(!isUseFnArgResolved){useFnArgPromise.reject(e);return;}throw e;});return useFnArgPromise;}function resolveDeps(fixtures,depSet=/* @__PURE__ */new Set(),pendingFixtures=[]){fixtures.forEach(fixture=>{if(pendingFixtures.includes(fixture))return;if(!fixture.isFn||!fixture.deps){pendingFixtures.push(fixture);return;}if(depSet.has(fixture))throw new Error(\`Circular fixture dependency detected: \${fixture.prop} <- \${[...depSet].reverse().map(d=>d.prop).join(" <- ")}\`);depSet.add(fixture);resolveDeps(fixture.deps,depSet,pendingFixtures);pendingFixtures.push(fixture);depSet.clear();});return pendingFixtures;}function getUsedProps(fn){const match=fn.toString().match(/[^(]*\\(([^)]*)/);if(!match)return[];const args=splitByComma(match[1]);if(!args.length)return[];const first=args[0];if(!(first.startsWith("{")&&first.endsWith("}")))throw new Error(\`The first argument inside a fixture must use object destructuring pattern, e.g. ({ test } => {}). Instead, received "\${first}".\`);const _first=first.slice(1,-1).replace(/\\s/g,"");const props=splitByComma(_first).map(prop=>{return prop.replace(/\\:.*|\\=.*/g,"");});const last=props.at(-1);if(last&&last.startsWith("..."))throw new Error(\`Rest parameters are not supported in fixtures, received "\${last}".\`);return props;}function splitByComma(s){const result=[];const stack=[];let start=0;for(let i=0;i<s.length;i++){if(s[i]==="{"||s[i]==="["){stack.push(s[i]==="{"?"}":"]");}else if(s[i]===stack[stack.length-1]){stack.pop();}else if(!stack.length&&s[i]===","){const token=s.substring(start,i).trim();if(token)result.push(token);start=i+1;}}const lastToken=s.substring(start).trim();if(lastToken)result.push(lastToken);return result;}let _test;function getCurrentTest(){return _test;}const suite=createSuite();createTest(function(name,optionsOrFn,optionsOrTest){getCurrentSuite().test.fn.call(this,formatName(name),optionsOrFn,optionsOrTest);});let runner;let defaultSuite;function getCurrentSuite(){return collectorContext.currentSuite||defaultSuite;}function createSuiteHooks(){return{beforeAll:[],afterAll:[],beforeEach:[],afterEach:[]};}function parseArguments(optionsOrFn,optionsOrTest){let options={};let fn=()=>{};if(typeof optionsOrTest==="object"){if(typeof optionsOrFn==="object")throw new TypeError("Cannot use two objects as arguments. Please provide options and a function callback in that order.");options=optionsOrTest;}else if(typeof optionsOrTest==="number"){options={timeout:optionsOrTest};}else if(typeof optionsOrFn==="object"){options=optionsOrFn;}if(typeof optionsOrFn==="function"){if(typeof optionsOrTest==="function")throw new TypeError("Cannot use two functions as arguments. Please use the second argument for options.");fn=optionsOrFn;}else if(typeof optionsOrTest==="function"){fn=optionsOrTest;}return{options,handler:fn};}function createSuiteCollector(name,factory=()=>{},mode,shuffle,each,suiteOptions){const tasks=[];const factoryQueue=[];let suite2;initSuite();const task=function(name2="",options={}){const task2={id:"",name:name2,suite:void 0,each:options.each,fails:options.fails,context:void 0,type:"custom",retry:options.retry??runner.config.retry,repeats:options.repeats,mode:options.only?"only":options.skip?"skip":options.todo?"todo":"run",meta:options.meta??/* @__PURE__ */Object.create(null)};const handler=options.handler;if(options.concurrent||!options.sequential&&runner.config.sequence.concurrent)task2.concurrent=true;if(shuffle)task2.shuffle=true;const context=createTestContext(task2,runner);Object.defineProperty(task2,"context",{value:context,enumerable:false});setFixture(context,options.fixtures);if(handler){setFn(task2,withTimeout(withFixtures(handler,context),(options==null?void 0:options.timeout)??runner.config.testTimeout));}if(runner.config.includeTaskLocation);tasks.push(task2);return task2;};const test2=createTest(function(name2,optionsOrFn,optionsOrTest){let _parseArguments=parseArguments(optionsOrFn,optionsOrTest),options=_parseArguments.options,handler=_parseArguments.handler;if(typeof suiteOptions==="object")options=Object.assign({},suiteOptions,options);options.concurrent=this.concurrent||!this.sequential&&(options==null?void 0:options.concurrent);options.sequential=this.sequential||!this.concurrent&&(options==null?void 0:options.sequential);const test3=task(formatName(name2),_objectSpread(_objectSpread(_objectSpread({},this),options),{},{handler}));test3.type="test";});const collector={type:"collector",name,mode,options:suiteOptions,test:test2,tasks,collect,task,clear,on:addHook};function addHook(name2,...fn){getHooks(suite2)[name2].push(...fn);}function initSuite(includeLocation){if(typeof suiteOptions==="number")suiteOptions={timeout:suiteOptions};suite2={id:"",type:"suite",name,mode,each,shuffle,tasks:[],meta:/* @__PURE__ */Object.create(null),projectName:""};setHooks(suite2,createSuiteHooks());}function clear(){tasks.length=0;factoryQueue.length=0;initSuite();}async function collect(file){factoryQueue.length=0;if(factory)await runWithSuite(collector,()=>factory(test2));const allChildren=[];for(const i of[...factoryQueue,...tasks])allChildren.push(i.type==="collector"?await i.collect(file):i);suite2.file=file;suite2.tasks=allChildren;allChildren.forEach(task2=>{task2.suite=suite2;if(file)task2.file=file;});return suite2;}collectTask(collector);return collector;}function createSuite(){function suiteFn(name,factoryOrOptions,optionsOrFactory={}){const mode=this.only?"only":this.skip?"skip":this.todo?"todo":"run";const currentSuite=getCurrentSuite();let _parseArguments2=parseArguments(factoryOrOptions,optionsOrFactory),options=_parseArguments2.options,factory=_parseArguments2.handler;if(currentSuite==null?void 0:currentSuite.options)options=_objectSpread(_objectSpread({},currentSuite.options),options);options.concurrent=this.concurrent||!this.sequential&&(options==null?void 0:options.concurrent);options.sequential=this.sequential||!this.concurrent&&(options==null?void 0:options.sequential);return createSuiteCollector(formatName(name),factory,mode,this.shuffle,this.each,options);}suiteFn.each=function(cases,...args){const suite2=this.withContext();this.setContext("each",true);if(Array.isArray(cases)&&args.length)cases=formatTemplateString(cases,args);return(name,optionsOrFn,fnOrOptions)=>{const _name=formatName(name);const arrayOnlyCases=cases.every(Array.isArray);const _parseArguments3=parseArguments(optionsOrFn,fnOrOptions),options=_parseArguments3.options,handler=_parseArguments3.handler;const fnFirst=typeof optionsOrFn==="function";cases.forEach((i,idx)=>{const items=Array.isArray(i)?i:[i];if(fnFirst){arrayOnlyCases?suite2(formatTitle(_name,items,idx),()=>handler(...items),options):suite2(formatTitle(_name,items,idx),()=>handler(i),options);}else{arrayOnlyCases?suite2(formatTitle(_name,items,idx),options,()=>handler(...items)):suite2(formatTitle(_name,items,idx),options,()=>handler(i));}});this.setContext("each",void 0);};};suiteFn.skipIf=condition=>condition?suite.skip:suite;suiteFn.runIf=condition=>condition?suite:suite.skip;return createChainable(["concurrent","sequential","shuffle","skip","only","todo"],suiteFn);}function createTaskCollector(fn,context){const taskFn=fn;taskFn.each=function(cases,...args){const test2=this.withContext();this.setContext("each",true);if(Array.isArray(cases)&&args.length)cases=formatTemplateString(cases,args);return(name,optionsOrFn,fnOrOptions)=>{const _name=formatName(name);const arrayOnlyCases=cases.every(Array.isArray);const _parseArguments4=parseArguments(optionsOrFn,fnOrOptions),options=_parseArguments4.options,handler=_parseArguments4.handler;const fnFirst=typeof optionsOrFn==="function";cases.forEach((i,idx)=>{const items=Array.isArray(i)?i:[i];if(fnFirst){arrayOnlyCases?test2(formatTitle(_name,items,idx),()=>handler(...items),options):test2(formatTitle(_name,items,idx),()=>handler(i),options);}else{arrayOnlyCases?test2(formatTitle(_name,items,idx),options,()=>handler(...items)):test2(formatTitle(_name,items,idx),options,()=>handler(i));}});this.setContext("each",void 0);};};taskFn.skipIf=function(condition){return condition?this.skip:this;};taskFn.runIf=function(condition){return condition?this:this.skip;};taskFn.extend=function(fixtures){const _context=mergeContextFixtures(fixtures,context);return createTest(function fn2(name,optionsOrFn,optionsOrTest){getCurrentSuite().test.fn.call(this,formatName(name),optionsOrFn,optionsOrTest);},_context);};const _test=createChainable(["concurrent","sequential","skip","only","todo","fails"],taskFn);if(context)_test.mergeContext(context);return _test;}function createTest(fn,context){return createTaskCollector(fn,context);}function formatName(name){return typeof name==="string"?name:name instanceof Function?name.name||"<anonymous>":String(name);}function formatTitle(template,items,idx){if(template.includes("%#")){template=template.replace(/%%/g,"__vitest_escaped_%__").replace(/%#/g,\`\${idx}\`).replace(/__vitest_escaped_%__/g,"%%");}const count=template.split("%").length-1;let formatted=format(template,...items.slice(0,count));if(isObject$1(items[0])){formatted=formatted.replace(/\\$([$\\w_.]+)/g,// https://github.com/chaijs/chai/pull/1490
(_,key)=>{var _a,_b;return objDisplay$2(objectAttr(items[0],key),{truncate:(_b=(_a=void 0)==null?void 0:_a.chaiConfig)==null?void 0:_b.truncateThreshold});});}return formatted;}function formatTemplateString(cases,args){const header=cases.join("").trim().replace(/ /g,"").split("\\n").map(i=>i.split("|"))[0];const res=[];for(let i=0;i<Math.floor(args.length/header.length);i++){const oneCase={};for(let j=0;j<header.length;j++)oneCase[header[j]]=args[i*header.length+j];res.push(oneCase);}return res;}function getWorkerState(){const workerState=globalThis.__vitest_worker__;if(!workerState){const errorMsg='Vitest failed to access its internal state.\\n\\nOne of the following is possible:\\n- "vitest" is imported directly without running "vitest" command\\n- "vitest" is imported inside "globalSetup" (to fix this, use "setupFiles" instead, because "globalSetup" runs in a different context)\\n- Otherwise, it might be a Vitest bug. Please report it to https://github.com/vitest-dev/vitest/issues\\n';throw new Error(errorMsg);}return workerState;}function getCurrentEnvironment(){const state=getWorkerState();return state==null?void 0:state.environment.name;}var chai$3={};/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */ /*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new \`{}\`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */function exclude(){var excludes=[].slice.call(arguments);function excludeProps(res,obj){Object.keys(obj).forEach(function(key){if(!~excludes.indexOf(key))res[key]=obj[key];});}return function extendExclude(){var args=[].slice.call(arguments),i=0,res={};for(;i<args.length;i++){excludeProps(res,args[i]);}return res;};}/*!
 * Primary Exports
 */var assertionError=AssertionError$1;/**
 * ### AssertionError
 *
 * An extension of the JavaScript \`Error\` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */function AssertionError$1(message,_props,ssf){var extend=exclude('name','message','stack','constructor','toJSON'),props=extend(_props||{});// default values
this.message=message||'Unspecified AssertionError';this.showDiff=false;// copy from properties
for(var key in props){this[key]=props[key];}// capture stack trace
ssf=ssf||AssertionError$1;if(Error.captureStackTrace){Error.captureStackTrace(this,ssf);}else{try{throw new Error();}catch(e){this.stack=e.stack;}}}/*!
 * Inherit from Error.prototype
 */AssertionError$1.prototype=Object.create(Error.prototype);/*!
 * Statically set name
 */AssertionError$1.prototype.name='AssertionError';/*!
 * Ensure correct constructor
 */AssertionError$1.prototype.constructor=AssertionError$1;/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: \`true\`)
 * @return {Object} object that can be \`JSON.stringify\`
 */AssertionError$1.prototype.toJSON=function(stack){var extend=exclude('constructor','toJSON','stack'),props=extend({name:this.name},this);// include stack if exists and not turned off
if(false!==stack&&this.stack){props.stack=this.stack;}return props;};var utils={};/* !
 * Chai - pathval utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */ /**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has own
 * or inherited from prototype chain named property.
 *
 * Basically does the same thing as the \`in\`
 * operator but works properly with null/undefined values
 * and other primitives.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty(obj, 'str');  // true
 *     hasProperty(obj, 'constructor');  // true
 *     hasProperty(obj, 'bar');  // false
 *
 *     hasProperty(obj.str, 'length'); // true
 *     hasProperty(obj.str, 1);  // true
 *     hasProperty(obj.str, 5);  // false
 *
 *     hasProperty(obj.arr, 'length');  // true
 *     hasProperty(obj.arr, 2);  // true
 *     hasProperty(obj.arr, 3);  // false
 *
 * @param {Object} object
 * @param {String|Symbol} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name hasProperty
 * @api public
 */function hasProperty(obj,name){if(typeof obj==='undefined'||obj===null){return false;}// The \`in\` operator does not work with primitives.
return name in Object(obj);}/* !
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with \`internalGetPathValue\`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be infinitely deep and nested.
 * * Arrays are also valid using the formal \`myobject.document[3].property\`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */function parsePath(path){var str=path.replace(/([^\\\\])\\[/g,'$1.[');var parts=str.match(/(\\\\\\.|[^.]+?)+/g);return parts.map(function mapMatches(value){if(value==='constructor'||value==='__proto__'||value==='prototype'){return{};}var regexp=/^\\[(\\d+)\\]$/;var mArr=regexp.exec(value);var parsed=null;if(mArr){parsed={i:parseFloat(mArr[1])};}else{parsed={p:value.replace(/\\\\([.[\\]])/g,'$1')};}return parsed;});}/* !
 * ## internalGetPathValue(obj, parsed[, pathDepth])
 *
 * Helper companion function for \`.parsePath\` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(obj, parsed);
 *
 * @param {Object} object to search against
 * @param {Object} parsed definition from \`parsePath\`.
 * @param {Number} depth (nesting level) of the property we want to retrieve
 * @returns {Object|Undefined} value
 * @api private
 */function internalGetPathValue(obj,parsed,pathDepth){var temporaryValue=obj;var res=null;pathDepth=typeof pathDepth==='undefined'?parsed.length:pathDepth;for(var i=0;i<pathDepth;i++){var part=parsed[i];if(temporaryValue){if(typeof part.p==='undefined'){temporaryValue=temporaryValue[part.i];}else{temporaryValue=temporaryValue[part.p];}if(i===pathDepth-1){res=temporaryValue;}}}return res;}/* !
 * ## internalSetPathValue(obj, value, parsed)
 *
 * Companion function for \`parsePath\` that sets
 * the value located at a parsed address.
 *
 *  internalSetPathValue(obj, 'value', parsed);
 *
 * @param {Object} object to search and define on
 * @param {*} value to use upon set
 * @param {Object} parsed definition from \`parsePath\`
 * @api private
 */function internalSetPathValue(obj,val,parsed){var tempObj=obj;var pathDepth=parsed.length;var part=null;// Here we iterate through every part of the path
for(var i=0;i<pathDepth;i++){var propName=null;var propVal=null;part=parsed[i];// If it's the last part of the path, we set the 'propName' value with the property name
if(i===pathDepth-1){propName=typeof part.p==='undefined'?part.i:part.p;// Now we set the property with the name held by 'propName' on object with the desired val
tempObj[propName]=val;}else if(typeof part.p!=='undefined'&&tempObj[part.p]){tempObj=tempObj[part.p];}else if(typeof part.i!=='undefined'&&tempObj[part.i]){tempObj=tempObj[part.i];}else{// If the obj doesn't have the property we create one with that name to define it
var next=parsed[i+1];// Here we set the name of the property which will be defined
propName=typeof part.p==='undefined'?part.i:part.p;// Here we decide if this property will be an array or a new object
propVal=typeof next.p==='undefined'?[]:{};tempObj[propName]=propVal;tempObj=tempObj[propName];}}}/**
 * ### .getPathInfo(object, path)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by \`path\`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise \`undefined\`
 * * exists - Whether the property exists or not
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */function getPathInfo(obj,path){var parsed=parsePath(path);var last=parsed[parsed.length-1];var info={parent:parsed.length>1?internalGetPathValue(obj,parsed,parsed.length-1):obj,name:last.p||last.i,value:internalGetPathValue(obj,parsed)};info.exists=hasProperty(info.parent,info.name);return info;}/**
 * ### .getPathValue(object, path)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue(obj, 'prop1.str'); // Hello
 *     getPathValue(obj, 'prop1.att[2]'); // b
 *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} value or \`undefined\`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */function getPathValue(obj,path){var info=getPathInfo(obj,path);return info.value;}/**
 * ### .setPathValue(object, path, value)
 *
 * Define the value in an object at a given string path.
 *
 * \`\`\`js
 * var obj = {
 *     prop1: {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *   , prop2: {
 *         arr: [ { nested: 'Universe' } ]
 *       , str: 'Hello again!'
 *     }
 * };
 * \`\`\`
 *
 * The following would be acceptable.
 *
 * \`\`\`js
 * var properties = require('tea-properties');
 * properties.set(obj, 'prop1.str', 'Hello Universe!');
 * properties.set(obj, 'prop1.arr[2]', 'B');
 * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
 * \`\`\`
 *
 * @param {Object} object
 * @param {String} path
 * @param {Mixed} value
 * @api private
 */function setPathValue(obj,path,val){var parsed=parsePath(path);internalSetPathValue(obj,val,parsed);return obj;}var pathval={hasProperty:hasProperty,getPathInfo:getPathInfo,getPathValue:getPathValue,setPathValue:setPathValue};/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or \`undefined\` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns \`bar\`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */var flag$5=function flag(obj,key,value){var flags=obj.__flags||(obj.__flags=Object.create(null));if(arguments.length===3){flags[key]=value;}else{return flags[key];}};/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Module dependencies
 */var flag$4=flag$5;/**
 * ### .test(object, expression)
 *
 * Test an object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */var test$1=function test(obj,args){var negate=flag$4(obj,'negate'),expr=args[0];return negate?!expr:expr;};var typeDetect$1={exports:{}};(function(module,exports){(function(global,factory){module.exports=factory();})(commonjsGlobal$1,function(){/* !
     * type-detect
     * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
     * MIT Licensed
     */var promiseExists=typeof Promise==='function';/* eslint-disable no-undef */var globalObject=typeof self==='object'?self:commonjsGlobal$1;// eslint-disable-line id-blacklist
var symbolExists=typeof Symbol!=='undefined';var mapExists=typeof Map!=='undefined';var setExists=typeof Set!=='undefined';var weakMapExists=typeof WeakMap!=='undefined';var weakSetExists=typeof WeakSet!=='undefined';var dataViewExists=typeof DataView!=='undefined';var symbolIteratorExists=symbolExists&&typeof Symbol.iterator!=='undefined';var symbolToStringTagExists=symbolExists&&typeof Symbol.toStringTag!=='undefined';var setEntriesExists=setExists&&typeof Set.prototype.entries==='function';var mapEntriesExists=mapExists&&typeof Map.prototype.entries==='function';var setIteratorPrototype=setEntriesExists&&Object.getPrototypeOf(new Set().entries());var mapIteratorPrototype=mapEntriesExists&&Object.getPrototypeOf(new Map().entries());var arrayIteratorExists=symbolIteratorExists&&typeof Array.prototype[Symbol.iterator]==='function';var arrayIteratorPrototype=arrayIteratorExists&&Object.getPrototypeOf([][Symbol.iterator]());var stringIteratorExists=symbolIteratorExists&&typeof String.prototype[Symbol.iterator]==='function';var stringIteratorPrototype=stringIteratorExists&&Object.getPrototypeOf(''[Symbol.iterator]());var toStringLeftSliceLength=8;var toStringRightSliceLength=-1;/**
     * ### typeOf (obj)
     *
     * Uses \`Object.prototype.toString\` to determine the type of an object,
     * normalising behaviour across engine versions & well optimised.
     *
     * @param {Mixed} object
     * @return {String} object type
     * @api public
     */function typeDetect(obj){/* ! Speed optimisation
       * Pre:
       *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
       *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
       *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
       *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
       *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
       * Post:
       *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
       *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
       *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
       *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
       *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
       */var typeofObj=typeof obj;if(typeofObj!=='object'){return typeofObj;}/* ! Speed optimisation
       * Pre:
       *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
       * Post:
       *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
       */if(obj===null){return'null';}/* ! Spec Conformance
       * Test: \`Object.prototype.toString.call(window)\`\`
       *  - Node === "[object global]"
       *  - Chrome === "[object global]"
       *  - Firefox === "[object Window]"
       *  - PhantomJS === "[object Window]"
       *  - Safari === "[object Window]"
       *  - IE 11 === "[object Window]"
       *  - IE Edge === "[object Window]"
       * Test: \`Object.prototype.toString.call(this)\`\`
       *  - Chrome Worker === "[object global]"
       *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
       *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
       *  - IE 11 Worker === "[object WorkerGlobalScope]"
       *  - IE Edge Worker === "[object WorkerGlobalScope]"
       */if(obj===globalObject){return'global';}/* ! Speed optimisation
       * Pre:
       *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
       * Post:
       *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
       */if(Array.isArray(obj)&&(symbolToStringTagExists===false||!(Symbol.toStringTag in obj))){return'Array';}// Not caching existence of \`window\` and related properties due to potential
// for \`window\` to be unset before tests in quasi-browser environments.
if(typeof window==='object'&&window!==null){/* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/browsers.html#location)
         * WhatWG HTML$7.7.3 - The \`Location\` interface
         * Test: \`Object.prototype.toString.call(window.location)\`\`
         *  - IE <=11 === "[object Object]"
         *  - IE Edge <=13 === "[object Object]"
         */if(typeof window.location==='object'&&obj===window.location){return'Location';}/* ! Spec Conformance
         * (https://html.spec.whatwg.org/#document)
         * WhatWG HTML$3.1.1 - The \`Document\` object
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         *       WhatWG HTML states:
         *         > For historical reasons, Window objects must also have a
         *         > writable, configurable, non-enumerable property named
         *         > HTMLDocument whose value is the Document interface object.
         * Test: \`Object.prototype.toString.call(document)\`\`
         *  - Chrome === "[object HTMLDocument]"
         *  - Firefox === "[object HTMLDocument]"
         *  - Safari === "[object HTMLDocument]"
         *  - IE <=10 === "[object Document]"
         *  - IE 11 === "[object HTMLDocument]"
         *  - IE Edge <=13 === "[object HTMLDocument]"
         */if(typeof window.document==='object'&&obj===window.document){return'Document';}if(typeof window.navigator==='object'){/* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
           * Test: \`Object.prototype.toString.call(navigator.mimeTypes)\`\`
           *  - IE <=10 === "[object MSMimeTypesCollection]"
           */if(typeof window.navigator.mimeTypes==='object'&&obj===window.navigator.mimeTypes){return'MimeTypeArray';}/* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
           * Test: \`Object.prototype.toString.call(navigator.plugins)\`\`
           *  - IE <=10 === "[object MSPluginsCollection]"
           */if(typeof window.navigator.plugins==='object'&&obj===window.navigator.plugins){return'PluginArray';}}if((typeof window.HTMLElement==='function'||typeof window.HTMLElement==='object')&&obj instanceof window.HTMLElement){/* ! Spec Conformance
          * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
          * WhatWG HTML$4.4.4 - The \`blockquote\` element - Interface \`HTMLQuoteElement\`
          * Test: \`Object.prototype.toString.call(document.createElement('blockquote'))\`\`
          *  - IE <=10 === "[object HTMLBlockElement]"
          */if(obj.tagName==='BLOCKQUOTE'){return'HTMLQuoteElement';}/* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltabledatacellelement)
           * WhatWG HTML$4.9.9 - The \`td\` element - Interface \`HTMLTableDataCellElement\`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('td'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */if(obj.tagName==='TD'){return'HTMLTableDataCellElement';}/* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltableheadercellelement)
           * WhatWG HTML$4.9.9 - The \`td\` element - Interface \`HTMLTableHeaderCellElement\`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('th'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */if(obj.tagName==='TH'){return'HTMLTableHeaderCellElement';}}}/* ! Speed optimisation
      * Pre:
      *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
      *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
      *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
      *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
      *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
      *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
      *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
      *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
      *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
      * Post:
      *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
      *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
      *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
      *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
      *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
      *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
      *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
      *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
      *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
      */var stringTag=symbolToStringTagExists&&obj[Symbol.toStringTag];if(typeof stringTag==='string'){return stringTag;}var objPrototype=Object.getPrototypeOf(obj);/* ! Speed optimisation
      * Pre:
      *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
      *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
      * Post:
      *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
      *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
      */if(objPrototype===RegExp.prototype){return'RegExp';}/* ! Speed optimisation
      * Pre:
      *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
      * Post:
      *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
      */if(objPrototype===Date.prototype){return'Date';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
       * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
       * Test: \`Object.prototype.toString.call(Promise.resolve())\`\`
       *  - Chrome <=47 === "[object Object]"
       *  - Edge <=20 === "[object Object]"
       *  - Firefox 29-Latest === "[object Promise]"
       *  - Safari 7.1-Latest === "[object Promise]"
       */if(promiseExists&&objPrototype===Promise.prototype){return'Promise';}/* ! Speed optimisation
      * Pre:
      *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
      * Post:
      *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
      */if(setExists&&objPrototype===Set.prototype){return'Set';}/* ! Speed optimisation
      * Pre:
      *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
      * Post:
      *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
      */if(mapExists&&objPrototype===Map.prototype){return'Map';}/* ! Speed optimisation
      * Pre:
      *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
      * Post:
      *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
      */if(weakSetExists&&objPrototype===WeakSet.prototype){return'WeakSet';}/* ! Speed optimisation
      * Pre:
      *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
      * Post:
      *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
      */if(weakMapExists&&objPrototype===WeakMap.prototype){return'WeakMap';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
       * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
       * Test: \`Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))\`\`
       *  - Edge <=13 === "[object Object]"
       */if(dataViewExists&&objPrototype===DataView.prototype){return'DataView';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
       * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
       * Test: \`Object.prototype.toString.call(new Map().entries())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(mapExists&&objPrototype===mapIteratorPrototype){return'Map Iterator';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
       * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
       * Test: \`Object.prototype.toString.call(new Set().entries())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(setExists&&objPrototype===setIteratorPrototype){return'Set Iterator';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
       * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
       * Test: \`Object.prototype.toString.call([][Symbol.iterator]())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(arrayIteratorExists&&objPrototype===arrayIteratorPrototype){return'Array Iterator';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
       * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
       * Test: \`Object.prototype.toString.call(''[Symbol.iterator]())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(stringIteratorExists&&objPrototype===stringIteratorPrototype){return'String Iterator';}/* ! Speed optimisation
      * Pre:
      *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
      * Post:
      *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
      */if(objPrototype===null){return'Object';}return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength,toStringRightSliceLength);}return typeDetect;});})(typeDetect$1);var typeDetectExports$1=typeDetect$1.exports;/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */var AssertionError=assertionError;var flag$3=flag$5;var type$3=typeDetectExports$1;var expectTypes=function expectTypes(obj,types){var flagMsg=flag$3(obj,'message');var ssfi=flag$3(obj,'ssfi');flagMsg=flagMsg?flagMsg+': ':'';obj=flag$3(obj,'object');types=types.map(function(t){return t.toLowerCase();});types.sort();// Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'
var str=types.map(function(t,index){var art=~['a','e','i','o','u'].indexOf(t.charAt(0))?'an':'a';var or=types.length>1&&index===types.length-1?'or ':'';return or+art+' '+t;}).join(', ');var objType=type$3(obj).toLowerCase();if(!types.some(function(expected){return objType===expected;})){throw new AssertionError(flagMsg+'object tested must be '+str+', but '+objType+' given',undefined,ssfi);}};/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .getActual(object, [actual])
 *
 * Returns the \`actual\` value for an Assertion.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */var getActual$1=function getActual(obj,args){return args.length>4?args[4]:obj._obj;};const require$$1=/*@__PURE__*/getAugmentedNamespace(loupe$1);var config$5={/**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */includeStack:false,/**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the \`showDiff\` flag should be included in the thrown
   * AssertionErrors. \`false\` will always be \`false\`; \`true\`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */showDiff:true,/**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like \`[ Array(3) ]\` or \`{ Object (prop1, prop2) }\`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */truncateThreshold:40,/**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {Boolean}
   * @api public
   */useProxy:true,/**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the \`useProxy\` configuration setting is enabled.
   * By default, \`then\` and \`inspect\` will not throw an error if they do not exist on the
   * assertion object because the \`.inspect\` property is read by \`util.inspect\` (for example, when
   * using \`console.log\` on the assertion object) and \`.then\` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @api public
   */proxyExcludedKeys:['then','catch','inspect','toJSON'],/**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the \`deep-eql\` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *        return chai.util.eql(expected, actual, {
   *           comparator: (expected, actual) => {
   *              // for non number comparison, use the default behavior
   *              if(typeof expected !== 'number') return null;
   *              // allow a difference of 10 between compared numbers
   *              return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *           }
   *        })
   *     };
   *
   * @param {Function}
   * @api public
   */deepEqual:null};var loupe=require$$1;var config$4=config$5;var inspect_1=inspect$2;/**
 * ### .inspect(obj, [showHidden], [depth], [colors])
 *
 * Echoes the value of a value. Tries to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects. Default is false.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 * @namespace Utils
 * @name inspect
 */function inspect$2(obj,showHidden,depth,colors){var options={colors:colors,depth:typeof depth==='undefined'?2:depth,showHidden:showHidden,truncate:config$4.truncateThreshold?config$4.truncateThreshold:Infinity};return loupe.inspect(obj,options);}/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Module dependencies
 */var inspect$1=inspect_1;var config$3=config$5;/**
 * ### .objDisplay(object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @returns {string} stringified object
 * @name objDisplay
 * @namespace Utils
 * @api public
 */var objDisplay$1=function objDisplay(obj){var str=inspect$1(obj),type=Object.prototype.toString.call(obj);if(config$3.truncateThreshold&&str.length>=config$3.truncateThreshold){if(type==='[object Function]'){return!obj.name||obj.name===''?'[Function]':'[Function: '+obj.name+']';}else if(type==='[object Array]'){return'[ Array('+obj.length+') ]';}else if(type==='[object Object]'){var keys=Object.keys(obj),kstr=keys.length>2?keys.splice(0,2).join(', ')+', ...':keys.join(', ');return'{ Object ('+kstr+') }';}else{return str;}}else{return str;}};/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Module dependencies
 */var flag$2=flag$5,getActual=getActual$1,objDisplay=objDisplay$1;/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - \`#{this}\` current asserted object
 * - \`#{act}\` actual value
 * - \`#{exp}\` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */var getMessage$1=function getMessage(obj,args){var negate=flag$2(obj,'negate'),val=flag$2(obj,'object'),expected=args[3],actual=getActual(obj,args),msg=negate?args[2]:args[1],flagMsg=flag$2(obj,'message');if(typeof msg==="function")msg=msg();msg=msg||'';msg=msg.replace(/#\\{this\\}/g,function(){return objDisplay(val);}).replace(/#\\{act\\}/g,function(){return objDisplay(actual);}).replace(/#\\{exp\\}/g,function(){return objDisplay(expected);});return flagMsg?flagMsg+': '+msg:msg;};/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for \`assertion\` to \`object\`. If
 * \`includeAll\` is set to \`false\`, then the base Chai
 * assertion flags (namely \`object\`, \`ssfi\`, \`lockSsfi\`,
 * and \`message\`) will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAssertion = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */var transferFlags=function transferFlags(assertion,object,includeAll){var flags=assertion.__flags||(assertion.__flags=Object.create(null));if(!object.__flags){object.__flags=Object.create(null);}includeAll=arguments.length===3?includeAll:true;for(var flag in flags){if(includeAll||flag!=='object'&&flag!=='ssfi'&&flag!=='lockSsfi'&&flag!='message'){object.__flags[flag]=flags[flag];}}};var deepEql={exports:{}};/* globals Symbol: false, Uint8Array: false, WeakMap: false */ /*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var type$2=typeDetectExports$1;function FakeMap(){this._key='chai/deep-eql__'+Math.random()+Date.now();}FakeMap.prototype={get:function get(key){return key[this._key];},set:function set(key,value){if(Object.isExtensible(key)){Object.defineProperty(key,this._key,{value:value,configurable:true});}}};var MemoizeMap=typeof WeakMap==='function'?WeakMap:FakeMap;/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/function memoizeCompare(leftHandOperand,rightHandOperand,memoizeMap){// Technically, WeakMap keys can *only* be objects, not primitives.
if(!memoizeMap||isPrimitive$1(leftHandOperand)||isPrimitive$1(rightHandOperand)){return null;}var leftHandMap=memoizeMap.get(leftHandOperand);if(leftHandMap){var result=leftHandMap.get(rightHandOperand);if(typeof result==='boolean'){return result;}}return null;}/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/function memoizeSet(leftHandOperand,rightHandOperand,memoizeMap,result){// Technically, WeakMap keys can *only* be objects, not primitives.
if(!memoizeMap||isPrimitive$1(leftHandOperand)||isPrimitive$1(rightHandOperand)){return;}var leftHandMap=memoizeMap.get(leftHandOperand);if(leftHandMap){leftHandMap.set(rightHandOperand,result);}else{leftHandMap=new MemoizeMap();leftHandMap.set(rightHandOperand,result);memoizeMap.set(leftHandOperand,leftHandMap);}}/*!
 * Primary Export
 */deepEql.exports=deepEqual;deepEql.exports.MemoizeMap=MemoizeMap;/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing \`false\` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */function deepEqual(leftHandOperand,rightHandOperand,options){// If we have a comparator, we can't assume anything; so bail to its check first.
if(options&&options.comparator){return extensiveDeepEqual(leftHandOperand,rightHandOperand,options);}var simpleResult=simpleEqual(leftHandOperand,rightHandOperand);if(simpleResult!==null){return simpleResult;}// Deeper comparisons are pushed through to a larger function
return extensiveDeepEqual(leftHandOperand,rightHandOperand,options);}/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */function simpleEqual(leftHandOperand,rightHandOperand){// Equal references (except for Numbers) can be returned early
if(leftHandOperand===rightHandOperand){// Handle +-0 cases
return leftHandOperand!==0||1/leftHandOperand===1/rightHandOperand;}// handle NaN cases
if(leftHandOperand!==leftHandOperand&&// eslint-disable-line no-self-compare
rightHandOperand!==rightHandOperand// eslint-disable-line no-self-compare
){return true;}// Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
// strings, and undefined, can be compared by reference.
if(isPrimitive$1(leftHandOperand)||isPrimitive$1(rightHandOperand)){// Easy out b/c it would have passed the first equality check
return false;}return null;}/*!
 * The main logic of the \`deepEqual\` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing \`false\` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/function extensiveDeepEqual(leftHandOperand,rightHandOperand,options){options=options||{};options.memoize=options.memoize===false?false:options.memoize||new MemoizeMap();var comparator=options&&options.comparator;// Check if a memoized result exists.
var memoizeResultLeft=memoizeCompare(leftHandOperand,rightHandOperand,options.memoize);if(memoizeResultLeft!==null){return memoizeResultLeft;}var memoizeResultRight=memoizeCompare(rightHandOperand,leftHandOperand,options.memoize);if(memoizeResultRight!==null){return memoizeResultRight;}// If a comparator is present, use it.
if(comparator){var comparatorResult=comparator(leftHandOperand,rightHandOperand);// Comparators may return null, in which case we want to go back to default behavior.
if(comparatorResult===false||comparatorResult===true){memoizeSet(leftHandOperand,rightHandOperand,options.memoize,comparatorResult);return comparatorResult;}// To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
// what to do, we need to make sure to return the basic tests first before we move on.
var simpleResult=simpleEqual(leftHandOperand,rightHandOperand);if(simpleResult!==null){// Don't memoize this, it takes longer to set/retrieve than to just compare.
return simpleResult;}}var leftHandType=type$2(leftHandOperand);if(leftHandType!==type$2(rightHandOperand)){memoizeSet(leftHandOperand,rightHandOperand,options.memoize,false);return false;}// Temporarily set the operands in the memoize object to prevent blowing the stack
memoizeSet(leftHandOperand,rightHandOperand,options.memoize,true);var result=extensiveDeepEqualByType(leftHandOperand,rightHandOperand,leftHandType,options);memoizeSet(leftHandOperand,rightHandOperand,options.memoize,result);return result;}function extensiveDeepEqualByType(leftHandOperand,rightHandOperand,leftHandType,options){switch(leftHandType){case'String':case'Number':case'Boolean':case'Date':// If these types are their instance types (e.g. \`new Number\`) then re-deepEqual against their values
return deepEqual(leftHandOperand.valueOf(),rightHandOperand.valueOf());case'Promise':case'Symbol':case'function':case'WeakMap':case'WeakSet':return leftHandOperand===rightHandOperand;case'Error':return keysEqual(leftHandOperand,rightHandOperand,['name','message','code'],options);case'Arguments':case'Int8Array':case'Uint8Array':case'Uint8ClampedArray':case'Int16Array':case'Uint16Array':case'Int32Array':case'Uint32Array':case'Float32Array':case'Float64Array':case'Array':return iterableEqual(leftHandOperand,rightHandOperand,options);case'RegExp':return regexpEqual(leftHandOperand,rightHandOperand);case'Generator':return generatorEqual(leftHandOperand,rightHandOperand,options);case'DataView':return iterableEqual(new Uint8Array(leftHandOperand.buffer),new Uint8Array(rightHandOperand.buffer),options);case'ArrayBuffer':return iterableEqual(new Uint8Array(leftHandOperand),new Uint8Array(rightHandOperand),options);case'Set':return entriesEqual(leftHandOperand,rightHandOperand,options);case'Map':return entriesEqual(leftHandOperand,rightHandOperand,options);case'Temporal.PlainDate':case'Temporal.PlainTime':case'Temporal.PlainDateTime':case'Temporal.Instant':case'Temporal.ZonedDateTime':case'Temporal.PlainYearMonth':case'Temporal.PlainMonthDay':return leftHandOperand.equals(rightHandOperand);case'Temporal.Duration':return leftHandOperand.total('nanoseconds')===rightHandOperand.total('nanoseconds');case'Temporal.TimeZone':case'Temporal.Calendar':return leftHandOperand.toString()===rightHandOperand.toString();default:return objectEqual(leftHandOperand,rightHandOperand,options);}}/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */function regexpEqual(leftHandOperand,rightHandOperand){return leftHandOperand.toString()===rightHandOperand.toString();}/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function entriesEqual(leftHandOperand,rightHandOperand,options){// IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
if(leftHandOperand.size!==rightHandOperand.size){return false;}if(leftHandOperand.size===0){return true;}var leftHandItems=[];var rightHandItems=[];leftHandOperand.forEach(function gatherEntries(key,value){leftHandItems.push([key,value]);});rightHandOperand.forEach(function gatherEntries(key,value){rightHandItems.push([key,value]);});return iterableEqual(leftHandItems.sort(),rightHandItems.sort(),options);}/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function iterableEqual(leftHandOperand,rightHandOperand,options){var length=leftHandOperand.length;if(length!==rightHandOperand.length){return false;}if(length===0){return true;}var index=-1;while(++index<length){if(deepEqual(leftHandOperand[index],rightHandOperand[index],options)===false){return false;}}return true;}/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function generatorEqual(leftHandOperand,rightHandOperand,options){return iterableEqual(getGeneratorEntries(leftHandOperand),getGeneratorEntries(rightHandOperand),options);}/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} \`true\` if the object has an @@iterator function.
 */function hasIteratorFunction(target){return typeof Symbol!=='undefined'&&typeof target==='object'&&typeof Symbol.iterator!=='undefined'&&typeof target[Symbol.iterator]==='function';}/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */function getIteratorEntries(target){if(hasIteratorFunction(target)){try{return getGeneratorEntries(target[Symbol.iterator]());}catch(iteratorError){return[];}}return[];}/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */function getGeneratorEntries(generator){var generatorResult=generator.next();var accumulator=[generatorResult.value];while(generatorResult.done===false){generatorResult=generator.next();accumulator.push(generatorResult.value);}return accumulator;}/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */function getEnumerableKeys(target){var keys=[];for(var key in target){keys.push(key);}return keys;}function getEnumerableSymbols(target){var keys=[];var allKeys=Object.getOwnPropertySymbols(target);for(var i=0;i<allKeys.length;i+=1){var key=allKeys[i];if(Object.getOwnPropertyDescriptor(target,key).enumerable){keys.push(key);}}return keys;}/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function keysEqual(leftHandOperand,rightHandOperand,keys,options){var length=keys.length;if(length===0){return true;}for(var i=0;i<length;i+=1){if(deepEqual(leftHandOperand[keys[i]],rightHandOperand[keys[i]],options)===false){return false;}}return true;}/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to \`deepEqual\`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function objectEqual(leftHandOperand,rightHandOperand,options){var leftHandKeys=getEnumerableKeys(leftHandOperand);var rightHandKeys=getEnumerableKeys(rightHandOperand);var leftHandSymbols=getEnumerableSymbols(leftHandOperand);var rightHandSymbols=getEnumerableSymbols(rightHandOperand);leftHandKeys=leftHandKeys.concat(leftHandSymbols);rightHandKeys=rightHandKeys.concat(rightHandSymbols);if(leftHandKeys.length&&leftHandKeys.length===rightHandKeys.length){if(iterableEqual(mapSymbols(leftHandKeys).sort(),mapSymbols(rightHandKeys).sort())===false){return false;}return keysEqual(leftHandOperand,rightHandOperand,leftHandKeys,options);}var leftHandEntries=getIteratorEntries(leftHandOperand);var rightHandEntries=getIteratorEntries(rightHandOperand);if(leftHandEntries.length&&leftHandEntries.length===rightHandEntries.length){leftHandEntries.sort();rightHandEntries.sort();return iterableEqual(leftHandEntries,rightHandEntries,options);}if(leftHandKeys.length===0&&leftHandEntries.length===0&&rightHandKeys.length===0&&rightHandEntries.length===0){return true;}return false;}/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */function isPrimitive$1(value){return value===null||typeof value!=='object';}function mapSymbols(arr){return arr.map(function mapSymbol(entry){if(typeof entry==='symbol'){return entry.toString();}return entry;});}var deepEqlExports=deepEql.exports;var config$2=config$5;/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .isProxyEnabled()
 *
 * Helper function to check if Chai's proxy protection feature is enabled. If
 * proxies are unsupported or disabled via the user's Chai config, then return
 * false. Otherwise, return true.
 *
 * @namespace Utils
 * @name isProxyEnabled
 */var isProxyEnabled$1=function isProxyEnabled(){return config$2.useProxy&&typeof Proxy!=='undefined'&&typeof Reflect!=='undefined';};/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var addProperty;var hasRequiredAddProperty;function requireAddProperty(){if(hasRequiredAddProperty)return addProperty;hasRequiredAddProperty=1;var chai=requireChai();var flag=flag$5;var isProxyEnabled=isProxyEnabled$1;var transferFlags$1=transferFlags;/**
   * ### .addProperty(ctx, name, getter)
   *
   * Adds a property to the prototype of an object.
   *
   *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
   *       var obj = utils.flag(this, 'object');
   *       new chai.Assertion(obj).to.be.instanceof(Foo);
   *     });
   *
   * Can also be accessed directly from \`chai.Assertion\`.
   *
   *     chai.Assertion.addProperty('foo', fn);
   *
   * Then can be used as any other assertion.
   *
   *     expect(myFoo).to.be.foo;
   *
   * @param {Object} ctx object to which the property is added
   * @param {String} name of property to add
   * @param {Function} getter function to be used for name
   * @namespace Utils
   * @name addProperty
   * @api public
   */addProperty=function addProperty(ctx,name,getter){getter=getter===undefined?function(){}:getter;Object.defineProperty(ctx,name,{get:function propertyGetter(){// Setting the \`ssfi\` flag to \`propertyGetter\` causes this function to
// be the starting point for removing implementation frames from the
// stack trace of a failed assertion.
//
// However, we only want to use this function as the starting point if
// the \`lockSsfi\` flag isn't set and proxy protection is disabled.
//
// If the \`lockSsfi\` flag is set, then either this assertion has been
// overwritten by another assertion, or this assertion is being invoked
// from inside of another assertion. In the first case, the \`ssfi\` flag
// has already been set by the overwriting assertion. In the second
// case, the \`ssfi\` flag has already been set by the outer assertion.
//
// If proxy protection is enabled, then the \`ssfi\` flag has already been
// set by the proxy getter.
if(!isProxyEnabled()&&!flag(this,'lockSsfi')){flag(this,'ssfi',propertyGetter);}var result=getter.call(this);if(result!==undefined)return result;var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;},configurable:true});};return addProperty;}var fnLengthDesc=Object.getOwnPropertyDescriptor(function(){},'length');/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .addLengthGuard(fn, assertionName, isChainable)
 *
 * Define \`length\` as a getter on the given uninvoked method assertion. The
 * getter acts as a guard against chaining \`length\` directly off of an uninvoked
 * method assertion, which is a problem because it references \`function\`'s
 * built-in \`length\` property instead of Chai's \`length\` assertion. When the
 * getter catches the user making this mistake, it throws an error with a
 * helpful message.
 *
 * There are two ways in which this mistake can be made. The first way is by
 * chaining the \`length\` assertion directly off of an uninvoked chainable
 * method. In this case, Chai suggests that the user use \`lengthOf\` instead. The
 * second way is by chaining the \`length\` assertion directly off of an uninvoked
 * non-chainable method. Non-chainable methods must be invoked prior to
 * chaining. In this case, Chai suggests that the user consult the docs for the
 * given assertion.
 *
 * If the \`length\` property of functions is unconfigurable, then return \`fn\`
 * without modification.
 *
 * Note that in ES6, the function's \`length\` property is configurable, so once
 * support for legacy environments is dropped, Chai's \`length\` property can
 * replace the built-in function's \`length\` property, and this length guard will
 * no longer be necessary. In the mean time, maintaining consistency across all
 * environments is the priority.
 *
 * @param {Function} fn
 * @param {String} assertionName
 * @param {Boolean} isChainable
 * @namespace Utils
 * @name addLengthGuard
 */var addLengthGuard=function addLengthGuard(fn,assertionName,isChainable){if(!fnLengthDesc.configurable)return fn;Object.defineProperty(fn,'length',{get:function(){if(isChainable){throw Error('Invalid Chai property: '+assertionName+'.length. Due'+' to a compatibility issue, "length" cannot directly follow "'+assertionName+'". Use "'+assertionName+'.lengthOf" instead.');}throw Error('Invalid Chai property: '+assertionName+'.length. See'+' docs for proper usage of "'+assertionName+'".');}});return fn;};/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */var getProperties$1=function getProperties(object){var result=Object.getOwnPropertyNames(object);function addProperty(property){if(result.indexOf(property)===-1){result.push(property);}}var proto=Object.getPrototypeOf(object);while(proto!==null){Object.getOwnPropertyNames(proto).forEach(addProperty);proto=Object.getPrototypeOf(proto);}return result;};var config$1=config$5;var flag$1=flag$5;var getProperties=getProperties$1;var isProxyEnabled=isProxyEnabled$1;/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .proxify(object)
 *
 * Return a proxy of given object that throws an error when a non-existent
 * property is read. By default, the root cause is assumed to be a misspelled
 * property, and thus an attempt is made to offer a reasonable suggestion from
 * the list of existing properties. However, if a nonChainableMethodName is
 * provided, then the root cause is instead a failure to invoke a non-chainable
 * method prior to reading the non-existent property.
 *
 * If proxies are unsupported or disabled via the user's Chai config, then
 * return object without modification.
 *
 * @param {Object} obj
 * @param {String} nonChainableMethodName
 * @namespace Utils
 * @name proxify
 */var builtins=['__flags','__methods','_obj','assert'];var proxify=function proxify(obj,nonChainableMethodName){if(!isProxyEnabled())return obj;return new Proxy(obj,{get:function proxyGetter(target,property){// This check is here because we should not throw errors on Symbol properties
// such as \`Symbol.toStringTag\`.
// The values for which an error should be thrown can be configured using
// the \`config.proxyExcludedKeys\` setting.
if(typeof property==='string'&&config$1.proxyExcludedKeys.indexOf(property)===-1&&!Reflect.has(target,property)){// Special message for invalid property access of non-chainable methods.
if(nonChainableMethodName){throw Error('Invalid Chai property: '+nonChainableMethodName+'.'+property+'. See docs for proper usage of "'+nonChainableMethodName+'".');}// If the property is reasonably close to an existing Chai property,
// suggest that property to the user. Only suggest properties with a
// distance less than 4.
var suggestion=null;var suggestionDistance=4;getProperties(target).forEach(function(prop){if(!Object.prototype.hasOwnProperty(prop)&&builtins.indexOf(prop)===-1){var dist=stringDistanceCapped(property,prop,suggestionDistance);if(dist<suggestionDistance){suggestion=prop;suggestionDistance=dist;}}});if(suggestion!==null){throw Error('Invalid Chai property: '+property+'. Did you mean "'+suggestion+'"?');}else{throw Error('Invalid Chai property: '+property);}}// Use this proxy getter as the starting point for removing implementation
// frames from the stack trace of a failed assertion. For property
// assertions, this prevents the proxy getter from showing up in the stack
// trace since it's invoked before the property getter. For method and
// chainable method assertions, this flag will end up getting changed to
// the method wrapper, which is good since this frame will no longer be in
// the stack once the method is invoked. Note that Chai builtin assertion
// properties such as \`__flags\` are skipped since this is only meant to
// capture the starting point of an assertion. This step is also skipped
// if the \`lockSsfi\` flag is set, thus indicating that this assertion is
// being called from within another assertion. In that case, the \`ssfi\`
// flag is already set to the outer assertion's starting point.
if(builtins.indexOf(property)===-1&&!flag$1(target,'lockSsfi')){flag$1(target,'ssfi',proxyGetter);}return Reflect.get(target,property);}});};/**
 * # stringDistanceCapped(strA, strB, cap)
 * Return the Levenshtein distance between two strings, but no more than cap.
 * @param {string} strA
 * @param {string} strB
 * @param {number} number
 * @return {number} min(string distance between strA and strB, cap)
 * @api private
 */function stringDistanceCapped(strA,strB,cap){if(Math.abs(strA.length-strB.length)>=cap){return cap;}var memo=[];// \`memo\` is a two-dimensional array containing distances.
// memo[i][j] is the distance between strA.slice(0, i) and
// strB.slice(0, j).
for(var i=0;i<=strA.length;i++){memo[i]=Array(strB.length+1).fill(0);memo[i][0]=i;}for(var j=0;j<strB.length;j++){memo[0][j]=j;}for(var i=1;i<=strA.length;i++){var ch=strA.charCodeAt(i-1);for(var j=1;j<=strB.length;j++){if(Math.abs(i-j)>=cap){memo[i][j]=cap;continue;}memo[i][j]=Math.min(memo[i-1][j]+1,memo[i][j-1]+1,memo[i-1][j-1]+(ch===strB.charCodeAt(j-1)?0:1));}}return memo[strA.length][strB.length];}/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var addMethod;var hasRequiredAddMethod;function requireAddMethod(){if(hasRequiredAddMethod)return addMethod;hasRequiredAddMethod=1;var addLengthGuard$1=addLengthGuard;var chai=requireChai();var flag=flag$5;var proxify$1=proxify;var transferFlags$1=transferFlags;/**
   * ### .addMethod(ctx, name, method)
   *
   * Adds a method to the prototype of an object.
   *
   *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
   *       var obj = utils.flag(this, 'object');
   *       new chai.Assertion(obj).to.be.equal(str);
   *     });
   *
   * Can also be accessed directly from \`chai.Assertion\`.
   *
   *     chai.Assertion.addMethod('foo', fn);
   *
   * Then can be used as any other assertion.
   *
   *     expect(fooStr).to.be.foo('bar');
   *
   * @param {Object} ctx object to which the method is added
   * @param {String} name of method to add
   * @param {Function} method function to be used for name
   * @namespace Utils
   * @name addMethod
   * @api public
   */addMethod=function addMethod(ctx,name,method){var methodWrapper=function(){// Setting the \`ssfi\` flag to \`methodWrapper\` causes this function to be the
// starting point for removing implementation frames from the stack trace of
// a failed assertion.
//
// However, we only want to use this function as the starting point if the
// \`lockSsfi\` flag isn't set.
//
// If the \`lockSsfi\` flag is set, then either this assertion has been
// overwritten by another assertion, or this assertion is being invoked from
// inside of another assertion. In the first case, the \`ssfi\` flag has
// already been set by the overwriting assertion. In the second case, the
// \`ssfi\` flag has already been set by the outer assertion.
if(!flag(this,'lockSsfi')){flag(this,'ssfi',methodWrapper);}var result=method.apply(this,arguments);if(result!==undefined)return result;var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;};addLengthGuard$1(methodWrapper,name,false);ctx[name]=proxify$1(methodWrapper,name);};return addMethod;}/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var overwriteProperty;var hasRequiredOverwriteProperty;function requireOverwriteProperty(){if(hasRequiredOverwriteProperty)return overwriteProperty;hasRequiredOverwriteProperty=1;var chai=requireChai();var flag=flag$5;var isProxyEnabled=isProxyEnabled$1;var transferFlags$1=transferFlags;/**
   * ### .overwriteProperty(ctx, name, fn)
   *
   * Overwrites an already existing property getter and provides
   * access to previous value. Must return function to use as getter.
   *
   *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
   *       return function () {
   *         var obj = utils.flag(this, 'object');
   *         if (obj instanceof Foo) {
   *           new chai.Assertion(obj.name).to.equal('bar');
   *         } else {
   *           _super.call(this);
   *         }
   *       }
   *     });
   *
   *
   * Can also be accessed directly from \`chai.Assertion\`.
   *
   *     chai.Assertion.overwriteProperty('foo', fn);
   *
   * Then can be used as any other assertion.
   *
   *     expect(myFoo).to.be.ok;
   *
   * @param {Object} ctx object whose property is to be overwritten
   * @param {String} name of property to overwrite
   * @param {Function} getter function that returns a getter function to be used for name
   * @namespace Utils
   * @name overwriteProperty
   * @api public
   */overwriteProperty=function overwriteProperty(ctx,name,getter){var _get=Object.getOwnPropertyDescriptor(ctx,name),_super=function(){};if(_get&&'function'===typeof _get.get)_super=_get.get;Object.defineProperty(ctx,name,{get:function overwritingPropertyGetter(){// Setting the \`ssfi\` flag to \`overwritingPropertyGetter\` causes this
// function to be the starting point for removing implementation frames
// from the stack trace of a failed assertion.
//
// However, we only want to use this function as the starting point if
// the \`lockSsfi\` flag isn't set and proxy protection is disabled.
//
// If the \`lockSsfi\` flag is set, then either this assertion has been
// overwritten by another assertion, or this assertion is being invoked
// from inside of another assertion. In the first case, the \`ssfi\` flag
// has already been set by the overwriting assertion. In the second
// case, the \`ssfi\` flag has already been set by the outer assertion.
//
// If proxy protection is enabled, then the \`ssfi\` flag has already been
// set by the proxy getter.
if(!isProxyEnabled()&&!flag(this,'lockSsfi')){flag(this,'ssfi',overwritingPropertyGetter);}// Setting the \`lockSsfi\` flag to \`true\` prevents the overwritten
// assertion from changing the \`ssfi\` flag. By this point, the \`ssfi\`
// flag is already set to the correct starting point for this assertion.
var origLockSsfi=flag(this,'lockSsfi');flag(this,'lockSsfi',true);var result=getter(_super).call(this);flag(this,'lockSsfi',origLockSsfi);if(result!==undefined){return result;}var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;},configurable:true});};return overwriteProperty;}/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var overwriteMethod;var hasRequiredOverwriteMethod;function requireOverwriteMethod(){if(hasRequiredOverwriteMethod)return overwriteMethod;hasRequiredOverwriteMethod=1;var addLengthGuard$1=addLengthGuard;var chai=requireChai();var flag=flag$5;var proxify$1=proxify;var transferFlags$1=transferFlags;/**
   * ### .overwriteMethod(ctx, name, fn)
   *
   * Overwrites an already existing method and provides
   * access to previous function. Must return function
   * to be used for name.
   *
   *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
   *       return function (str) {
   *         var obj = utils.flag(this, 'object');
   *         if (obj instanceof Foo) {
   *           new chai.Assertion(obj.value).to.equal(str);
   *         } else {
   *           _super.apply(this, arguments);
   *         }
   *       }
   *     });
   *
   * Can also be accessed directly from \`chai.Assertion\`.
   *
   *     chai.Assertion.overwriteMethod('foo', fn);
   *
   * Then can be used as any other assertion.
   *
   *     expect(myFoo).to.equal('bar');
   *
   * @param {Object} ctx object whose method is to be overwritten
   * @param {String} name of method to overwrite
   * @param {Function} method function that returns a function to be used for name
   * @namespace Utils
   * @name overwriteMethod
   * @api public
   */overwriteMethod=function overwriteMethod(ctx,name,method){var _method=ctx[name],_super=function(){throw new Error(name+' is not a function');};if(_method&&'function'===typeof _method)_super=_method;var overwritingMethodWrapper=function(){// Setting the \`ssfi\` flag to \`overwritingMethodWrapper\` causes this
// function to be the starting point for removing implementation frames from
// the stack trace of a failed assertion.
//
// However, we only want to use this function as the starting point if the
// \`lockSsfi\` flag isn't set.
//
// If the \`lockSsfi\` flag is set, then either this assertion has been
// overwritten by another assertion, or this assertion is being invoked from
// inside of another assertion. In the first case, the \`ssfi\` flag has
// already been set by the overwriting assertion. In the second case, the
// \`ssfi\` flag has already been set by the outer assertion.
if(!flag(this,'lockSsfi')){flag(this,'ssfi',overwritingMethodWrapper);}// Setting the \`lockSsfi\` flag to \`true\` prevents the overwritten assertion
// from changing the \`ssfi\` flag. By this point, the \`ssfi\` flag is already
// set to the correct starting point for this assertion.
var origLockSsfi=flag(this,'lockSsfi');flag(this,'lockSsfi',true);var result=method(_super).apply(this,arguments);flag(this,'lockSsfi',origLockSsfi);if(result!==undefined){return result;}var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;};addLengthGuard$1(overwritingMethodWrapper,name,false);ctx[name]=proxify$1(overwritingMethodWrapper,name);};return overwriteMethod;}/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var addChainableMethod;var hasRequiredAddChainableMethod;function requireAddChainableMethod(){if(hasRequiredAddChainableMethod)return addChainableMethod;hasRequiredAddChainableMethod=1;/*!
   * Module dependencies
   */var addLengthGuard$1=addLengthGuard;var chai=requireChai();var flag=flag$5;var proxify$1=proxify;var transferFlags$1=transferFlags;/*!
   * Module variables
   */ // Check whether \`Object.setPrototypeOf\` is supported
var canSetPrototype=typeof Object.setPrototypeOf==='function';// Without \`Object.setPrototypeOf\` support, this module will need to add properties to a function.
// However, some of functions' own props are not configurable and should be skipped.
var testFn=function(){};var excludeNames=Object.getOwnPropertyNames(testFn).filter(function(name){var propDesc=Object.getOwnPropertyDescriptor(testFn,name);// Note: PhantomJS 1.x includes \`callee\` as one of \`testFn\`'s own properties,
// but then returns \`undefined\` as the property descriptor for \`callee\`. As a
// workaround, we perform an otherwise unnecessary type-check for \`propDesc\`,
// and then filter it out if it's not an object as it should be.
if(typeof propDesc!=='object')return true;return!propDesc.configurable;});// Cache \`Function\` properties
var call=Function.prototype.call,apply=Function.prototype.apply;/**
   * ### .addChainableMethod(ctx, name, method, chainingBehavior)
   *
   * Adds a method to an object, such that the method can also be chained.
   *
   *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
   *       var obj = utils.flag(this, 'object');
   *       new chai.Assertion(obj).to.be.equal(str);
   *     });
   *
   * Can also be accessed directly from \`chai.Assertion\`.
   *
   *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
   *
   * The result can then be used as both a method assertion, executing both \`method\` and
   * \`chainingBehavior\`, or as a language chain, which only executes \`chainingBehavior\`.
   *
   *     expect(fooStr).to.be.foo('bar');
   *     expect(fooStr).to.be.foo.equal('foo');
   *
   * @param {Object} ctx object to which the method is added
   * @param {String} name of method to add
   * @param {Function} method function to be used for \`name\`, when called
   * @param {Function} chainingBehavior function to be called every time the property is accessed
   * @namespace Utils
   * @name addChainableMethod
   * @api public
   */addChainableMethod=function addChainableMethod(ctx,name,method,chainingBehavior){if(typeof chainingBehavior!=='function'){chainingBehavior=function(){};}var chainableBehavior={method:method,chainingBehavior:chainingBehavior};// save the methods so we can overwrite them later, if we need to.
if(!ctx.__methods){ctx.__methods={};}ctx.__methods[name]=chainableBehavior;Object.defineProperty(ctx,name,{get:function chainableMethodGetter(){chainableBehavior.chainingBehavior.call(this);var chainableMethodWrapper=function(){// Setting the \`ssfi\` flag to \`chainableMethodWrapper\` causes this
// function to be the starting point for removing implementation
// frames from the stack trace of a failed assertion.
//
// However, we only want to use this function as the starting point if
// the \`lockSsfi\` flag isn't set.
//
// If the \`lockSsfi\` flag is set, then this assertion is being
// invoked from inside of another assertion. In this case, the \`ssfi\`
// flag has already been set by the outer assertion.
//
// Note that overwriting a chainable method merely replaces the saved
// methods in \`ctx.__methods\` instead of completely replacing the
// overwritten assertion. Therefore, an overwriting assertion won't
// set the \`ssfi\` or \`lockSsfi\` flags.
if(!flag(this,'lockSsfi')){flag(this,'ssfi',chainableMethodWrapper);}var result=chainableBehavior.method.apply(this,arguments);if(result!==undefined){return result;}var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;};addLengthGuard$1(chainableMethodWrapper,name,true);// Use \`Object.setPrototypeOf\` if available
if(canSetPrototype){// Inherit all properties from the object by replacing the \`Function\` prototype
var prototype=Object.create(this);// Restore the \`call\` and \`apply\` methods from \`Function\`
prototype.call=call;prototype.apply=apply;Object.setPrototypeOf(chainableMethodWrapper,prototype);}// Otherwise, redefine all properties (slow!)
else{var asserterNames=Object.getOwnPropertyNames(ctx);asserterNames.forEach(function(asserterName){if(excludeNames.indexOf(asserterName)!==-1){return;}var pd=Object.getOwnPropertyDescriptor(ctx,asserterName);Object.defineProperty(chainableMethodWrapper,asserterName,pd);});}transferFlags$1(this,chainableMethodWrapper);return proxify$1(chainableMethodWrapper);},configurable:true});};return addChainableMethod;}/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var overwriteChainableMethod;var hasRequiredOverwriteChainableMethod;function requireOverwriteChainableMethod(){if(hasRequiredOverwriteChainableMethod)return overwriteChainableMethod;hasRequiredOverwriteChainableMethod=1;var chai=requireChai();var transferFlags$1=transferFlags;/**
   * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)
   *
   * Overwrites an already existing chainable method
   * and provides access to the previous function or
   * property.  Must return functions to be used for
   * name.
   *
   *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
   *       function (_super) {
   *       }
   *     , function (_super) {
   *       }
   *     );
   *
   * Can also be accessed directly from \`chai.Assertion\`.
   *
   *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
   *
   * Then can be used as any other assertion.
   *
   *     expect(myFoo).to.have.lengthOf(3);
   *     expect(myFoo).to.have.lengthOf.above(3);
   *
   * @param {Object} ctx object whose method / property is to be overwritten
   * @param {String} name of method / property to overwrite
   * @param {Function} method function that returns a function to be used for name
   * @param {Function} chainingBehavior function that returns a function to be used for property
   * @namespace Utils
   * @name overwriteChainableMethod
   * @api public
   */overwriteChainableMethod=function overwriteChainableMethod(ctx,name,method,chainingBehavior){var chainableBehavior=ctx.__methods[name];var _chainingBehavior=chainableBehavior.chainingBehavior;chainableBehavior.chainingBehavior=function overwritingChainableMethodGetter(){var result=chainingBehavior(_chainingBehavior).call(this);if(result!==undefined){return result;}var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;};var _method=chainableBehavior.method;chainableBehavior.method=function overwritingChainableMethodWrapper(){var result=method(_method).apply(this,arguments);if(result!==undefined){return result;}var newAssertion=new chai.Assertion();transferFlags$1(this,newAssertion);return newAssertion;};};return overwriteChainableMethod;}/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Module dependencies
 */var inspect=inspect_1;/**
 * ### .compareByInspect(mixed, mixed)
 *
 * To be used as a compareFunction with Array.prototype.sort. Compares elements
 * using inspect instead of default behavior of using toString so that Symbols
 * and objects with irregular/missing toString can still be sorted without a
 * TypeError.
 *
 * @param {Mixed} first element to compare
 * @param {Mixed} second element to compare
 * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1
 * @name compareByInspect
 * @namespace Utils
 * @api public
 */var compareByInspect=function compareByInspect(a,b){return inspect(a)<inspect(b)?-1:1;};/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .getOwnEnumerablePropertySymbols(object)
 *
 * This allows the retrieval of directly-owned enumerable property symbols of an
 * object. This function is necessary because Object.getOwnPropertySymbols
 * returns both enumerable and non-enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerablePropertySymbols
 * @api public
 */var getOwnEnumerablePropertySymbols$1=function getOwnEnumerablePropertySymbols(obj){if(typeof Object.getOwnPropertySymbols!=='function')return[];return Object.getOwnPropertySymbols(obj).filter(function(sym){return Object.getOwnPropertyDescriptor(obj,sym).enumerable;});};/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /*!
 * Module dependencies
 */var getOwnEnumerablePropertySymbols=getOwnEnumerablePropertySymbols$1;/**
 * ### .getOwnEnumerableProperties(object)
 *
 * This allows the retrieval of directly-owned enumerable property names and
 * symbols of an object. This function is necessary because Object.keys only
 * returns enumerable property names, not enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerableProperties
 * @api public
 */var getOwnEnumerableProperties=function getOwnEnumerableProperties(obj){return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));};/* !
 * Chai - checkError utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var getFunctionName=getFuncName_1;/**
 * ### .checkError
 *
 * Checks that an error conforms to a given set of criteria and/or retrieves information about it.
 *
 * @api public
 */ /**
 * ### .compatibleInstance(thrown, errorLike)
 *
 * Checks if two instances are compatible (strict equal).
 * Returns false if errorLike is not an instance of Error, because instances
 * can only be compatible if they're both error instances.
 *
 * @name compatibleInstance
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */function compatibleInstance(thrown,errorLike){return errorLike instanceof Error&&thrown===errorLike;}/**
 * ### .compatibleConstructor(thrown, errorLike)
 *
 * Checks if two constructors are compatible.
 * This function can receive either an error constructor or
 * an error instance as the \`errorLike\` argument.
 * Constructors are compatible if they're the same or if one is
 * an instance of another.
 *
 * @name compatibleConstructor
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */function compatibleConstructor(thrown,errorLike){if(errorLike instanceof Error){// If \`errorLike\` is an instance of any error we compare their constructors
return thrown.constructor===errorLike.constructor||thrown instanceof errorLike.constructor;}else if(errorLike.prototype instanceof Error||errorLike===Error){// If \`errorLike\` is a constructor that inherits from Error, we compare \`thrown\` to \`errorLike\` directly
return thrown.constructor===errorLike||thrown instanceof errorLike;}return false;}/**
 * ### .compatibleMessage(thrown, errMatcher)
 *
 * Checks if an error's message is compatible with a matcher (String or RegExp).
 * If the message contains the String or passes the RegExp test,
 * it is considered compatible.
 *
 * @name compatibleMessage
 * @param {Error} thrown error
 * @param {String|RegExp} errMatcher to look for into the message
 * @namespace Utils
 * @api public
 */function compatibleMessage(thrown,errMatcher){var comparisonString=typeof thrown==='string'?thrown:thrown.message;if(errMatcher instanceof RegExp){return errMatcher.test(comparisonString);}else if(typeof errMatcher==='string'){return comparisonString.indexOf(errMatcher)!==-1;// eslint-disable-line no-magic-numbers
}return false;}/**
 * ### .getConstructorName(errorLike)
 *
 * Gets the constructor name for an Error instance or constructor itself.
 *
 * @name getConstructorName
 * @param {Error|ErrorConstructor} errorLike
 * @namespace Utils
 * @api public
 */function getConstructorName(errorLike){var constructorName=errorLike;if(errorLike instanceof Error){constructorName=getFunctionName(errorLike.constructor);}else if(typeof errorLike==='function'){// If \`err\` is not an instance of Error it is an error constructor itself or another function.
// If we've got a common function we get its name, otherwise we may need to create a new instance
// of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.
constructorName=getFunctionName(errorLike);if(constructorName===''){var newConstructorName=getFunctionName(new errorLike());// eslint-disable-line new-cap
constructorName=newConstructorName||constructorName;}}return constructorName;}/**
 * ### .getMessage(errorLike)
 *
 * Gets the error message from an error.
 * If \`err\` is a String itself, we return it.
 * If the error has no message, we return an empty string.
 *
 * @name getMessage
 * @param {Error|String} errorLike
 * @namespace Utils
 * @api public
 */function getMessage(errorLike){var msg='';if(errorLike&&errorLike.message){msg=errorLike.message;}else if(typeof errorLike==='string'){msg=errorLike;}return msg;}var checkError={compatibleInstance:compatibleInstance,compatibleConstructor:compatibleConstructor,compatibleMessage:compatibleMessage,getMessage:getMessage,getConstructorName:getConstructorName};/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */ /**
 * ### .isNaN(value)
 *
 * Checks if the given value is NaN or not.
 *
 *     utils.isNaN(NaN); // true
 *
 * @param {Value} The value which has to be checked if it is NaN
 * @name isNaN
 * @api private
 */function isNaN$1(value){// Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number
// section's NOTE.
return value!==value;}// If ECMAScript 6's Number.isNaN is present, prefer that.
var _isNaN=Number.isNaN||isNaN$1;var type$1=typeDetectExports$1;var flag=flag$5;function isObjectType(obj){var objectType=type$1(obj);var objectTypes=['Array','Object','function'];return objectTypes.indexOf(objectType)!==-1;}/**
 * ### .getOperator(message)
 *
 * Extract the operator from error message.
 * Operator defined is based on below link
 * https://nodejs.org/api/assert.html#assert_assert.
 *
 * Returns the \`operator\` or \`undefined\` value for an Assertion.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getOperator
 * @api public
 */var getOperator=function getOperator(obj,args){var operator=flag(obj,'operator');var negate=flag(obj,'negate');var expected=args[3];var msg=negate?args[2]:args[1];if(operator){return operator;}if(typeof msg==='function')msg=msg();msg=msg||'';if(!msg){return undefined;}if(/\\shave\\s/.test(msg)){return undefined;}var isObject=isObjectType(expected);if(/\\snot\\s/.test(msg)){return isObject?'notDeepStrictEqual':'notStrictEqual';}return isObject?'deepStrictEqual':'strictEqual';};/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var hasRequiredUtils;function requireUtils(){if(hasRequiredUtils)return utils;hasRequiredUtils=1;/*!
   * Dependencies that are used for multiple exports are required here only once
   */var pathval$1=pathval;/*!
   * test utility
   */utils.test=test$1;/*!
   * type utility
   */utils.type=typeDetectExports$1;/*!
   * expectTypes utility
   */utils.expectTypes=expectTypes;/*!
   * message utility
   */utils.getMessage=getMessage$1;/*!
   * actual utility
   */utils.getActual=getActual$1;/*!
   * Inspect util
   */utils.inspect=inspect_1;/*!
   * Object Display util
   */utils.objDisplay=objDisplay$1;/*!
   * Flag utility
   */utils.flag=flag$5;/*!
   * Flag transferring utility
   */utils.transferFlags=transferFlags;/*!
   * Deep equal utility
   */utils.eql=deepEqlExports;/*!
   * Deep path info
   */utils.getPathInfo=pathval$1.getPathInfo;/*!
   * Check if a property exists
   */utils.hasProperty=pathval$1.hasProperty;/*!
   * Function name
   */utils.getName=getFuncName_1;/*!
   * add Property
   */utils.addProperty=requireAddProperty();/*!
   * add Method
   */utils.addMethod=requireAddMethod();/*!
   * overwrite Property
   */utils.overwriteProperty=requireOverwriteProperty();/*!
   * overwrite Method
   */utils.overwriteMethod=requireOverwriteMethod();/*!
   * Add a chainable method
   */utils.addChainableMethod=requireAddChainableMethod();/*!
   * Overwrite chainable method
   */utils.overwriteChainableMethod=requireOverwriteChainableMethod();/*!
   * Compare by inspect method
   */utils.compareByInspect=compareByInspect;/*!
   * Get own enumerable property symbols method
   */utils.getOwnEnumerablePropertySymbols=getOwnEnumerablePropertySymbols$1;/*!
   * Get own enumerable properties method
   */utils.getOwnEnumerableProperties=getOwnEnumerableProperties;/*!
   * Checks error against a given set of criteria
   */utils.checkError=checkError;/*!
   * Proxify util
   */utils.proxify=proxify;/*!
   * addLengthGuard util
   */utils.addLengthGuard=addLengthGuard;/*!
   * isProxyEnabled helper
   */utils.isProxyEnabled=isProxyEnabled$1;/*!
   * isNaN method
   */utils.isNaN=_isNaN;/*!
   * getOperator method
   */utils.getOperator=getOperator;return utils;}/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var config=config$5;var assertion=function(_chai,util){/*!
   * Module dependencies.
   */var AssertionError=_chai.AssertionError,flag=util.flag;/*!
   * Module export.
   */_chai.Assertion=Assertion;/*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * \`Assertion\` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - \`object\`: This flag contains the target of the assertion. For example, in
   *   the assertion \`expect(numKittens).to.equal(7);\`, the \`object\` flag will
   *   contain \`numKittens\` so that the \`equal\` assertion can reference it when
   *   needed.
   *
   * - \`message\`: This flag contains an optional custom error message to be
   *   prepended to the error message that's generated by the assertion when it
   *   fails.
   *
   * - \`ssfi\`: This flag stands for "start stack function indicator". It
   *   contains a function reference that serves as the starting point for
   *   removing frames from the stack trace of the error that's created by the
   *   assertion when it fails. The goal is to provide a cleaner stack trace to
   *   end users by removing Chai's internal functions. Note that it only works
   *   in environments that support \`Error.captureStackTrace\`, and only when
   *   \`Chai.config.includeStack\` hasn't been set to \`false\`.
   *
   * - \`lockSsfi\`: This flag controls whether or not the given \`ssfi\` flag
   *   should retain its current value, even as assertions are chained off of
   *   this object. This is usually set to \`true\` when creating a new assertion
   *   from within another assertion. It's also temporarily set to \`true\` before
   *   an overwritten assertion gets called by the overwriting assertion.
   *
   * - \`eql\`: This flag contains the deepEqual function to be used by the assertion.
   *
   * @param {Mixed} obj target of the assertion
   * @param {String} msg (optional) custom error message
   * @param {Function} ssfi (optional) starting point for removing stack frames
   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
   * @api private
   */function Assertion(obj,msg,ssfi,lockSsfi){flag(this,'ssfi',ssfi||Assertion);flag(this,'lockSsfi',lockSsfi);flag(this,'object',obj);flag(this,'message',msg);flag(this,'eql',config.deepEqual||util.eql);return util.proxify(this);}Object.defineProperty(Assertion,'includeStack',{get:function(){console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');return config.includeStack;},set:function(value){console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');config.includeStack=value;}});Object.defineProperty(Assertion,'showDiff',{get:function(){console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');return config.showDiff;},set:function(value){console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');config.showDiff=value;}});Assertion.addProperty=function(name,fn){util.addProperty(this.prototype,name,fn);};Assertion.addMethod=function(name,fn){util.addMethod(this.prototype,name,fn);};Assertion.addChainableMethod=function(name,fn,chainingBehavior){util.addChainableMethod(this.prototype,name,fn,chainingBehavior);};Assertion.overwriteProperty=function(name,fn){util.overwriteProperty(this.prototype,name,fn);};Assertion.overwriteMethod=function(name,fn){util.overwriteMethod(this.prototype,name,fn);};Assertion.overwriteChainableMethod=function(name,fn,chainingBehavior){util.overwriteChainableMethod(this.prototype,name,fn,chainingBehavior);};/**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to \`this.obj\`
   * @param {Boolean} showDiff (optional) when set to \`true\`, assert will display a diff in addition to the message if expression fails
   * @api private
   */Assertion.prototype.assert=function(expr,msg,negateMsg,expected,_actual,showDiff){var ok=util.test(this,arguments);if(false!==showDiff)showDiff=true;if(undefined===expected&&undefined===_actual)showDiff=false;if(true!==config.showDiff)showDiff=false;if(!ok){msg=util.getMessage(this,arguments);var actual=util.getActual(this,arguments);var assertionErrorObjectProperties={actual:actual,expected:expected,showDiff:showDiff};var operator=util.getOperator(this,arguments);if(operator){assertionErrorObjectProperties.operator=operator;}throw new AssertionError(msg,assertionErrorObjectProperties,config.includeStack?this.assert:flag(this,'ssfi'));}};/*!
   * ### ._obj
   *
   * Quick reference to stored \`actual\` value for plugin developers.
   *
   * @api private
   */Object.defineProperty(Assertion.prototype,'_obj',{get:function(){return flag(this,'object');},set:function(val){flag(this,'object',val);}});};/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var assertions=function(chai,_){var Assertion=chai.Assertion,AssertionError=chai.AssertionError,flag=_.flag;/**
   * ### Language Chains
   *
   * The following are provided as chainable getters to improve the readability
   * of your assertions.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   * - but
   * - does
   * - still
   * - also
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */['to','be','been','is','and','has','have','with','that','which','at','of','same','but','does','still',"also"].forEach(function(chain){Assertion.addProperty(chain);});/**
   * ### .not
   *
   * Negates all assertions that follow in the chain.
   *
   *     expect(function () {}).to.not.throw();
   *     expect({a: 1}).to.not.have.property('b');
   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);
   *
   * Just because you can negate any assertion with \`.not\` doesn't mean you
   * should. With great power comes great responsibility. It's often best to
   * assert that the one expected output was produced, rather than asserting
   * that one of countless unexpected outputs wasn't produced. See individual
   * assertions for specific guidance.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.equal(1); // Not recommended
   *
   * @name not
   * @namespace BDD
   * @api public
   */Assertion.addProperty('not',function(){flag(this,'negate',true);});/**
   * ### .deep
   *
   * Causes all \`.equal\`, \`.include\`, \`.members\`, \`.keys\`, and \`.property\`
   * assertions that follow in the chain to use deep equality instead of strict
   * (\`===\`) equality. See the \`deep-eql\` project page for info on the deep
   * equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals \`{a: 1}\`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) includes \`{a: 1}\`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes \`x: {a: 1}\`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   *     // Target array deeply (but not strictly) has member \`{a: 1}\`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   *     // Target set deeply (but not strictly) has key \`{a: 1}\`
   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);
   *
   *     // Target object deeply (but not strictly) has property \`x: {a: 1}\`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * @name deep
   * @namespace BDD
   * @api public
   */Assertion.addProperty('deep',function(){flag(this,'deep',true);});/**
   * ### .nested
   *
   * Enables dot- and bracket-notation in all \`.property\` and \`.include\`
   * assertions that follow in the chain.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If \`.\` or \`[]\` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');
   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 'x'});
   *
   * \`.nested\` cannot be combined with \`.own\`.
   *
   * @name nested
   * @namespace BDD
   * @api public
   */Assertion.addProperty('nested',function(){flag(this,'nested',true);});/**
   * ### .own
   *
   * Causes all \`.property\` and \`.include\` assertions that follow in the chain
   * to ignore inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * \`.own\` cannot be combined with \`.nested\`.
   *
   * @name own
   * @namespace BDD
   * @api public
   */Assertion.addProperty('own',function(){flag(this,'own',true);});/**
   * ### .ordered
   *
   * Causes all \`.members\` assertions that follow in the chain to require that
   * members be in the same order.
   *
   *     expect([1, 2]).to.have.ordered.members([1, 2])
   *       .but.not.have.ordered.members([2, 1]);
   *
   * When \`.include\` and \`.ordered\` are combined, the ordering begins at the
   * start of both arrays.
   *
   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])
   *       .but.not.include.ordered.members([2, 3]);
   *
   * @name ordered
   * @namespace BDD
   * @api public
   */Assertion.addProperty('ordered',function(){flag(this,'ordered',true);});/**
   * ### .any
   *
   * Causes all \`.keys\` assertions that follow in the chain to only require that
   * the target have at least one of the given keys. This is the opposite of
   * \`.all\`, which requires that the target have all of the given keys.
   *
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   * See the \`.keys\` doc for guidance on when to use \`.any\` or \`.all\`.
   *
   * @name any
   * @namespace BDD
   * @api public
   */Assertion.addProperty('any',function(){flag(this,'any',true);flag(this,'all',false);});/**
   * ### .all
   *
   * Causes all \`.keys\` assertions that follow in the chain to require that the
   * target have all of the given keys. This is the opposite of \`.any\`, which
   * only requires that the target have at least one of the given keys.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   * Note that \`.all\` is used by default when neither \`.all\` nor \`.any\` are
   * added earlier in the chain. However, it's often best to add \`.all\` anyway
   * because it improves readability.
   *
   * See the \`.keys\` doc for guidance on when to use \`.any\` or \`.all\`.
   *
   * @name all
   * @namespace BDD
   * @api public
   */Assertion.addProperty('all',function(){flag(this,'all',true);flag(this,'any',false);});/**
   * ### .a(type[, msg])
   *
   * Asserts that the target's type is equal to the given string \`type\`. Types
   * are case insensitive. See the \`type-detect\` project page for info on the
   * type detection algorithm: https://github.com/chaijs/type-detect.
   *
   *     expect('foo').to.be.a('string');
   *     expect({a: 1}).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(Promise.resolve()).to.be.a('promise');
   *     expect(new Float32Array).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   * \`.a\` supports objects that have a custom type set via \`Symbol.toStringTag\`.
   *
   *     var myObj = {
   *       [Symbol.toStringTag]: 'myCustomType'
   *     };
   *
   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');
   *
   * It's often best to use \`.a\` to check a target's type before making more
   * assertions on the same target. That way, you avoid unexpected behavior from
   * any assertion that does different things based on the target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add \`.not\` earlier in the chain to negate \`.a\`. However, it's often best to
   * assert that the target is the expected type, rather than asserting that it
   * isn't one of many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.an('array'); // Not recommended
   *
   * \`.a\` accepts an optional \`msg\` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to \`expect\`.
   *
   *     expect(1).to.be.a('string', 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.a('string');
   *
   * \`.a\` can also be used as a language chain to improve the readability of
   * your assertions.
   *
   *     expect({b: 2}).to.have.a.property('b');
   *
   * The alias \`.an\` can be used interchangeably with \`.a\`.
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function an(type,msg){if(msg)flag(this,'message',msg);type=type.toLowerCase();var obj=flag(this,'object'),article=~['a','e','i','o','u'].indexOf(type.charAt(0))?'an ':'a ';this.assert(type===_.type(obj).toLowerCase(),'expected #{this} to be '+article+type,'expected #{this} not to be '+article+type);}Assertion.addChainableMethod('an',an);Assertion.addChainableMethod('a',an);/**
   * ### .include(val[, msg])
   *
   * When the target is a string, \`.include\` asserts that the given string \`val\`
   * is a substring of the target.
   *
   *     expect('foobar').to.include('foo');
   *
   * When the target is an array, \`.include\` asserts that the given \`val\` is a
   * member of the target.
   *
   *     expect([1, 2, 3]).to.include(2);
   *
   * When the target is an object, \`.include\` asserts that the given object
   * \`val\`'s properties are a subset of the target's properties.
   *
   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
   *
   * When the target is a Set or WeakSet, \`.include\` asserts that the given \`val\` is a
   * member of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Set([1, 2])).to.include(2);
   *
   * When the target is a Map, \`.include\` asserts that the given \`val\` is one of
   * the values of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);
   *
   * Because \`.include\` does different things based on the target's type, it's
   * important to check the target's type before using \`.include\`. See the \`.a\`
   * doc for info on testing a target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *
   * By default, strict (\`===\`) equality is used to compare array members and
   * object properties. Add \`.deep\` earlier in the chain to use deep equality
   * instead (WeakSet targets are not supported). See the \`deep-eql\` project
   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) includes \`{a: 1}\`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes \`x: {a: 1}\`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   * By default, all of the target's properties are searched when working with
   * objects. This includes properties that are inherited and/or non-enumerable.
   * Add \`.own\` earlier in the chain to exclude the target's inherited
   * properties from the search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * Note that a target object is always only searched for \`val\`'s own
   * enumerable properties.
   *
   * \`.deep\` and \`.own\` can be combined.
   *
   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
   *
   * Add \`.nested\` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If \`.\` or \`[]\` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 2});
   *
   * \`.deep\` and \`.nested\` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
   *
   * \`.own\` and \`.nested\` cannot be combined.
   *
   * Add \`.not\` earlier in the chain to negate \`.include\`.
   *
   *     expect('foobar').to.not.include('taco');
   *     expect([1, 2, 3]).to.not.include(4);
   *
   * However, it's dangerous to negate \`.include\` when the target is an object.
   * The problem is that it creates uncertain expectations by asserting that the
   * target object doesn't have all of \`val\`'s key/value pairs but may or may
   * not have some of them. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target object isn't even expected to have \`val\`'s keys, it's
   * often best to assert exactly that.
   *
   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * When the target object is expected to have \`val\`'s keys, it's often best to
   * assert that each of the properties has its expected value, rather than
   * asserting that each property doesn't have one of many unexpected values.
   *
   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * \`.include\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);
   *
   * \`.include\` can also be used as a language chain, causing all \`.members\` and
   * \`.keys\` assertions that follow in the chain to require the target to be a
   * superset of the expected set, rather than an identical set. Note that
   * \`.members\` ignores duplicates in the subset when \`.include\` is added.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * Note that adding \`.any\` earlier in the chain causes the \`.keys\` assertion
   * to ignore \`.include\`.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *
   * The aliases \`.includes\`, \`.contain\`, and \`.contains\` can be used
   * interchangeably with \`.include\`.
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function SameValueZero(a,b){return _.isNaN(a)&&_.isNaN(b)||a===b;}function includeChainingBehavior(){flag(this,'contains',true);}function include(val,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),objType=_.type(obj).toLowerCase(),flagMsg=flag(this,'message'),negate=flag(this,'negate'),ssfi=flag(this,'ssfi'),isDeep=flag(this,'deep'),descriptor=isDeep?'deep ':'',isEql=isDeep?flag(this,'eql'):SameValueZero;flagMsg=flagMsg?flagMsg+': ':'';var included=false;switch(objType){case'string':included=obj.indexOf(val)!==-1;break;case'weakset':if(isDeep){throw new AssertionError(flagMsg+'unable to use .deep.include with WeakSet',undefined,ssfi);}included=obj.has(val);break;case'map':obj.forEach(function(item){included=included||isEql(item,val);});break;case'set':if(isDeep){obj.forEach(function(item){included=included||isEql(item,val);});}else{included=obj.has(val);}break;case'array':if(isDeep){included=obj.some(function(item){return isEql(item,val);});}else{included=obj.indexOf(val)!==-1;}break;default:// This block is for asserting a subset of properties in an object.
// \`_.expectTypes\` isn't used here because \`.include\` should work with
// objects with a custom \`@@toStringTag\`.
if(val!==Object(val)){throw new AssertionError(flagMsg+'the given combination of arguments ('+objType+' and '+_.type(val).toLowerCase()+')'+' is invalid for this assertion. '+'You can use an array, a map, an object, a set, a string, '+'or a weakset instead of a '+_.type(val).toLowerCase(),undefined,ssfi);}var props=Object.keys(val),firstErr=null,numErrs=0;props.forEach(function(prop){var propAssertion=new Assertion(obj);_.transferFlags(this,propAssertion,true);flag(propAssertion,'lockSsfi',true);if(!negate||props.length===1){propAssertion.property(prop,val[prop]);return;}try{propAssertion.property(prop,val[prop]);}catch(err){if(!_.checkError.compatibleConstructor(err,AssertionError)){throw err;}if(firstErr===null)firstErr=err;numErrs++;}},this);// When validating .not.include with multiple properties, we only want
// to throw an assertion error if all of the properties are included,
// in which case we throw the first property assertion error that we
// encountered.
if(negate&&props.length>1&&numErrs===props.length){throw firstErr;}return;}// Assert inclusion in collection or substring in a string.
this.assert(included,'expected #{this} to '+descriptor+'include '+_.inspect(val),'expected #{this} to not '+descriptor+'include '+_.inspect(val));}Assertion.addChainableMethod('include',include,includeChainingBehavior);Assertion.addChainableMethod('contain',include,includeChainingBehavior);Assertion.addChainableMethod('contains',include,includeChainingBehavior);Assertion.addChainableMethod('includes',include,includeChainingBehavior);/**
   * ### .ok
   *
   * Asserts that the target is a truthy value (considered \`true\` in boolean context).
   * However, it's often best to assert that the target is strictly (\`===\`) or
   * deeply equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.ok; // Not recommended
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.be.ok; // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.ok\`.
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.not.be.ok; // Not recommended
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.ok; // Not recommended
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.be.ok; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.be.ok; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(false, 'nooo why fail??').to.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */Assertion.addProperty('ok',function(){this.assert(flag(this,'object'),'expected #{this} to be truthy','expected #{this} to be falsy');});/**
   * ### .true
   *
   * Asserts that the target is strictly (\`===\`) equal to \`true\`.
   *
   *     expect(true).to.be.true;
   *
   * Add \`.not\` earlier in the chain to negate \`.true\`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to \`true\`.
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.true; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.true; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(false, 'nooo why fail??').to.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */Assertion.addProperty('true',function(){this.assert(true===flag(this,'object'),'expected #{this} to be true','expected #{this} to be false',flag(this,'negate')?false:true);});/**
   * ### .false
   *
   * Asserts that the target is strictly (\`===\`) equal to \`false\`.
   *
   *     expect(false).to.be.false;
   *
   * Add \`.not\` earlier in the chain to negate \`.false\`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to \`false\`.
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.not.be.false; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.false; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(true, 'nooo why fail??').to.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */Assertion.addProperty('false',function(){this.assert(false===flag(this,'object'),'expected #{this} to be false','expected #{this} to be true',flag(this,'negate')?true:false);});/**
   * ### .null
   *
   * Asserts that the target is strictly (\`===\`) equal to \`null\`.
   *
   *     expect(null).to.be.null;
   *
   * Add \`.not\` earlier in the chain to negate \`.null\`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to \`null\`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.null; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(42, 'nooo why fail??').to.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */Assertion.addProperty('null',function(){this.assert(null===flag(this,'object'),'expected #{this} to be null','expected #{this} not to be null');});/**
   * ### .undefined
   *
   * Asserts that the target is strictly (\`===\`) equal to \`undefined\`.
   *
   *     expect(undefined).to.be.undefined;
   *
   * Add \`.not\` earlier in the chain to negate \`.undefined\`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to \`undefined\`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.undefined; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(42, 'nooo why fail??').to.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */Assertion.addProperty('undefined',function(){this.assert(undefined===flag(this,'object'),'expected #{this} to be undefined','expected #{this} not to be undefined');});/**
   * ### .NaN
   *
   * Asserts that the target is exactly \`NaN\`.
   *
   *     expect(NaN).to.be.NaN;
   *
   * Add \`.not\` earlier in the chain to negate \`.NaN\`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to \`NaN\`.
   *
   *     expect('foo').to.equal('foo'); // Recommended
   *     expect('foo').to.not.be.NaN; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(42, 'nooo why fail??').to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */Assertion.addProperty('NaN',function(){this.assert(_.isNaN(flag(this,'object')),'expected #{this} to be NaN','expected #{this} not to be NaN');});/**
   * ### .exist
   *
   * Asserts that the target is not strictly (\`===\`) equal to either \`null\` or
   * \`undefined\`. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.exist; // Not recommended
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.exist; // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.exist\`.
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.exist; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.exist; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(null, 'nooo why fail??').to.exist;
   *
   * The alias \`.exists\` can be used interchangeably with \`.exist\`.
   *
   * @name exist
   * @alias exists
   * @namespace BDD
   * @api public
   */function assertExist(){var val=flag(this,'object');this.assert(val!==null&&val!==undefined,'expected #{this} to exist','expected #{this} to not exist');}Assertion.addProperty('exist',assertExist);Assertion.addProperty('exists',assertExist);/**
   * ### .empty
   *
   * When the target is a string or array, \`.empty\` asserts that the target's
   * \`length\` property is strictly (\`===\`) equal to \`0\`.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *
   * When the target is a map or set, \`.empty\` asserts that the target's \`size\`
   * property is strictly equal to \`0\`.
   *
   *     expect(new Set()).to.be.empty;
   *     expect(new Map()).to.be.empty;
   *
   * When the target is a non-function object, \`.empty\` asserts that the target
   * doesn't have any own enumerable properties. Properties with Symbol-based
   * keys are excluded from the count.
   *
   *     expect({}).to.be.empty;
   *
   * Because \`.empty\` does different things based on the target's type, it's
   * important to check the target's type before using \`.empty\`. See the \`.a\`
   * doc for info on testing a target's type.
   *
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add \`.not\` earlier in the chain to negate \`.empty\`. However, it's often
   * best to assert that the target contains its expected number of values,
   * rather than asserting that it's not empty.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended
   *
   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended
   *
   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
   *     expect({a: 1}).to.not.be.empty; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */Assertion.addProperty('empty',function(){var val=flag(this,'object'),ssfi=flag(this,'ssfi'),flagMsg=flag(this,'message'),itemsCount;flagMsg=flagMsg?flagMsg+': ':'';switch(_.type(val).toLowerCase()){case'array':case'string':itemsCount=val.length;break;case'map':case'set':itemsCount=val.size;break;case'weakmap':case'weakset':throw new AssertionError(flagMsg+'.empty was passed a weak collection',undefined,ssfi);case'function':var msg=flagMsg+'.empty was passed a function '+_.getName(val);throw new AssertionError(msg.trim(),undefined,ssfi);default:if(val!==Object(val)){throw new AssertionError(flagMsg+'.empty was passed non-string primitive '+_.inspect(val),undefined,ssfi);}itemsCount=Object.keys(val).length;}this.assert(0===itemsCount,'expected #{this} to be empty','expected #{this} not to be empty');});/**
   * ### .arguments
   *
   * Asserts that the target is an \`arguments\` object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   *     test();
   *
   * Add \`.not\` earlier in the chain to negate \`.arguments\`. However, it's often
   * best to assert which type the target is expected to be, rather than
   * asserting that it’s not an \`arguments\` object.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.arguments; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect({}, 'nooo why fail??').to.be.arguments;
   *
   * The alias \`.Arguments\` can be used interchangeably with \`.arguments\`.
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */function checkArguments(){var obj=flag(this,'object'),type=_.type(obj);this.assert('Arguments'===type,'expected #{this} to be arguments but got '+type,'expected #{this} to not be arguments');}Assertion.addProperty('arguments',checkArguments);Assertion.addProperty('Arguments',checkArguments);/**
   * ### .equal(val[, msg])
   *
   * Asserts that the target is strictly (\`===\`) equal to the given \`val\`.
   *
   *     expect(1).to.equal(1);
   *     expect('foo').to.equal('foo');
   *
   * Add \`.deep\` earlier in the chain to use deep equality instead. See the
   * \`deep-eql\` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals \`{a: 1}\`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) equals \`[1, 2]\`
   *     expect([1, 2]).to.deep.equal([1, 2]);
   *     expect([1, 2]).to.not.equal([1, 2]);
   *
   * Add \`.not\` earlier in the chain to negate \`.equal\`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to one of countless unexpected values.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.equal(2); // Not recommended
   *
   * \`.equal\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect(1).to.equal(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.equal(2);
   *
   * The aliases \`.equals\` and \`eq\` can be used interchangeably with \`.equal\`.
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertEqual(val,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object');if(flag(this,'deep')){var prevLockSsfi=flag(this,'lockSsfi');flag(this,'lockSsfi',true);this.eql(val);flag(this,'lockSsfi',prevLockSsfi);}else{this.assert(val===obj,'expected #{this} to equal #{exp}','expected #{this} to not equal #{exp}',val,this._obj,true);}}Assertion.addMethod('equal',assertEqual);Assertion.addMethod('equals',assertEqual);Assertion.addMethod('eq',assertEqual);/**
   * ### .eql(obj[, msg])
   *
   * Asserts that the target is deeply equal to the given \`obj\`. See the
   * \`deep-eql\` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object is deeply (but not strictly) equal to {a: 1}
   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});
   *
   *     // Target array is deeply (but not strictly) equal to [1, 2]
   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
   *
   * Add \`.not\` earlier in the chain to negate \`.eql\`. However, it's often best
   * to assert that the target is deeply equal to its expected value, rather
   * than not deeply equal to one of countless unexpected values.
   *
   *     expect({a: 1}).to.eql({a: 1}); // Recommended
   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended
   *
   * \`.eql\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
   *
   * The alias \`.eqls\` can be used interchangeably with \`.eql\`.
   *
   * The \`.deep.equal\` assertion is almost identical to \`.eql\` but with one
   * difference: \`.deep.equal\` causes deep equality comparisons to also be used
   * for any other assertions that follow in the chain.
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} obj
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertEql(obj,msg){if(msg)flag(this,'message',msg);var eql=flag(this,'eql');this.assert(eql(obj,flag(this,'object')),'expected #{this} to deeply equal #{exp}','expected #{this} to not deeply equal #{exp}',obj,this._obj,true);}Assertion.addMethod('eql',assertEql);Assertion.addMethod('eqls',assertEql);/**
   * ### .above(n[, msg])
   *
   * Asserts that the target is a number or a date greater than the given number or date \`n\` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.above(1); // Not recommended
   *
   * Add \`.lengthOf\` earlier in the chain to assert that the target's \`length\`
   * or \`size\` is greater than the given number \`n\`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.above(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.above\`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(1).to.not.be.above(2); // Not recommended
   *
   * \`.above\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect(1).to.be.above(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.above(2);
   *
   * The aliases \`.gt\` and \`.greaterThan\` can be used interchangeably with
   * \`.above\`.
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertAbove(n,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),doLength=flag(this,'doLength'),flagMsg=flag(this,'message'),msgPrefix=flagMsg?flagMsg+': ':'',ssfi=flag(this,'ssfi'),objType=_.type(obj).toLowerCase(),nType=_.type(n).toLowerCase(),errorMessage,shouldThrow=true;if(doLength&&objType!=='map'&&objType!=='set'){new Assertion(obj,flagMsg,ssfi,true).to.have.property('length');}if(!doLength&&objType==='date'&&nType!=='date'){errorMessage=msgPrefix+'the argument to above must be a date';}else if(nType!=='number'&&(doLength||objType==='number')){errorMessage=msgPrefix+'the argument to above must be a number';}else if(!doLength&&objType!=='date'&&objType!=='number'){var printObj=objType==='string'?"'"+obj+"'":obj;errorMessage=msgPrefix+'expected '+printObj+' to be a number or a date';}else{shouldThrow=false;}if(shouldThrow){throw new AssertionError(errorMessage,undefined,ssfi);}if(doLength){var descriptor='length',itemsCount;if(objType==='map'||objType==='set'){descriptor='size';itemsCount=obj.size;}else{itemsCount=obj.length;}this.assert(itemsCount>n,'expected #{this} to have a '+descriptor+' above #{exp} but got #{act}','expected #{this} to not have a '+descriptor+' above #{exp}',n,itemsCount);}else{this.assert(obj>n,'expected #{this} to be above #{exp}','expected #{this} to be at most #{exp}',n);}}Assertion.addMethod('above',assertAbove);Assertion.addMethod('gt',assertAbove);Assertion.addMethod('greaterThan',assertAbove);/**
   * ### .least(n[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date \`n\` respectively. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.at.least(1); // Not recommended
   *     expect(2).to.be.at.least(2); // Not recommended
   *
   * Add \`.lengthOf\` earlier in the chain to assert that the target's \`length\`
   * or \`size\` is greater than or equal to the given number \`n\`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.least\`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.at.least(2); // Not recommended
   *
   * \`.least\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect(1).to.be.at.least(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.at.least(2);
   *
   * The aliases \`.gte\` and \`.greaterThanOrEqual\` can be used interchangeably with
   * \`.least\`.
   *
   * @name least
   * @alias gte
   * @alias greaterThanOrEqual
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertLeast(n,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),doLength=flag(this,'doLength'),flagMsg=flag(this,'message'),msgPrefix=flagMsg?flagMsg+': ':'',ssfi=flag(this,'ssfi'),objType=_.type(obj).toLowerCase(),nType=_.type(n).toLowerCase(),errorMessage,shouldThrow=true;if(doLength&&objType!=='map'&&objType!=='set'){new Assertion(obj,flagMsg,ssfi,true).to.have.property('length');}if(!doLength&&objType==='date'&&nType!=='date'){errorMessage=msgPrefix+'the argument to least must be a date';}else if(nType!=='number'&&(doLength||objType==='number')){errorMessage=msgPrefix+'the argument to least must be a number';}else if(!doLength&&objType!=='date'&&objType!=='number'){var printObj=objType==='string'?"'"+obj+"'":obj;errorMessage=msgPrefix+'expected '+printObj+' to be a number or a date';}else{shouldThrow=false;}if(shouldThrow){throw new AssertionError(errorMessage,undefined,ssfi);}if(doLength){var descriptor='length',itemsCount;if(objType==='map'||objType==='set'){descriptor='size';itemsCount=obj.size;}else{itemsCount=obj.length;}this.assert(itemsCount>=n,'expected #{this} to have a '+descriptor+' at least #{exp} but got #{act}','expected #{this} to have a '+descriptor+' below #{exp}',n,itemsCount);}else{this.assert(obj>=n,'expected #{this} to be at least #{exp}','expected #{this} to be below #{exp}',n);}}Assertion.addMethod('least',assertLeast);Assertion.addMethod('gte',assertLeast);Assertion.addMethod('greaterThanOrEqual',assertLeast);/**
   * ### .below(n[, msg])
   *
   * Asserts that the target is a number or a date less than the given number or date \`n\` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.below(2); // Not recommended
   *
   * Add \`.lengthOf\` earlier in the chain to assert that the target's \`length\`
   * or \`size\` is less than the given number \`n\`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.below(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.length(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.below\`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.below(1); // Not recommended
   *
   * \`.below\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect(2).to.be.below(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.below(1);
   *
   * The aliases \`.lt\` and \`.lessThan\` can be used interchangeably with
   * \`.below\`.
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertBelow(n,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),doLength=flag(this,'doLength'),flagMsg=flag(this,'message'),msgPrefix=flagMsg?flagMsg+': ':'',ssfi=flag(this,'ssfi'),objType=_.type(obj).toLowerCase(),nType=_.type(n).toLowerCase(),errorMessage,shouldThrow=true;if(doLength&&objType!=='map'&&objType!=='set'){new Assertion(obj,flagMsg,ssfi,true).to.have.property('length');}if(!doLength&&objType==='date'&&nType!=='date'){errorMessage=msgPrefix+'the argument to below must be a date';}else if(nType!=='number'&&(doLength||objType==='number')){errorMessage=msgPrefix+'the argument to below must be a number';}else if(!doLength&&objType!=='date'&&objType!=='number'){var printObj=objType==='string'?"'"+obj+"'":obj;errorMessage=msgPrefix+'expected '+printObj+' to be a number or a date';}else{shouldThrow=false;}if(shouldThrow){throw new AssertionError(errorMessage,undefined,ssfi);}if(doLength){var descriptor='length',itemsCount;if(objType==='map'||objType==='set'){descriptor='size';itemsCount=obj.size;}else{itemsCount=obj.length;}this.assert(itemsCount<n,'expected #{this} to have a '+descriptor+' below #{exp} but got #{act}','expected #{this} to not have a '+descriptor+' below #{exp}',n,itemsCount);}else{this.assert(obj<n,'expected #{this} to be below #{exp}','expected #{this} to be at least #{exp}',n);}}Assertion.addMethod('below',assertBelow);Assertion.addMethod('lt',assertBelow);Assertion.addMethod('lessThan',assertBelow);/**
   * ### .most(n[, msg])
   *
   * Asserts that the target is a number or a date less than or equal to the given number
   * or date \`n\` respectively. However, it's often best to assert that the target is equal to its
   * expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.at.most(2); // Not recommended
   *     expect(1).to.be.at.most(1); // Not recommended
   *
   * Add \`.lengthOf\` earlier in the chain to assert that the target's \`length\`
   * or \`size\` is less than or equal to the given number \`n\`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.most\`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.at.most(1); // Not recommended
   *
   * \`.most\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect(2).to.be.at.most(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.at.most(1);
   *
   * The aliases \`.lte\` and \`.lessThanOrEqual\` can be used interchangeably with
   * \`.most\`.
   *
   * @name most
   * @alias lte
   * @alias lessThanOrEqual
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertMost(n,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),doLength=flag(this,'doLength'),flagMsg=flag(this,'message'),msgPrefix=flagMsg?flagMsg+': ':'',ssfi=flag(this,'ssfi'),objType=_.type(obj).toLowerCase(),nType=_.type(n).toLowerCase(),errorMessage,shouldThrow=true;if(doLength&&objType!=='map'&&objType!=='set'){new Assertion(obj,flagMsg,ssfi,true).to.have.property('length');}if(!doLength&&objType==='date'&&nType!=='date'){errorMessage=msgPrefix+'the argument to most must be a date';}else if(nType!=='number'&&(doLength||objType==='number')){errorMessage=msgPrefix+'the argument to most must be a number';}else if(!doLength&&objType!=='date'&&objType!=='number'){var printObj=objType==='string'?"'"+obj+"'":obj;errorMessage=msgPrefix+'expected '+printObj+' to be a number or a date';}else{shouldThrow=false;}if(shouldThrow){throw new AssertionError(errorMessage,undefined,ssfi);}if(doLength){var descriptor='length',itemsCount;if(objType==='map'||objType==='set'){descriptor='size';itemsCount=obj.size;}else{itemsCount=obj.length;}this.assert(itemsCount<=n,'expected #{this} to have a '+descriptor+' at most #{exp} but got #{act}','expected #{this} to have a '+descriptor+' above #{exp}',n,itemsCount);}else{this.assert(obj<=n,'expected #{this} to be at most #{exp}','expected #{this} to be above #{exp}',n);}}Assertion.addMethod('most',assertMost);Assertion.addMethod('lte',assertMost);Assertion.addMethod('lessThanOrEqual',assertMost);/**
   * ### .within(start, finish[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date \`start\`, and less than or equal to the given number or date \`finish\` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.within(1, 3); // Not recommended
   *     expect(2).to.be.within(2, 3); // Not recommended
   *     expect(2).to.be.within(1, 2); // Not recommended
   *
   * Add \`.lengthOf\` earlier in the chain to assert that the target's \`length\`
   * or \`size\` is greater than or equal to the given number \`start\`, and less
   * than or equal to the given number \`finish\`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.within\`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.within(2, 4); // Not recommended
   *
   * \`.within\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect(4).to.be.within(1, 3, 'nooo why fail??');
   *     expect(4, 'nooo why fail??').to.be.within(1, 3);
   *
   * @name within
   * @param {Number} start lower bound inclusive
   * @param {Number} finish upper bound inclusive
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */Assertion.addMethod('within',function(start,finish,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),doLength=flag(this,'doLength'),flagMsg=flag(this,'message'),msgPrefix=flagMsg?flagMsg+': ':'',ssfi=flag(this,'ssfi'),objType=_.type(obj).toLowerCase(),startType=_.type(start).toLowerCase(),finishType=_.type(finish).toLowerCase(),errorMessage,shouldThrow=true,range=startType==='date'&&finishType==='date'?start.toISOString()+'..'+finish.toISOString():start+'..'+finish;if(doLength&&objType!=='map'&&objType!=='set'){new Assertion(obj,flagMsg,ssfi,true).to.have.property('length');}if(!doLength&&objType==='date'&&(startType!=='date'||finishType!=='date')){errorMessage=msgPrefix+'the arguments to within must be dates';}else if((startType!=='number'||finishType!=='number')&&(doLength||objType==='number')){errorMessage=msgPrefix+'the arguments to within must be numbers';}else if(!doLength&&objType!=='date'&&objType!=='number'){var printObj=objType==='string'?"'"+obj+"'":obj;errorMessage=msgPrefix+'expected '+printObj+' to be a number or a date';}else{shouldThrow=false;}if(shouldThrow){throw new AssertionError(errorMessage,undefined,ssfi);}if(doLength){var descriptor='length',itemsCount;if(objType==='map'||objType==='set'){descriptor='size';itemsCount=obj.size;}else{itemsCount=obj.length;}this.assert(itemsCount>=start&&itemsCount<=finish,'expected #{this} to have a '+descriptor+' within '+range,'expected #{this} to not have a '+descriptor+' within '+range);}else{this.assert(obj>=start&&obj<=finish,'expected #{this} to be within '+range,'expected #{this} to not be within '+range);}});/**
   * ### .instanceof(constructor[, msg])
   *
   * Asserts that the target is an instance of the given \`constructor\`.
   *
   *     function Cat () { }
   *
   *     expect(new Cat()).to.be.an.instanceof(Cat);
   *     expect([1, 2]).to.be.an.instanceof(Array);
   *
   * Add \`.not\` earlier in the chain to negate \`.instanceof\`.
   *
   *     expect({a: 1}).to.not.be.an.instanceof(Array);
   *
   * \`.instanceof\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
   *
   * Due to limitations in ES5, \`.instanceof\` may not always work as expected
   * when using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing built-in object such as
   * \`Array\`, \`Error\`, and \`Map\`. See your transpiler's docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * The alias \`.instanceOf\` can be used interchangeably with \`.instanceof\`.
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} msg _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */function assertInstanceOf(constructor,msg){if(msg)flag(this,'message',msg);var target=flag(this,'object');var ssfi=flag(this,'ssfi');var flagMsg=flag(this,'message');try{var isInstanceOf=target instanceof constructor;}catch(err){if(err instanceof TypeError){flagMsg=flagMsg?flagMsg+': ':'';throw new AssertionError(flagMsg+'The instanceof assertion needs a constructor but '+_.type(constructor)+' was given.',undefined,ssfi);}throw err;}var name=_.getName(constructor);if(name===null){name='an unnamed constructor';}this.assert(isInstanceOf,'expected #{this} to be an instance of '+name,'expected #{this} to not be an instance of '+name);}Assertion.addMethod('instanceof',assertInstanceOf);Assertion.addMethod('instanceOf',assertInstanceOf);/**
   * ### .property(name[, val[, msg]])
   *
   * Asserts that the target has a property with the given key \`name\`.
   *
   *     expect({a: 1}).to.have.property('a');
   *
   * When \`val\` is provided, \`.property\` also asserts that the property's value
   * is equal to the given \`val\`.
   *
   *     expect({a: 1}).to.have.property('a', 1);
   *
   * By default, strict (\`===\`) equality is used. Add \`.deep\` earlier in the
   * chain to use deep equality instead. See the \`deep-eql\` project page for
   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) has property \`x: {a: 1}\`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * The target's enumerable and non-enumerable properties are always included
   * in the search. By default, both own and inherited properties are included.
   * Add \`.own\` earlier in the chain to exclude inherited properties from the
   * search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.own.property('a', 1);
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   * \`.deep\` and \`.own\` can be combined.
   *
   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
   *
   * Add \`.nested\` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
   *
   * If \`.\` or \`[]\` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');
   *
   * \`.deep\` and \`.nested\` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}})
   *       .to.have.deep.nested.property('a.b[0]', {c: 3});
   *
   * \`.own\` and \`.nested\` cannot be combined.
   *
   * Add \`.not\` earlier in the chain to negate \`.property\`.
   *
   *     expect({a: 1}).to.not.have.property('b');
   *
   * However, it's dangerous to negate \`.property\` when providing \`val\`. The
   * problem is that it creates uncertain expectations by asserting that the
   * target either doesn't have a property with the given key \`name\`, or that it
   * does have a property with the given key \`name\` but its value isn't equal to
   * the given \`val\`. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property with the given key
   * \`name\`, it's often best to assert exactly that.
   *
   *     expect({b: 2}).to.not.have.property('a'); // Recommended
   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended
   *
   * When the target is expected to have a property with the given key \`name\`,
   * it's often best to assert that the property has its expected value, rather
   * than asserting that it doesn't have one of many unexpected values.
   *
   *     expect({a: 3}).to.have.property('a', 3); // Recommended
   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended
   *
   * \`.property\` changes the target of any assertions that follow in the chain
   * to be the value of the property from the original target object.
   *
   *     expect({a: 1}).to.have.property('a').that.is.a('number');
   *
   * \`.property\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`. When not providing \`val\`, only use the
   * second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');
   *
   *     // Not recommended
   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing \`val\`. Instead,
   * it's asserting that the target object has a \`b\` property that's equal to
   * \`undefined\`.
   *
   * The assertions \`.ownProperty\` and \`.haveOwnProperty\` can be used
   * interchangeably with \`.own.property\`.
   *
   * @name property
   * @param {String} name
   * @param {Mixed} val (optional)
   * @param {String} msg _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */function assertProperty(name,val,msg){if(msg)flag(this,'message',msg);var isNested=flag(this,'nested'),isOwn=flag(this,'own'),flagMsg=flag(this,'message'),obj=flag(this,'object'),ssfi=flag(this,'ssfi'),nameType=typeof name;flagMsg=flagMsg?flagMsg+': ':'';if(isNested){if(nameType!=='string'){throw new AssertionError(flagMsg+'the argument to property must be a string when using nested syntax',undefined,ssfi);}}else{if(nameType!=='string'&&nameType!=='number'&&nameType!=='symbol'){throw new AssertionError(flagMsg+'the argument to property must be a string, number, or symbol',undefined,ssfi);}}if(isNested&&isOwn){throw new AssertionError(flagMsg+'The "nested" and "own" flags cannot be combined.',undefined,ssfi);}if(obj===null||obj===undefined){throw new AssertionError(flagMsg+'Target cannot be null or undefined.',undefined,ssfi);}var isDeep=flag(this,'deep'),negate=flag(this,'negate'),pathInfo=isNested?_.getPathInfo(obj,name):null,value=isNested?pathInfo.value:obj[name],isEql=isDeep?flag(this,'eql'):(val1,val2)=>val1===val2;var descriptor='';if(isDeep)descriptor+='deep ';if(isOwn)descriptor+='own ';if(isNested)descriptor+='nested ';descriptor+='property ';var hasProperty;if(isOwn)hasProperty=Object.prototype.hasOwnProperty.call(obj,name);else if(isNested)hasProperty=pathInfo.exists;else hasProperty=_.hasProperty(obj,name);// When performing a negated assertion for both name and val, merely having
// a property with the given name isn't enough to cause the assertion to
// fail. It must both have a property with the given name, and the value of
// that property must equal the given val. Therefore, skip this assertion in
// favor of the next.
if(!negate||arguments.length===1){this.assert(hasProperty,'expected #{this} to have '+descriptor+_.inspect(name),'expected #{this} to not have '+descriptor+_.inspect(name));}if(arguments.length>1){this.assert(hasProperty&&isEql(val,value),'expected #{this} to have '+descriptor+_.inspect(name)+' of #{exp}, but got #{act}','expected #{this} to not have '+descriptor+_.inspect(name)+' of #{act}',val,value);}flag(this,'object',value);}Assertion.addMethod('property',assertProperty);function assertOwnProperty(name,value,msg){flag(this,'own',true);assertProperty.apply(this,arguments);}Assertion.addMethod('ownProperty',assertOwnProperty);Assertion.addMethod('haveOwnProperty',assertOwnProperty);/**
   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])
   *
   * Asserts that the target has its own property descriptor with the given key
   * \`name\`. Enumerable and non-enumerable properties are included in the
   * search.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');
   *
   * When \`descriptor\` is provided, \`.ownPropertyDescriptor\` also asserts that
   * the property's descriptor is deeply equal to the given \`descriptor\`. See
   * the \`deep-eql\` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * Add \`.not\` earlier in the chain to negate \`.ownPropertyDescriptor\`.
   *
   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
   *
   * However, it's dangerous to negate \`.ownPropertyDescriptor\` when providing
   * a \`descriptor\`. The problem is that it creates uncertain expectations by
   * asserting that the target either doesn't have a property descriptor with
   * the given key \`name\`, or that it does have a property descriptor with the
   * given key \`name\` but it’s not deeply equal to the given \`descriptor\`. It's
   * often best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property descriptor with the given
   * key \`name\`, it's often best to assert exactly that.
   *
   *     // Recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');
   *
   *     // Not recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * When the target is expected to have a property descriptor with the given
   * key \`name\`, it's often best to assert that the property has its expected
   * descriptor, rather than asserting that it doesn't have one of many
   * unexpected descriptors.
   *
   *     // Recommended
   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 3,
   *     });
   *
   *     // Not recommended
   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * \`.ownPropertyDescriptor\` changes the target of any assertions that follow
   * in the chain to be the value of the property descriptor from the original
   * target object.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')
   *       .that.has.property('enumerable', true);
   *
   * \`.ownPropertyDescriptor\` accepts an optional \`msg\` argument which is a
   * custom error message to show when the assertion fails. The message can also
   * be given as the second argument to \`expect\`. When not providing
   * \`descriptor\`, only use the second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     }, 'nooo why fail??');
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     });
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');
   *
   *     // Not recommended
   *     expect({a: 1})
   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing \`descriptor\`.
   * Instead, it's asserting that the target object has a \`b\` property
   * descriptor that's deeply equal to \`undefined\`.
   *
   * The alias \`.haveOwnPropertyDescriptor\` can be used interchangeably with
   * \`.ownPropertyDescriptor\`.
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertOwnPropertyDescriptor(name,descriptor,msg){if(typeof descriptor==='string'){msg=descriptor;descriptor=null;}if(msg)flag(this,'message',msg);var obj=flag(this,'object');var actualDescriptor=Object.getOwnPropertyDescriptor(Object(obj),name);var eql=flag(this,'eql');if(actualDescriptor&&descriptor){this.assert(eql(descriptor,actualDescriptor),'expected the own property descriptor for '+_.inspect(name)+' on #{this} to match '+_.inspect(descriptor)+', got '+_.inspect(actualDescriptor),'expected the own property descriptor for '+_.inspect(name)+' on #{this} to not match '+_.inspect(descriptor),descriptor,actualDescriptor,true);}else{this.assert(actualDescriptor,'expected #{this} to have an own property descriptor for '+_.inspect(name),'expected #{this} to not have an own property descriptor for '+_.inspect(name));}flag(this,'object',actualDescriptor);}Assertion.addMethod('ownPropertyDescriptor',assertOwnPropertyDescriptor);Assertion.addMethod('haveOwnPropertyDescriptor',assertOwnPropertyDescriptor);/**
   * ### .lengthOf(n[, msg])
   *
   * Asserts that the target's \`length\` or \`size\` is equal to the given number
   * \`n\`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *     expect('foo').to.have.lengthOf(3);
   *     expect(new Set([1, 2, 3])).to.have.lengthOf(3);
   *     expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);
   *
   * Add \`.not\` earlier in the chain to negate \`.lengthOf\`. However, it's often
   * best to assert that the target's \`length\` property is equal to its expected
   * value, rather than not equal to one of many unexpected values.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.not.have.lengthOf(4); // Not recommended
   *
   * \`.lengthOf\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
   *
   * \`.lengthOf\` can also be used as a language chain, causing all \`.above\`,
   * \`.below\`, \`.least\`, \`.most\`, and \`.within\` assertions that follow in the
   * chain to use the target's \`length\` property as the target. However, it's
   * often best to assert that the target's \`length\` property is equal to its
   * expected length, rather than asserting that its \`length\` property falls
   * within some range of values.
   *
   *     // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *
   *     // Not recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2);
   *     expect([1, 2, 3]).to.have.lengthOf.below(4);
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);
   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);
   *
   * Due to a compatibility issue, the alias \`.length\` can't be chained directly
   * off of an uninvoked method such as \`.a\`. Therefore, \`.length\` can't be used
   * interchangeably with \`.lengthOf\` in every situation. It's recommended to
   * always use \`.lengthOf\` instead of \`.length\`.
   *
   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
   *
   * @name lengthOf
   * @alias length
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertLengthChain(){flag(this,'doLength',true);}function assertLength(n,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),objType=_.type(obj).toLowerCase(),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi'),descriptor='length',itemsCount;switch(objType){case'map':case'set':descriptor='size';itemsCount=obj.size;break;default:new Assertion(obj,flagMsg,ssfi,true).to.have.property('length');itemsCount=obj.length;}this.assert(itemsCount==n,'expected #{this} to have a '+descriptor+' of #{exp} but got #{act}','expected #{this} to not have a '+descriptor+' of #{act}',n,itemsCount);}Assertion.addChainableMethod('length',assertLength,assertLengthChain);Assertion.addChainableMethod('lengthOf',assertLength,assertLengthChain);/**
   * ### .match(re[, msg])
   *
   * Asserts that the target matches the given regular expression \`re\`.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * Add \`.not\` earlier in the chain to negate \`.match\`.
   *
   *     expect('foobar').to.not.match(/taco/);
   *
   * \`.match\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect('foobar').to.match(/taco/, 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.match(/taco/);
   *
   * The alias \`.matches\` can be used interchangeably with \`.match\`.
   *
   * @name match
   * @alias matches
   * @param {RegExp} re
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertMatch(re,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object');this.assert(re.exec(obj),'expected #{this} to match '+re,'expected #{this} not to match '+re);}Assertion.addMethod('match',assertMatch);Assertion.addMethod('matches',assertMatch);/**
   * ### .string(str[, msg])
   *
   * Asserts that the target string contains the given substring \`str\`.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * Add \`.not\` earlier in the chain to negate \`.string\`.
   *
   *     expect('foobar').to.not.have.string('taco');
   *
   * \`.string\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect('foobar').to.have.string('taco', 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.have.string('taco');
   *
   * @name string
   * @param {String} str
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */Assertion.addMethod('string',function(str,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi');new Assertion(obj,flagMsg,ssfi,true).is.a('string');this.assert(~obj.indexOf(str),'expected #{this} to contain '+_.inspect(str),'expected #{this} to not contain '+_.inspect(str));});/**
   * ### .keys(key1[, key2[, ...]])
   *
   * Asserts that the target object, array, map, or set has the given keys. Only
   * the target's own inherited properties are included in the search.
   *
   * When the target is an object or array, keys can be provided as one or more
   * string arguments, a single array argument, or a single object argument. In
   * the latter case, only the keys in the given object matter; the values are
   * ignored.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *     expect(['x', 'y']).to.have.all.keys(0, 1);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
   *     expect(['x', 'y']).to.have.all.keys([0, 1]);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
   *
   * When the target is a map or set, each key must be provided as a separate
   * argument.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
   *
   * Because \`.keys\` does different things based on the target's type, it's
   * important to check the target's type before using \`.keys\`. See the \`.a\` doc
   * for info on testing a target's type.
   *
   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
   *
   * By default, strict (\`===\`) equality is used to compare keys of maps and
   * sets. Add \`.deep\` earlier in the chain to use deep equality instead. See
   * the \`deep-eql\` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target set deeply (but not strictly) has key \`{a: 1}\`
   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
   *
   * By default, the target must have all of the given keys and no more. Add
   * \`.any\` earlier in the chain to only require that the target have at least
   * one of the given keys. Also, add \`.not\` earlier in the chain to negate
   * \`.keys\`. It's often best to add \`.any\` when negating \`.keys\`, and to use
   * \`.all\` when asserting \`.keys\` without negation.
   *
   * When negating \`.keys\`, \`.any\` is preferred because \`.not.any.keys\` asserts
   * exactly what's expected of the output, whereas \`.not.all.keys\` creates
   * uncertain expectations.
   *
   *     // Recommended; asserts that target doesn't have any of the given keys
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   *     // Not recommended; asserts that target doesn't have all of the given
   *     // keys but may or may not have some of them
   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
   *
   * When asserting \`.keys\` without negation, \`.all\` is preferred because
   * \`.all.keys\` asserts exactly what's expected of the output, whereas
   * \`.any.keys\` creates uncertain expectations.
   *
   *     // Recommended; asserts that target has all the given keys
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   *     // Not recommended; asserts that target has at least one of the given
   *     // keys but may or may not have more of them
   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
   *
   * Note that \`.all\` is used by default when neither \`.all\` nor \`.any\` appear
   * earlier in the chain. However, it's often best to add \`.all\` anyway because
   * it improves readability.
   *
   *     // Both assertions are identical
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
   *
   * Add \`.include\` earlier in the chain to require that the target's keys be a
   * superset of the expected keys, rather than identical sets.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   * However, if \`.any\` and \`.include\` are combined, only the \`.any\` takes
   * effect. The \`.include\` is ignored in this case.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');
   *
   * The alias \`.key\` can be used interchangeably with \`.keys\`.
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */function assertKeys(keys){var obj=flag(this,'object'),objType=_.type(obj),keysType=_.type(keys),ssfi=flag(this,'ssfi'),isDeep=flag(this,'deep'),str,deepStr='',actual,ok=true,flagMsg=flag(this,'message');flagMsg=flagMsg?flagMsg+': ':'';var mixedArgsMsg=flagMsg+'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';if(objType==='Map'||objType==='Set'){deepStr=isDeep?'deeply ':'';actual=[];// Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.
obj.forEach(function(val,key){actual.push(key);});if(keysType!=='Array'){keys=Array.prototype.slice.call(arguments);}}else{actual=_.getOwnEnumerableProperties(obj);switch(keysType){case'Array':if(arguments.length>1){throw new AssertionError(mixedArgsMsg,undefined,ssfi);}break;case'Object':if(arguments.length>1){throw new AssertionError(mixedArgsMsg,undefined,ssfi);}keys=Object.keys(keys);break;default:keys=Array.prototype.slice.call(arguments);}// Only stringify non-Symbols because Symbols would become "Symbol()"
keys=keys.map(function(val){return typeof val==='symbol'?val:String(val);});}if(!keys.length){throw new AssertionError(flagMsg+'keys required',undefined,ssfi);}var len=keys.length,any=flag(this,'any'),all=flag(this,'all'),expected=keys,isEql=isDeep?flag(this,'eql'):(val1,val2)=>val1===val2;if(!any&&!all){all=true;}// Has any
if(any){ok=expected.some(function(expectedKey){return actual.some(function(actualKey){return isEql(expectedKey,actualKey);});});}// Has all
if(all){ok=expected.every(function(expectedKey){return actual.some(function(actualKey){return isEql(expectedKey,actualKey);});});if(!flag(this,'contains')){ok=ok&&keys.length==actual.length;}}// Key string
if(len>1){keys=keys.map(function(key){return _.inspect(key);});var last=keys.pop();if(all){str=keys.join(', ')+', and '+last;}if(any){str=keys.join(', ')+', or '+last;}}else{str=_.inspect(keys[0]);}// Form
str=(len>1?'keys ':'key ')+str;// Have / include
str=(flag(this,'contains')?'contain ':'have ')+str;// Assertion
this.assert(ok,'expected #{this} to '+deepStr+str,'expected #{this} to not '+deepStr+str,expected.slice(0).sort(_.compareByInspect),actual.sort(_.compareByInspect),true);}Assertion.addMethod('keys',assertKeys);Assertion.addMethod('key',assertKeys);/**
   * ### .throw([errorLike], [errMsgMatcher], [msg])
   *
   * When no arguments are provided, \`.throw\` invokes the target function and
   * asserts that an error is thrown.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw();
   *
   * When one argument is provided, and it's an error constructor, \`.throw\`
   * invokes the target function and asserts that an error is thrown that's an
   * instance of that error constructor.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError);
   *
   * When one argument is provided, and it's an error instance, \`.throw\` invokes
   * the target function and asserts that an error is thrown that's strictly
   * (\`===\`) equal to that error instance.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(err);
   *
   * When one argument is provided, and it's a string, \`.throw\` invokes the
   * target function and asserts that an error is thrown with a message that
   * contains that string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw('salmon');
   *
   * When one argument is provided, and it's a regular expression, \`.throw\`
   * invokes the target function and asserts that an error is thrown with a
   * message that matches that regular expression.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(/salmon/);
   *
   * When two arguments are provided, and the first is an error instance or
   * constructor, and the second is a string or regular expression, \`.throw\`
   * invokes the function and asserts that an error is thrown that fulfills both
   * conditions as described above.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon');
   *     expect(badFn).to.throw(TypeError, /salmon/);
   *     expect(badFn).to.throw(err, 'salmon');
   *     expect(badFn).to.throw(err, /salmon/);
   *
   * Add \`.not\` earlier in the chain to negate \`.throw\`.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw();
   *
   * However, it's dangerous to negate \`.throw\` when providing any arguments.
   * The problem is that it creates uncertain expectations by asserting that the
   * target either doesn't throw an error, or that it throws an error but of a
   * different type than the given type, or that it throws an error of the given
   * type but with a message that doesn't include the given string. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to throw an error, it's often best to assert
   * exactly that.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw(); // Recommended
   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * When the target is expected to throw an error, it's often best to assert
   * that the error is of its expected type, and has a message that includes an
   * expected string, rather than asserting that it doesn't have one of many
   * unexpected types, and doesn't have a message that includes some string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * \`.throw\` changes the target of any assertions that follow in the chain to
   * be the error object that's thrown.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     err.code = 42;
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError).with.property('code', 42);
   *
   * \`.throw\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`. When not providing two arguments, always use
   * the second form.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
   *     expect(goodFn, 'nooo why fail??').to.throw();
   *
   * Due to limitations in ES5, \`.throw\` may not always work as expected when
   * using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing the built-in \`Error\` object and
   * then passing the subclassed constructor to \`.throw\`. See your transpiler's
   * docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * Beware of some common mistakes when using the \`throw\` assertion. One common
   * mistake is to accidentally invoke the function yourself instead of letting
   * the \`throw\` assertion invoke the function for you. For example, when
   * testing if a function named \`fn\` throws, provide \`fn\` instead of \`fn()\` as
   * the target for the assertion.
   *
   *     expect(fn).to.throw();     // Good! Tests \`fn\` as desired
   *     expect(fn()).to.throw();   // Bad! Tests result of \`fn()\`, not \`fn\`
   *
   * If you need to assert that your function \`fn\` throws when passed certain
   * arguments, then wrap a call to \`fn\` inside of another function.
   *
   *     expect(function () { fn(42); }).to.throw();  // Function expression
   *     expect(() => fn(42)).to.throw();             // ES6 arrow function
   *
   * Another common mistake is to provide an object method (or any stand-alone
   * function that relies on \`this\`) as the target of the assertion. Doing so is
   * problematic because the \`this\` context will be lost when the function is
   * invoked by \`.throw\`; there's no way for it to know what \`this\` is supposed
   * to be. There are two ways around this problem. One solution is to wrap the
   * method or function call inside of another function. Another solution is to
   * use \`bind\`.
   *
   *     expect(function () { cat.meow(); }).to.throw();  // Function expression
   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function
   *     expect(cat.meow.bind(cat)).to.throw();           // Bind
   *
   * Finally, it's worth mentioning that it's a best practice in JavaScript to
   * only throw \`Error\` and derivatives of \`Error\` such as \`ReferenceError\`,
   * \`TypeError\`, and user-defined objects that extend \`Error\`. No other type of
   * value will generate a stack trace when initialized. With that said, the
   * \`throw\` assertion does technically support any type of value being thrown,
   * not just \`Error\` and its derivatives.
   *
   * The aliases \`.throws\` and \`.Throw\` can be used interchangeably with
   * \`.throw\`.
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {Error|ErrorConstructor} errorLike
   * @param {String|RegExp} errMsgMatcher error message
   * @param {String} msg _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */function assertThrows(errorLike,errMsgMatcher,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),ssfi=flag(this,'ssfi'),flagMsg=flag(this,'message'),negate=flag(this,'negate')||false;new Assertion(obj,flagMsg,ssfi,true).is.a('function');if(errorLike instanceof RegExp||typeof errorLike==='string'){errMsgMatcher=errorLike;errorLike=null;}var caughtErr;try{obj();}catch(err){caughtErr=err;}// If we have the negate flag enabled and at least one valid argument it means we do expect an error
// but we want it to match a given set of criteria
var everyArgIsUndefined=errorLike===undefined&&errMsgMatcher===undefined;// If we've got the negate flag enabled and both args, we should only fail if both aren't compatible
// See Issue #551 and PR #683@GitHub
var everyArgIsDefined=Boolean(errorLike&&errMsgMatcher);var errorLikeFail=false;var errMsgMatcherFail=false;// Checking if error was thrown
if(everyArgIsUndefined||!everyArgIsUndefined&&!negate){// We need this to display results correctly according to their types
var errorLikeString='an error';if(errorLike instanceof Error){errorLikeString='#{exp}';}else if(errorLike){errorLikeString=_.checkError.getConstructorName(errorLike);}this.assert(caughtErr,'expected #{this} to throw '+errorLikeString,'expected #{this} to not throw an error but #{act} was thrown',errorLike&&errorLike.toString(),caughtErr instanceof Error?caughtErr.toString():typeof caughtErr==='string'?caughtErr:caughtErr&&_.checkError.getConstructorName(caughtErr));}if(errorLike&&caughtErr){// We should compare instances only if \`errorLike\` is an instance of \`Error\`
if(errorLike instanceof Error){var isCompatibleInstance=_.checkError.compatibleInstance(caughtErr,errorLike);if(isCompatibleInstance===negate){// These checks were created to ensure we won't fail too soon when we've got both args and a negate
// See Issue #551 and PR #683@GitHub
if(everyArgIsDefined&&negate){errorLikeFail=true;}else{this.assert(negate,'expected #{this} to throw #{exp} but #{act} was thrown','expected #{this} to not throw #{exp}'+(caughtErr&&!negate?' but #{act} was thrown':''),errorLike.toString(),caughtErr.toString());}}}var isCompatibleConstructor=_.checkError.compatibleConstructor(caughtErr,errorLike);if(isCompatibleConstructor===negate){if(everyArgIsDefined&&negate){errorLikeFail=true;}else{this.assert(negate,'expected #{this} to throw #{exp} but #{act} was thrown','expected #{this} to not throw #{exp}'+(caughtErr?' but #{act} was thrown':''),errorLike instanceof Error?errorLike.toString():errorLike&&_.checkError.getConstructorName(errorLike),caughtErr instanceof Error?caughtErr.toString():caughtErr&&_.checkError.getConstructorName(caughtErr));}}}if(caughtErr&&errMsgMatcher!==undefined&&errMsgMatcher!==null){// Here we check compatible messages
var placeholder='including';if(errMsgMatcher instanceof RegExp){placeholder='matching';}var isCompatibleMessage=_.checkError.compatibleMessage(caughtErr,errMsgMatcher);if(isCompatibleMessage===negate){if(everyArgIsDefined&&negate){errMsgMatcherFail=true;}else{this.assert(negate,'expected #{this} to throw error '+placeholder+' #{exp} but got #{act}','expected #{this} to throw error not '+placeholder+' #{exp}',errMsgMatcher,_.checkError.getMessage(caughtErr));}}}// If both assertions failed and both should've matched we throw an error
if(errorLikeFail&&errMsgMatcherFail){this.assert(negate,'expected #{this} to throw #{exp} but #{act} was thrown','expected #{this} to not throw #{exp}'+(caughtErr?' but #{act} was thrown':''),errorLike instanceof Error?errorLike.toString():errorLike&&_.checkError.getConstructorName(errorLike),caughtErr instanceof Error?caughtErr.toString():caughtErr&&_.checkError.getConstructorName(caughtErr));}flag(this,'object',caughtErr);}Assertion.addMethod('throw',assertThrows);Assertion.addMethod('throws',assertThrows);Assertion.addMethod('Throw',assertThrows);/**
   * ### .respondTo(method[, msg])
   *
   * When the target is a non-function object, \`.respondTo\` asserts that the
   * target has a method with the given name \`method\`. The method can be own or
   * inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.respondTo('meow');
   *
   * When the target is a function, \`.respondTo\` asserts that the target's
   * \`prototype\` property has a method with the given name \`method\`. Again, the
   * method can be own or inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(Cat).to.respondTo('meow');
   *
   * Add \`.itself\` earlier in the chain to force \`.respondTo\` to treat the
   * target as a non-function object, even if it's a function. Thus, it asserts
   * that the target has a method with the given name \`method\`, rather than
   * asserting that the target's \`prototype\` property has a method with the
   * given name \`method\`.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * When not adding \`.itself\`, it's important to check the target's type before
   * using \`.respondTo\`. See the \`.a\` doc for info on checking a target's type.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');
   *
   * Add \`.not\` earlier in the chain to negate \`.respondTo\`.
   *
   *     function Dog () {}
   *     Dog.prototype.bark = function () {};
   *
   *     expect(new Dog()).to.not.respondTo('meow');
   *
   * \`.respondTo\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect({}).to.respondTo('meow', 'nooo why fail??');
   *     expect({}, 'nooo why fail??').to.respondTo('meow');
   *
   * The alias \`.respondsTo\` can be used interchangeably with \`.respondTo\`.
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function respondTo(method,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),itself=flag(this,'itself'),context='function'===typeof obj&&!itself?obj.prototype[method]:obj[method];this.assert('function'===typeof context,'expected #{this} to respond to '+_.inspect(method),'expected #{this} to not respond to '+_.inspect(method));}Assertion.addMethod('respondTo',respondTo);Assertion.addMethod('respondsTo',respondTo);/**
   * ### .itself
   *
   * Forces all \`.respondTo\` assertions that follow in the chain to behave as if
   * the target is a non-function object, even if it's a function. Thus, it
   * causes \`.respondTo\` to assert that the target has a method with the given
   * name, rather than asserting that the target's \`prototype\` property has a
   * method with the given name.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */Assertion.addProperty('itself',function(){flag(this,'itself',true);});/**
   * ### .satisfy(matcher[, msg])
   *
   * Invokes the given \`matcher\` function with the target being passed as the
   * first argument, and asserts that the value returned is truthy.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 0;
   *     });
   *
   * Add \`.not\` earlier in the chain to negate \`.satisfy\`.
   *
   *     expect(1).to.not.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * \`.satisfy\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 2;
   *     }, 'nooo why fail??');
   *
   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * The alias \`.satisfies\` can be used interchangeably with \`.satisfy\`.
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function satisfy(matcher,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object');var result=matcher(obj);this.assert(result,'expected #{this} to satisfy '+_.objDisplay(matcher),'expected #{this} to not satisfy'+_.objDisplay(matcher),flag(this,'negate')?false:true,result);}Assertion.addMethod('satisfy',satisfy);Assertion.addMethod('satisfies',satisfy);/**
   * ### .closeTo(expected, delta[, msg])
   *
   * Asserts that the target is a number that's within a given +/- \`delta\` range
   * of the given number \`expected\`. However, it's often best to assert that the
   * target is equal to its expected value.
   *
   *     // Recommended
   *     expect(1.5).to.equal(1.5);
   *
   *     // Not recommended
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *     expect(1.5).to.be.closeTo(2, 0.5);
   *     expect(1.5).to.be.closeTo(1, 1);
   *
   * Add \`.not\` earlier in the chain to negate \`.closeTo\`.
   *
   *     expect(1.5).to.equal(1.5); // Recommended
   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
   *
   * \`.closeTo\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
   *
   * The alias \`.approximately\` can be used interchangeably with \`.closeTo\`.
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function closeTo(expected,delta,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi');new Assertion(obj,flagMsg,ssfi,true).is.a('number');if(typeof expected!=='number'||typeof delta!=='number'){flagMsg=flagMsg?flagMsg+': ':'';var deltaMessage=delta===undefined?", and a delta is required":"";throw new AssertionError(flagMsg+'the arguments to closeTo or approximately must be numbers'+deltaMessage,undefined,ssfi);}this.assert(Math.abs(obj-expected)<=delta,'expected #{this} to be close to '+expected+' +/- '+delta,'expected #{this} not to be close to '+expected+' +/- '+delta);}Assertion.addMethod('closeTo',closeTo);Assertion.addMethod('approximately',closeTo);// Note: Duplicates are ignored if testing for inclusion instead of sameness.
function isSubsetOf(subset,superset,cmp,contains,ordered){if(!contains){if(subset.length!==superset.length)return false;superset=superset.slice();}return subset.every(function(elem,idx){if(ordered)return cmp?cmp(elem,superset[idx]):elem===superset[idx];if(!cmp){var matchIdx=superset.indexOf(elem);if(matchIdx===-1)return false;// Remove match from superset so not counted twice if duplicate in subset.
if(!contains)superset.splice(matchIdx,1);return true;}return superset.some(function(elem2,matchIdx){if(!cmp(elem,elem2))return false;// Remove match from superset so not counted twice if duplicate in subset.
if(!contains)superset.splice(matchIdx,1);return true;});});}/**
   * ### .members(set[, msg])
   *
   * Asserts that the target array has the same members as the given array
   * \`set\`.
   *
   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);
   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);
   *
   * By default, members are compared using strict (\`===\`) equality. Add \`.deep\`
   * earlier in the chain to use deep equality instead. See the \`deep-eql\`
   * project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) has member \`{a: 1}\`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   * By default, order doesn't matter. Add \`.ordered\` earlier in the chain to
   * require that members appear in the same order.
   *
   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
   *     expect([1, 2, 3]).to.have.members([2, 1, 3])
   *       .but.not.ordered.members([2, 1, 3]);
   *
   * By default, both arrays must be the same size. Add \`.include\` earlier in
   * the chain to require that the target's members be a superset of the
   * expected members. Note that duplicates are ignored in the subset when
   * \`.include\` is added.
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * \`.deep\`, \`.ordered\`, and \`.include\` can all be combined. However, if
   * \`.include\` and \`.ordered\` are combined, the ordering begins at the start of
   * both arrays.
   *
   *     expect([{a: 1}, {b: 2}, {c: 3}])
   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])
   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
   *
   * Add \`.not\` earlier in the chain to negate \`.members\`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the target array doesn't have all of the same members as
   * the given array \`set\` but may or may not have some of them. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
   *
   * \`.members\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`.
   *
   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
   *
   * @name members
   * @param {Array} set
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */Assertion.addMethod('members',function(subset,msg){if(msg)flag(this,'message',msg);var obj=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi');new Assertion(obj,flagMsg,ssfi,true).to.be.an('array');new Assertion(subset,flagMsg,ssfi,true).to.be.an('array');var contains=flag(this,'contains');var ordered=flag(this,'ordered');var subject,failMsg,failNegateMsg;if(contains){subject=ordered?'an ordered superset':'a superset';failMsg='expected #{this} to be '+subject+' of #{exp}';failNegateMsg='expected #{this} to not be '+subject+' of #{exp}';}else{subject=ordered?'ordered members':'members';failMsg='expected #{this} to have the same '+subject+' as #{exp}';failNegateMsg='expected #{this} to not have the same '+subject+' as #{exp}';}var cmp=flag(this,'deep')?flag(this,'eql'):undefined;this.assert(isSubsetOf(subset,obj,cmp,contains,ordered),failMsg,failNegateMsg,subset,obj,true);});/**
   * ### .oneOf(list[, msg])
   *
   * Asserts that the target is a member of the given array \`list\`. However,
   * it's often best to assert that the target is equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
   *
   * Comparisons are performed using strict (\`===\`) equality.
   *
   * Add \`.not\` earlier in the chain to negate \`.oneOf\`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
   *
   * It can also be chained with \`.contain\` or \`.include\`, which will work with
   * both arrays and strings:
   *
   *     expect('Today is sunny').to.contain.oneOf(['sunny', 'cloudy'])
   *     expect('Today is rainy').to.not.contain.oneOf(['sunny', 'cloudy'])
   *     expect([1,2,3]).to.contain.oneOf([3,4,5])
   *     expect([1,2,3]).to.not.contain.oneOf([4,5,6])
   *
   * \`.oneOf\` accepts an optional \`msg\` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to \`expect\`.
   *
   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function oneOf(list,msg){if(msg)flag(this,'message',msg);var expected=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi'),contains=flag(this,'contains'),isDeep=flag(this,'deep'),eql=flag(this,'eql');new Assertion(list,flagMsg,ssfi,true).to.be.an('array');if(contains){this.assert(list.some(function(possibility){return expected.indexOf(possibility)>-1;}),'expected #{this} to contain one of #{exp}','expected #{this} to not contain one of #{exp}',list,expected);}else{if(isDeep){this.assert(list.some(function(possibility){return eql(expected,possibility);}),'expected #{this} to deeply equal one of #{exp}','expected #{this} to deeply equal one of #{exp}',list,expected);}else{this.assert(list.indexOf(expected)>-1,'expected #{this} to be one of #{exp}','expected #{this} to not be one of #{exp}',list,expected);}}}Assertion.addMethod('oneOf',oneOf);/**
   * ### .change(subject[, prop[, msg]])
   *
   * When one argument is provided, \`.change\` asserts that the given function
   * \`subject\` returns a different value when it's invoked before the target
   * function compared to when it's invoked afterward. However, it's often best
   * to assert that \`subject\` is equal to its expected value.
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     // Recommended
   *     expect(getDots()).to.equal('');
   *     addDot();
   *     expect(getDots()).to.equal('.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(getDots);
   *
   * When two arguments are provided, \`.change\` asserts that the value of the
   * given object \`subject\`'s \`prop\` property is different before invoking the
   * target function compared to afterward.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     // Recommended
   *     expect(myObj).to.have.property('dots', '');
   *     addDot();
   *     expect(myObj).to.have.property('dots', '.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(myObj, 'dots');
   *
   * Strict (\`===\`) equality is used to compare before and after values.
   *
   * Add \`.not\` earlier in the chain to negate \`.change\`.
   *
   *     var dots = ''
   *       , noop = function () {}
   *       , getDots = function () { return dots; };
   *
   *     expect(noop).to.not.change(getDots);
   *
   *     var myObj = {dots: ''}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'dots');
   *
   * \`.change\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);
   *
   * \`.change\` also causes all \`.by\` assertions that follow in the chain to
   * assert how much a numeric subject was increased or decreased by. However,
   * it's dangerous to use \`.change.by\`. The problem is that it creates
   * uncertain expectations by asserting that the subject either increases by
   * the given delta, or that it decreases by the given delta. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * The alias \`.changes\` can be used interchangeably with \`.change\`.
   *
   * @name change
   * @alias changes
   * @param {String} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertChanges(subject,prop,msg){if(msg)flag(this,'message',msg);var fn=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi');new Assertion(fn,flagMsg,ssfi,true).is.a('function');var initial;if(!prop){new Assertion(subject,flagMsg,ssfi,true).is.a('function');initial=subject();}else{new Assertion(subject,flagMsg,ssfi,true).to.have.property(prop);initial=subject[prop];}fn();var final=prop===undefined||prop===null?subject():subject[prop];var msgObj=prop===undefined||prop===null?initial:'.'+prop;// This gets flagged because of the .by(delta) assertion
flag(this,'deltaMsgObj',msgObj);flag(this,'initialDeltaValue',initial);flag(this,'finalDeltaValue',final);flag(this,'deltaBehavior','change');flag(this,'realDelta',final!==initial);this.assert(initial!==final,'expected '+msgObj+' to change','expected '+msgObj+' to not change');}Assertion.addMethod('change',assertChanges);Assertion.addMethod('changes',assertChanges);/**
   * ### .increase(subject[, prop[, msg]])
   *
   * When one argument is provided, \`.increase\` asserts that the given function
   * \`subject\` returns a greater number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. \`.increase\` also
   * causes all \`.by\` assertions that follow in the chain to assert how much
   * greater of a number is returned. It's often best to assert that the return
   * value increased by the expected amount, rather than asserting it increased
   * by any amount.
   *
   *     var val = 1
   *       , addTwo = function () { val += 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(addTwo).to.increase(getVal).by(2); // Recommended
   *     expect(addTwo).to.increase(getVal); // Not recommended
   *
   * When two arguments are provided, \`.increase\` asserts that the value of the
   * given object \`subject\`'s \`prop\` property is greater after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.increase\`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either decreases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to decrease, it's often best to assert that it
   * decreased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended
   *
   * \`.increase\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.increase(getVal);
   *
   * The alias \`.increases\` can be used interchangeably with \`.increase\`.
   *
   * @name increase
   * @alias increases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertIncreases(subject,prop,msg){if(msg)flag(this,'message',msg);var fn=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi');new Assertion(fn,flagMsg,ssfi,true).is.a('function');var initial;if(!prop){new Assertion(subject,flagMsg,ssfi,true).is.a('function');initial=subject();}else{new Assertion(subject,flagMsg,ssfi,true).to.have.property(prop);initial=subject[prop];}// Make sure that the target is a number
new Assertion(initial,flagMsg,ssfi,true).is.a('number');fn();var final=prop===undefined||prop===null?subject():subject[prop];var msgObj=prop===undefined||prop===null?initial:'.'+prop;flag(this,'deltaMsgObj',msgObj);flag(this,'initialDeltaValue',initial);flag(this,'finalDeltaValue',final);flag(this,'deltaBehavior','increase');flag(this,'realDelta',final-initial);this.assert(final-initial>0,'expected '+msgObj+' to increase','expected '+msgObj+' to not increase');}Assertion.addMethod('increase',assertIncreases);Assertion.addMethod('increases',assertIncreases);/**
   * ### .decrease(subject[, prop[, msg]])
   *
   * When one argument is provided, \`.decrease\` asserts that the given function
   * \`subject\` returns a lesser number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. \`.decrease\` also
   * causes all \`.by\` assertions that follow in the chain to assert how much
   * lesser of a number is returned. It's often best to assert that the return
   * value decreased by the expected amount, rather than asserting it decreased
   * by any amount.
   *
   *     var val = 1
   *       , subtractTwo = function () { val -= 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
   *     expect(subtractTwo).to.decrease(getVal); // Not recommended
   *
   * When two arguments are provided, \`.decrease\` asserts that the value of the
   * given object \`subject\`'s \`prop\` property is lesser after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.decrease\`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either increases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to increase, it's often best to assert that it
   * increased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * \`.decrease\` accepts an optional \`msg\` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to \`expect\`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.decrease(getVal);
   *
   * The alias \`.decreases\` can be used interchangeably with \`.decrease\`.
   *
   * @name decrease
   * @alias decreases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertDecreases(subject,prop,msg){if(msg)flag(this,'message',msg);var fn=flag(this,'object'),flagMsg=flag(this,'message'),ssfi=flag(this,'ssfi');new Assertion(fn,flagMsg,ssfi,true).is.a('function');var initial;if(!prop){new Assertion(subject,flagMsg,ssfi,true).is.a('function');initial=subject();}else{new Assertion(subject,flagMsg,ssfi,true).to.have.property(prop);initial=subject[prop];}// Make sure that the target is a number
new Assertion(initial,flagMsg,ssfi,true).is.a('number');fn();var final=prop===undefined||prop===null?subject():subject[prop];var msgObj=prop===undefined||prop===null?initial:'.'+prop;flag(this,'deltaMsgObj',msgObj);flag(this,'initialDeltaValue',initial);flag(this,'finalDeltaValue',final);flag(this,'deltaBehavior','decrease');flag(this,'realDelta',initial-final);this.assert(final-initial<0,'expected '+msgObj+' to decrease','expected '+msgObj+' to not decrease');}Assertion.addMethod('decrease',assertDecreases);Assertion.addMethod('decreases',assertDecreases);/**
   * ### .by(delta[, msg])
   *
   * When following an \`.increase\` assertion in the chain, \`.by\` asserts that
   * the subject of the \`.increase\` assertion increased by the given \`delta\`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   * When following a \`.decrease\` assertion in the chain, \`.by\` asserts that the
   * subject of the \`.decrease\` assertion decreased by the given \`delta\`.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);
   *
   * When following a \`.change\` assertion in the chain, \`.by\` asserts that the
   * subject of the \`.change\` assertion either increased or decreased by the
   * given \`delta\`. However, it's dangerous to use \`.change.by\`. The problem is
   * that it creates uncertain expectations. It's often best to identify the
   * exact output that's expected, and then write an assertion that only accepts
   * that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * Add \`.not\` earlier in the chain to negate \`.by\`. However, it's often best
   * to assert that the subject changed by its expected delta, rather than
   * asserting that it didn't change by one of countless unexpected deltas.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     // Recommended
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   *     // Not recommended
   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
   *
   * \`.by\` accepts an optional \`msg\` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to \`expect\`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
   *
   * @name by
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */function assertDelta(delta,msg){if(msg)flag(this,'message',msg);var msgObj=flag(this,'deltaMsgObj');var initial=flag(this,'initialDeltaValue');var final=flag(this,'finalDeltaValue');var behavior=flag(this,'deltaBehavior');var realDelta=flag(this,'realDelta');var expression;if(behavior==='change'){expression=Math.abs(final-initial)===Math.abs(delta);}else{expression=realDelta===Math.abs(delta);}this.assert(expression,'expected '+msgObj+' to '+behavior+' by '+delta,'expected '+msgObj+' to not '+behavior+' by '+delta);}Assertion.addMethod('by',assertDelta);/**
   * ### .extensible
   *
   * Asserts that the target is extensible, which means that new properties can
   * be added to it. Primitives are never extensible.
   *
   *     expect({a: 1}).to.be.extensible;
   *
   * Add \`.not\` earlier in the chain to negate \`.extensible\`.
   *
   *     var nonExtensibleObject = Object.preventExtensions({})
   *       , sealedObject = Object.seal({})
   *       , frozenObject = Object.freeze({});
   *
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *     expect(1).to.not.be.extensible;
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect(1, 'nooo why fail??').to.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */Assertion.addProperty('extensible',function(){var obj=flag(this,'object');// In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
// In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
// The following provides ES6 behavior for ES5 environments.
var isExtensible=obj===Object(obj)&&Object.isExtensible(obj);this.assert(isExtensible,'expected #{this} to be extensible','expected #{this} to not be extensible');});/**
   * ### .sealed
   *
   * Asserts that the target is sealed, which means that new properties can't be
   * added to it, and its existing properties can't be reconfigured or deleted.
   * However, it's possible that its existing properties can still be reassigned
   * to different values. Primitives are always sealed.
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect(1).to.be.sealed;
   *
   * Add \`.not\` earlier in the chain to negate \`.sealed\`.
   *
   *     expect({a: 1}).to.not.be.sealed;
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */Assertion.addProperty('sealed',function(){var obj=flag(this,'object');// In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
// In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
// The following provides ES6 behavior for ES5 environments.
var isSealed=obj===Object(obj)?Object.isSealed(obj):true;this.assert(isSealed,'expected #{this} to be sealed','expected #{this} to not be sealed');});/**
   * ### .frozen
   *
   * Asserts that the target is frozen, which means that new properties can't be
   * added to it, and its existing properties can't be reassigned to different
   * values, reconfigured, or deleted. Primitives are always frozen.
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect(1).to.be.frozen;
   *
   * Add \`.not\` earlier in the chain to negate \`.frozen\`.
   *
   *     expect({a: 1}).to.not.be.frozen;
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */Assertion.addProperty('frozen',function(){var obj=flag(this,'object');// In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
// In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
// The following provides ES6 behavior for ES5 environments.
var isFrozen=obj===Object(obj)?Object.isFrozen(obj):true;this.assert(isFrozen,'expected #{this} to be frozen','expected #{this} to not be frozen');});/**
   * ### .finite
   *
   * Asserts that the target is a number, and isn't \`NaN\` or positive/negative
   * \`Infinity\`.
   *
   *     expect(1).to.be.finite;
   *
   * Add \`.not\` earlier in the chain to negate \`.finite\`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either isn't a number, or that it's \`NaN\`, or
   * that it's positive \`Infinity\`, or that it's negative \`Infinity\`. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to be a number, it's often best to assert
   * that it's the expected type, rather than asserting that it isn't one of
   * many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.finite; // Not recommended
   *
   * When the target is expected to be \`NaN\`, it's often best to assert exactly
   * that.
   *
   *     expect(NaN).to.be.NaN; // Recommended
   *     expect(NaN).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be positive infinity, it's often best to
   * assert exactly that.
   *
   *     expect(Infinity).to.equal(Infinity); // Recommended
   *     expect(Infinity).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be negative infinity, it's often best to
   * assert exactly that.
   *
   *     expect(-Infinity).to.equal(-Infinity); // Recommended
   *     expect(-Infinity).to.not.be.finite; // Not recommended
   *
   * A custom error message can be given as the second argument to \`expect\`.
   *
   *     expect('foo', 'nooo why fail??').to.be.finite;
   *
   * @name finite
   * @namespace BDD
   * @api public
   */Assertion.addProperty('finite',function(msg){var obj=flag(this,'object');this.assert(typeof obj==='number'&&isFinite(obj),'expected #{this} to be a finite number','expected #{this} to not be a finite number');});};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var expect$1=function(chai,util){chai.expect=function(val,message){return new chai.Assertion(val,message);};/**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   *     expect.fail();
   *     expect.fail("custom error message");
   *     expect.fail(1, 2);
   *     expect.fail(1, 2, "custom error message");
   *     expect.fail(1, 2, "custom error message", ">");
   *     expect.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace BDD
   * @api public
   */chai.expect.fail=function(actual,expected,message,operator){if(arguments.length<2){message=actual;actual=undefined;}message=message||'expect.fail()';throw new chai.AssertionError(message,{actual:actual,expected:expected,operator:operator},chai.expect.fail);};};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var should=function(chai,util){var Assertion=chai.Assertion;function loadShould(){// explicitly define this method as function as to have it's name to include as \`ssfi\`
function shouldGetter(){if(this instanceof String||this instanceof Number||this instanceof Boolean||typeof Symbol==='function'&&this instanceof Symbol||typeof BigInt==='function'&&this instanceof BigInt){return new Assertion(this.valueOf(),null,shouldGetter);}return new Assertion(this,null,shouldGetter);}function shouldSetter(value){// See https://github.com/chaijs/chai/issues/86: this makes
// \`whatever.should = someValue\` actually set \`someValue\`, which is
// especially useful for \`global.should = require('chai').should()\`.
//
// Note that we have to use [[DefineProperty]] instead of [[Put]]
// since otherwise we would trigger this very setter!
Object.defineProperty(this,'should',{value:value,enumerable:true,configurable:true,writable:true});}// modify Object.prototype to have \`should\`
Object.defineProperty(Object.prototype,'should',{set:shouldSetter,get:shouldGetter,configurable:true});var should={};/**
     * ### .fail([message])
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     *     should.fail();
     *     should.fail("custom error message");
     *     should.fail(1, 2);
     *     should.fail(1, 2, "custom error message");
     *     should.fail(1, 2, "custom error message", ">");
     *     should.fail(1, 2, undefined, ">");
     *
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace BDD
     * @api public
     */should.fail=function(actual,expected,message,operator){if(arguments.length<2){message=actual;actual=undefined;}message=message||'should.fail()';throw new chai.AssertionError(message,{actual:actual,expected:expected,operator:operator},should.fail);};/**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (\`==\`) of \`actual\` and \`expected\`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */should.equal=function(val1,val2,msg){new Assertion(val1,msg).to.equal(val2);};/**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that \`function\` will throw an error that is an instance of
     * \`constructor\`, or alternately that it will throw an error with message
     * matching \`regexp\`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */should.Throw=function(fn,errt,errs,msg){new Assertion(fn,msg).to.Throw(errt,errs);};/**
     * ### .exist
     *
     * Asserts that the target is neither \`null\` nor \`undefined\`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */should.exist=function(val,msg){new Assertion(val,msg).to.exist;};// negation
should.not={};/**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (\`!=\`) of \`actual\` and \`expected\`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */should.not.equal=function(val1,val2,msg){new Assertion(val1,msg).to.not.equal(val2);};/**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that \`function\` will _not_ throw an error that is an instance of
     * \`constructor\`, or alternately that it will not throw an error with message
     * matching \`regexp\`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */should.not.Throw=function(fn,errt,errs,msg){new Assertion(fn,msg).to.not.Throw(errt,errs);};/**
     * ### .not.exist
     *
     * Asserts that the target is neither \`null\` nor \`undefined\`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */should.not.exist=function(val,msg){new Assertion(val,msg).to.not.exist;};should['throw']=should['Throw'];should.not['throw']=should.not['Throw'];return should;}chai.should=loadShould;chai.Should=loadShould;};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var assert$1=function(chai,util){/*!
   * Chai dependencies.
   */var Assertion=chai.Assertion,flag=util.flag;/*!
   * Module export.
   */ /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */var assert=chai.assert=function(express,errmsg){var test=new Assertion(null,null,chai.assert,true);test.assert(express,errmsg,'[ negation message unavailable ]');};/**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js \`assert\` module-compatible.
   *
   *     assert.fail();
   *     assert.fail("custom error message");
   *     assert.fail(1, 2);
   *     assert.fail(1, 2, "custom error message");
   *     assert.fail(1, 2, "custom error message", ">");
   *     assert.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */assert.fail=function(actual,expected,message,operator){if(arguments.length<2){// Comply with Node's fail([message]) interface
message=actual;actual=undefined;}message=message||'assert.fail()';throw new chai.AssertionError(message,{actual:actual,expected:expected,operator:operator},assert.fail);};/**
   * ### .isOk(object, [message])
   *
   * Asserts that \`object\` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isOk=function(val,msg){new Assertion(val,msg,assert.isOk,true).is.ok;};/**
   * ### .isNotOk(object, [message])
   *
   * Asserts that \`object\` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotOk=function(val,msg){new Assertion(val,msg,assert.isNotOk,true).is.not.ok;};/**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (\`==\`) of \`actual\` and \`expected\`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.equal=function(act,exp,msg){var test=new Assertion(act,msg,assert.equal,true);test.assert(exp==flag(test,'object'),'expected #{this} to equal #{exp}','expected #{this} to not equal #{act}',exp,act,true);};/**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (\`!=\`) of \`actual\` and \`expected\`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notEqual=function(act,exp,msg){var test=new Assertion(act,msg,assert.notEqual,true);test.assert(exp!=flag(test,'object'),'expected #{this} to not equal #{exp}','expected #{this} to equal #{act}',exp,act,true);};/**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (\`===\`) of \`actual\` and \`expected\`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.strictEqual=function(act,exp,msg){new Assertion(act,msg,assert.strictEqual,true).to.equal(exp);};/**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (\`!==\`) of \`actual\` and \`expected\`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notStrictEqual=function(act,exp,msg){new Assertion(act,msg,assert.notStrictEqual,true).to.not.equal(exp);};/**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that \`actual\` is deeply equal to \`expected\`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @alias deepStrictEqual
   * @namespace Assert
   * @api public
   */assert.deepEqual=assert.deepStrictEqual=function(act,exp,msg){new Assertion(act,msg,assert.deepEqual,true).to.eql(exp);};/**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that \`actual\` is not deeply equal to \`expected\`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notDeepEqual=function(act,exp,msg){new Assertion(act,msg,assert.notDeepEqual,true).to.not.eql(exp);};/**
  * ### .isAbove(valueToCheck, valueToBeAbove, [message])
  *
  * Asserts \`valueToCheck\` is strictly greater than (>) \`valueToBeAbove\`.
  *
  *     assert.isAbove(5, 2, '5 is strictly greater than 2');
  *
  * @name isAbove
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAbove
  * @param {String} message
  * @namespace Assert
  * @api public
  */assert.isAbove=function(val,abv,msg){new Assertion(val,msg,assert.isAbove,true).to.be.above(abv);};/**
  * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
  *
  * Asserts \`valueToCheck\` is greater than or equal to (>=) \`valueToBeAtLeast\`.
  *
  *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
  *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
  *
  * @name isAtLeast
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtLeast
  * @param {String} message
  * @namespace Assert
  * @api public
  */assert.isAtLeast=function(val,atlst,msg){new Assertion(val,msg,assert.isAtLeast,true).to.be.least(atlst);};/**
  * ### .isBelow(valueToCheck, valueToBeBelow, [message])
  *
  * Asserts \`valueToCheck\` is strictly less than (<) \`valueToBeBelow\`.
  *
  *     assert.isBelow(3, 6, '3 is strictly less than 6');
  *
  * @name isBelow
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeBelow
  * @param {String} message
  * @namespace Assert
  * @api public
  */assert.isBelow=function(val,blw,msg){new Assertion(val,msg,assert.isBelow,true).to.be.below(blw);};/**
  * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
  *
  * Asserts \`valueToCheck\` is less than or equal to (<=) \`valueToBeAtMost\`.
  *
  *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
  *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
  *
  * @name isAtMost
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtMost
  * @param {String} message
  * @namespace Assert
  * @api public
  */assert.isAtMost=function(val,atmst,msg){new Assertion(val,msg,assert.isAtMost,true).to.be.most(atmst);};/**
   * ### .isTrue(value, [message])
   *
   * Asserts that \`value\` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isTrue=function(val,msg){new Assertion(val,msg,assert.isTrue,true).is['true'];};/**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that \`value\` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotTrue=function(val,msg){new Assertion(val,msg,assert.isNotTrue,true).to.not.equal(true);};/**
   * ### .isFalse(value, [message])
   *
   * Asserts that \`value\` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isFalse=function(val,msg){new Assertion(val,msg,assert.isFalse,true).is['false'];};/**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that \`value\` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotFalse=function(val,msg){new Assertion(val,msg,assert.isNotFalse,true).to.not.equal(false);};/**
   * ### .isNull(value, [message])
   *
   * Asserts that \`value\` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNull=function(val,msg){new Assertion(val,msg,assert.isNull,true).to.equal(null);};/**
   * ### .isNotNull(value, [message])
   *
   * Asserts that \`value\` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotNull=function(val,msg){new Assertion(val,msg,assert.isNotNull,true).to.not.equal(null);};/**
   * ### .isNaN
   *
   * Asserts that value is NaN.
   *
   *     assert.isNaN(NaN, 'NaN is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNaN=function(val,msg){new Assertion(val,msg,assert.isNaN,true).to.be.NaN;};/**
   * ### .isNotNaN
   *
   * Asserts that value is not NaN.
   *
   *     assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotNaN=function(val,msg){new Assertion(val,msg,assert.isNotNaN,true).not.to.be.NaN;};/**
   * ### .exists
   *
   * Asserts that the target is neither \`null\` nor \`undefined\`.
   *
   *     var foo = 'hi';
   *
   *     assert.exists(foo, 'foo is neither \`null\` nor \`undefined\`');
   *
   * @name exists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.exists=function(val,msg){new Assertion(val,msg,assert.exists,true).to.exist;};/**
   * ### .notExists
   *
   * Asserts that the target is either \`null\` or \`undefined\`.
   *
   *     var bar = null
   *       , baz;
   *
   *     assert.notExists(bar);
   *     assert.notExists(baz, 'baz is either null or undefined');
   *
   * @name notExists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notExists=function(val,msg){new Assertion(val,msg,assert.notExists,true).to.not.exist;};/**
   * ### .isUndefined(value, [message])
   *
   * Asserts that \`value\` is \`undefined\`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isUndefined=function(val,msg){new Assertion(val,msg,assert.isUndefined,true).to.equal(undefined);};/**
   * ### .isDefined(value, [message])
   *
   * Asserts that \`value\` is not \`undefined\`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isDefined=function(val,msg){new Assertion(val,msg,assert.isDefined,true).to.not.equal(undefined);};/**
   * ### .isFunction(value, [message])
   *
   * Asserts that \`value\` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isFunction=function(val,msg){new Assertion(val,msg,assert.isFunction,true).to.be.a('function');};/**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that \`value\` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotFunction=function(val,msg){new Assertion(val,msg,assert.isNotFunction,true).to.not.be.a('function');};/**
   * ### .isObject(value, [message])
   *
   * Asserts that \`value\` is an object of type 'Object' (as revealed by \`Object.prototype.toString\`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isObject=function(val,msg){new Assertion(val,msg,assert.isObject,true).to.be.a('object');};/**
   * ### .isNotObject(value, [message])
   *
   * Asserts that \`value\` is _not_ an object of type 'Object' (as revealed by \`Object.prototype.toString\`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotObject=function(val,msg){new Assertion(val,msg,assert.isNotObject,true).to.not.be.a('object');};/**
   * ### .isArray(value, [message])
   *
   * Asserts that \`value\` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isArray=function(val,msg){new Assertion(val,msg,assert.isArray,true).to.be.an('array');};/**
   * ### .isNotArray(value, [message])
   *
   * Asserts that \`value\` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotArray=function(val,msg){new Assertion(val,msg,assert.isNotArray,true).to.not.be.an('array');};/**
   * ### .isString(value, [message])
   *
   * Asserts that \`value\` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isString=function(val,msg){new Assertion(val,msg,assert.isString,true).to.be.a('string');};/**
   * ### .isNotString(value, [message])
   *
   * Asserts that \`value\` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotString=function(val,msg){new Assertion(val,msg,assert.isNotString,true).to.not.be.a('string');};/**
   * ### .isNumber(value, [message])
   *
   * Asserts that \`value\` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNumber=function(val,msg){new Assertion(val,msg,assert.isNumber,true).to.be.a('number');};/**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that \`value\` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotNumber=function(val,msg){new Assertion(val,msg,assert.isNotNumber,true).to.not.be.a('number');};/**
  * ### .isFinite(value, [message])
  *
  * Asserts that \`value\` is a finite number. Unlike \`.isNumber\`, this will fail for \`NaN\` and \`Infinity\`.
  *
  *     var cups = 2;
  *     assert.isFinite(cups, 'how many cups');
  *
  *     assert.isFinite(NaN); // throws
  *
  * @name isFinite
  * @param {Number} value
  * @param {String} message
  * @namespace Assert
  * @api public
  */assert.isFinite=function(val,msg){new Assertion(val,msg,assert.isFinite,true).to.be.finite;};/**
   * ### .isBoolean(value, [message])
   *
   * Asserts that \`value\` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isBoolean=function(val,msg){new Assertion(val,msg,assert.isBoolean,true).to.be.a('boolean');};/**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that \`value\` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.isNotBoolean=function(val,msg){new Assertion(val,msg,assert.isNotBoolean,true).to.not.be.a('boolean');};/**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that \`value\`'s type is \`name\`, as determined by
   * \`Object.prototype.toString\`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.typeOf=function(val,type,msg){new Assertion(val,msg,assert.typeOf,true).to.be.a(type);};/**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that \`value\`'s type is _not_ \`name\`, as determined by
   * \`Object.prototype.toString\`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notTypeOf=function(val,type,msg){new Assertion(val,msg,assert.notTypeOf,true).to.not.be.a(type);};/**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that \`value\` is an instance of \`constructor\`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.instanceOf=function(val,type,msg){new Assertion(val,msg,assert.instanceOf,true).to.be.instanceOf(type);};/**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts \`value\` is not an instance of \`constructor\`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notInstanceOf=function(val,type,msg){new Assertion(val,msg,assert.notInstanceOf,true).to.not.be.instanceOf(type);};/**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that \`haystack\` includes \`needle\`. Can be used to assert the
   * inclusion of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.include([1,2,3], 2, 'array contains value');
   *     assert.include('foobar', 'foo', 'string contains substring');
   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');
   *
   * Strict equality (===) is used. When asserting the inclusion of a value in
   * an array, the array is searched for an element that's strictly equal to the
   * given value. When asserting a subset of properties in an object, the object
   * is searched for the given property keys, checking that each one is present
   * and strictly equal to the given property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.include([obj1, obj2], obj1);
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.include=function(exp,inc,msg){new Assertion(exp,msg,assert.include,true).include(inc);};/**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that \`haystack\` does not include \`needle\`. Can be used to assert
   * the absence of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.notInclude([1,2,3], 4, "array doesn't contain value");
   *     assert.notInclude('foobar', 'baz', "string doesn't contain substring");
   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');
   *
   * Strict equality (===) is used. When asserting the absence of a value in an
   * array, the array is searched to confirm the absence of an element that's
   * strictly equal to the given value. When asserting a subset of properties in
   * an object, the object is searched to confirm that at least one of the given
   * property keys is either not present or not strictly equal to the given
   * property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notInclude([obj1, obj2], {a: 1});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.notInclude,true).not.include(inc);};/**
   * ### .deepInclude(haystack, needle, [message])
   *
   * Asserts that \`haystack\` includes \`needle\`. Can be used to assert the
   * inclusion of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.deepInclude([obj1, obj2], {a: 1});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
   *
   * @name deepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.deepInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.deepInclude,true).deep.include(inc);};/**
   * ### .notDeepInclude(haystack, needle, [message])
   *
   * Asserts that \`haystack\` does not include \`needle\`. Can be used to assert
   * the absence of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notDeepInclude([obj1, obj2], {a: 9});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
   *
   * @name notDeepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notDeepInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.notDeepInclude,true).not.deep.include(inc);};/**
   * ### .nestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.[b]': 'x'});
   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'x'});
   *
   * @name nestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.nestedInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.nestedInclude,true).nested.include(inc);};/**
   * ### .notNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.b': 'y'});
   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'y'});
   *
   * @name notNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notNestedInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.notNestedInclude,true).not.nested.include(inc);};/**
   * ### .deepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {x: 1}});
   *
   * @name deepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.deepNestedInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.deepNestedInclude,true).deep.nested.include(inc);};/**
   * ### .notDeepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {y: 2}});
   *
   * @name notDeepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notDeepNestedInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.notDeepNestedInclude,true).not.deep.nested.include(inc);};/**
   * ### .ownInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     assert.ownInclude({ a: 1 }, { a: 1 });
   *
   * @name ownInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.ownInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.ownInclude,true).own.include(inc);};/**
   * ### .notOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     assert.notOwnInclude({ a: 1 }, { b: 2 });
   *
   * @name notOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notOwnInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.notOwnInclude,true).not.own.include(inc);};/**
   * ### .deepOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties and checking for deep equality.
   *
   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
   *
   * @name deepOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.deepOwnInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.deepOwnInclude,true).deep.own.include(inc);};/**
  * ### .notDeepOwnInclude(haystack, needle, [message])
  *
  * Asserts that 'haystack' includes 'needle'.
  * Can be used to assert the absence of a subset of properties in an
  * object while ignoring inherited properties and checking for deep equality.
  *
  *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
  *
  * @name notDeepOwnInclude
  * @param {Object} haystack
  * @param {Object} needle
  * @param {String} message
  * @namespace Assert
  * @api public
  */assert.notDeepOwnInclude=function(exp,inc,msg){new Assertion(exp,msg,assert.notDeepOwnInclude,true).not.deep.own.include(inc);};/**
   * ### .match(value, regexp, [message])
   *
   * Asserts that \`value\` matches the regular expression \`regexp\`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.match=function(exp,re,msg){new Assertion(exp,msg,assert.match,true).to.match(re);};/**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that \`value\` does not match the regular expression \`regexp\`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notMatch=function(exp,re,msg){new Assertion(exp,msg,assert.notMatch,true).to.not.match(re);};/**
   * ### .property(object, property, [message])
   *
   * Asserts that \`object\` has a direct or inherited property named by
   * \`property\`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *     assert.property({ tea: { green: 'matcha' }}, 'toString');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.property=function(obj,prop,msg){new Assertion(obj,msg,assert.property,true).to.have.property(prop);};/**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that \`object\` does _not_ have a direct or inherited property named
   * by \`property\`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notProperty=function(obj,prop,msg){new Assertion(obj,msg,assert.notProperty,true).to.not.have.property(prop);};/**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` has a direct or inherited property named by
   * \`property\` with a value given by \`value\`. Uses a strict equality check
   * (===).
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.propertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.propertyVal,true).to.have.property(prop,val);};/**
   * ### .notPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` does _not_ have a direct or inherited property named
   * by \`property\` with value given by \`value\`. Uses a strict equality check
   * (===).
   *
   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
   *
   * @name notPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.notPropertyVal,true).to.not.have.property(prop,val);};/**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` has a direct or inherited property named by
   * \`property\` with a value given by \`value\`. Uses a deep equality check.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.deepPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.deepPropertyVal,true).to.have.deep.property(prop,val);};/**
   * ### .notDeepPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` does _not_ have a direct or inherited property named
   * by \`property\` with value given by \`value\`. Uses a deep equality check.
   *
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *
   * @name notDeepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notDeepPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.notDeepPropertyVal,true).to.not.have.deep.property(prop,val);};/**
   * ### .ownProperty(object, property, [message])
   *
   * Asserts that \`object\` has a direct property named by \`property\`. Inherited
   * properties aren't checked.
   *
   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name ownProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */assert.ownProperty=function(obj,prop,msg){new Assertion(obj,msg,assert.ownProperty,true).to.have.own.property(prop);};/**
   * ### .notOwnProperty(object, property, [message])
   *
   * Asserts that \`object\` does _not_ have a direct property named by
   * \`property\`. Inherited properties aren't checked.
   *
   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');
   *     assert.notOwnProperty({}, 'toString');
   *
   * @name notOwnProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */assert.notOwnProperty=function(obj,prop,msg){new Assertion(obj,msg,assert.notOwnProperty,true).to.not.have.own.property(prop);};/**
   * ### .ownPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` has a direct property named by \`property\` and a value
   * equal to the provided \`value\`. Uses a strict equality check (===).
   * Inherited properties aren't checked.
   *
   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');
   *
   * @name ownPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */assert.ownPropertyVal=function(obj,prop,value,msg){new Assertion(obj,msg,assert.ownPropertyVal,true).to.have.own.property(prop,value);};/**
   * ### .notOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` does _not_ have a direct property named by \`property\`
   * with a value equal to the provided \`value\`. Uses a strict equality check
   * (===). Inherited properties aren't checked.
   *
   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');
   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */assert.notOwnPropertyVal=function(obj,prop,value,msg){new Assertion(obj,msg,assert.notOwnPropertyVal,true).to.not.have.own.property(prop,value);};/**
   * ### .deepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` has a direct property named by \`property\` and a value
   * equal to the provided \`value\`. Uses a deep equality check. Inherited
   * properties aren't checked.
   *
   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */assert.deepOwnPropertyVal=function(obj,prop,value,msg){new Assertion(obj,msg,assert.deepOwnPropertyVal,true).to.have.deep.own.property(prop,value);};/**
   * ### .notDeepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` does _not_ have a direct property named by \`property\`
   * with a value equal to the provided \`value\`. Uses a deep equality check.
   * Inherited properties aren't checked.
   *
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notDeepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */assert.notDeepOwnPropertyVal=function(obj,prop,value,msg){new Assertion(obj,msg,assert.notDeepOwnPropertyVal,true).to.not.have.deep.own.property(prop,value);};/**
   * ### .nestedProperty(object, property, [message])
   *
   * Asserts that \`object\` has a direct or inherited property named by
   * \`property\`, which can be a string using dot- and bracket-notation for
   * nested reference.
   *
   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name nestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.nestedProperty=function(obj,prop,msg){new Assertion(obj,msg,assert.nestedProperty,true).to.have.nested.property(prop);};/**
   * ### .notNestedProperty(object, property, [message])
   *
   * Asserts that \`object\` does _not_ have a property named by \`property\`, which
   * can be a string using dot- and bracket-notation for nested reference. The
   * property cannot exist on the object nor anywhere in its prototype chain.
   *
   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notNestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notNestedProperty=function(obj,prop,msg){new Assertion(obj,msg,assert.notNestedProperty,true).to.not.have.nested.property(prop);};/**
   * ### .nestedPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` has a property named by \`property\` with value given
   * by \`value\`. \`property\` can use dot- and bracket-notation for nested
   * reference. Uses a strict equality check (===).
   *
   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name nestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.nestedPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.nestedPropertyVal,true).to.have.nested.property(prop,val);};/**
   * ### .notNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` does _not_ have a property named by \`property\` with
   * value given by \`value\`. \`property\` can use dot- and bracket-notation for
   * nested reference. Uses a strict equality check (===).
   *
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
   *
   * @name notNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notNestedPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.notNestedPropertyVal,true).to.not.have.nested.property(prop,val);};/**
   * ### .deepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` has a property named by \`property\` with a value given
   * by \`value\`. \`property\` can use dot- and bracket-notation for nested
   * reference. Uses a deep equality check.
   *
   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
   *
   * @name deepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.deepNestedPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.deepNestedPropertyVal,true).to.have.deep.nested.property(prop,val);};/**
   * ### .notDeepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that \`object\` does _not_ have a property named by \`property\` with
   * value given by \`value\`. \`property\` can use dot- and bracket-notation for
   * nested reference. Uses a deep equality check.
   *
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
   *
   * @name notDeepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notDeepNestedPropertyVal=function(obj,prop,val,msg){new Assertion(obj,msg,assert.notDeepNestedPropertyVal,true).to.not.have.deep.nested.property(prop,val);};/**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that \`object\` has a \`length\` or \`size\` with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *     assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');
   *     assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.lengthOf=function(exp,len,msg){new Assertion(exp,msg,assert.lengthOf,true).to.have.lengthOf(len);};/**
   * ### .hasAnyKeys(object, [keys], [message])
   *
   * Asserts that \`object\` has at least one of the \`keys\` provided.
   * You can also provide a single object instead of a \`keys\` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});
   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAnyKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.hasAnyKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.hasAnyKeys,true).to.have.any.keys(keys);};/**
   * ### .hasAllKeys(object, [keys], [message])
   *
   * Asserts that \`object\` has all and only all of the \`keys\` provided.
   * You can also provide a single object instead of a \`keys\` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.hasAllKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.hasAllKeys,true).to.have.all.keys(keys);};/**
   * ### .containsAllKeys(object, [keys], [message])
   *
   * Asserts that \`object\` has all of the \`keys\` provided but may have more keys not listed.
   * You can also provide a single object instead of a \`keys\` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name containsAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.containsAllKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.containsAllKeys,true).to.contain.all.keys(keys);};/**
   * ### .doesNotHaveAnyKeys(object, [keys], [message])
   *
   * Asserts that \`object\` has none of the \`keys\` provided.
   * You can also provide a single object instead of a \`keys\` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAnyKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.doesNotHaveAnyKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.doesNotHaveAnyKeys,true).to.not.have.any.keys(keys);};/**
   * ### .doesNotHaveAllKeys(object, [keys], [message])
   *
   * Asserts that \`object\` does not have at least one of the \`keys\` provided.
   * You can also provide a single object instead of a \`keys\` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.doesNotHaveAllKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.doesNotHaveAllKeys,true).to.not.have.all.keys(keys);};/**
   * ### .hasAnyDeepKeys(object, [keys], [message])
   *
   * Asserts that \`object\` has at least one of the \`keys\` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a \`keys\` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name hasAnyDeepKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.hasAnyDeepKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.hasAnyDeepKeys,true).to.have.any.deep.keys(keys);};/**
    * ### .hasAllDeepKeys(object, [keys], [message])
    *
    * Asserts that \`object\` has all and only all of the \`keys\` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a \`keys\` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name hasAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */assert.hasAllDeepKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.hasAllDeepKeys,true).to.have.all.deep.keys(keys);};/**
    * ### .containsAllDeepKeys(object, [keys], [message])
    *
    * Asserts that \`object\` contains all of the \`keys\` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a \`keys\` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name containsAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */assert.containsAllDeepKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.containsAllDeepKeys,true).to.contain.all.deep.keys(keys);};/**
    * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])
    *
    * Asserts that \`object\` has none of the \`keys\` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a \`keys\` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAnyDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */assert.doesNotHaveAnyDeepKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.doesNotHaveAnyDeepKeys,true).to.not.have.any.deep.keys(keys);};/**
    * ### .doesNotHaveAllDeepKeys(object, [keys], [message])
    *
    * Asserts that \`object\` does not have at least one of the \`keys\` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a \`keys\` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */assert.doesNotHaveAllDeepKeys=function(obj,keys,msg){new Assertion(obj,msg,assert.doesNotHaveAllDeepKeys,true).to.not.have.all.deep.keys(keys);};/**
    * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])
    *
    * If \`errorLike\` is an \`Error\` constructor, asserts that \`fn\` will throw an error that is an
    * instance of \`errorLike\`.
    * If \`errorLike\` is an \`Error\` instance, asserts that the error thrown is the same
    * instance as \`errorLike\`.
    * If \`errMsgMatcher\` is provided, it also asserts that the error thrown will have a
    * message matching \`errMsgMatcher\`.
    *
    *     assert.throws(fn, 'Error thrown must have this msg');
    *     assert.throws(fn, /Error thrown must have a msg that matches this/);
    *     assert.throws(fn, ReferenceError);
    *     assert.throws(fn, errorInstance);
    *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
    *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
    *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
    *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
    *
    * @name throws
    * @alias throw
    * @alias Throw
    * @param {Function} fn
    * @param {ErrorConstructor|Error} errorLike
    * @param {RegExp|String} errMsgMatcher
    * @param {String} message
    * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
    * @namespace Assert
    * @api public
    */assert.throws=function(fn,errorLike,errMsgMatcher,msg){if('string'===typeof errorLike||errorLike instanceof RegExp){errMsgMatcher=errorLike;errorLike=null;}var assertErr=new Assertion(fn,msg,assert.throws,true).to.throw(errorLike,errMsgMatcher);return flag(assertErr,'object');};/**
   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])
   *
   * If \`errorLike\` is an \`Error\` constructor, asserts that \`fn\` will _not_ throw an error that is an
   * instance of \`errorLike\`.
   * If \`errorLike\` is an \`Error\` instance, asserts that the error thrown is _not_ the same
   * instance as \`errorLike\`.
   * If \`errMsgMatcher\` is provided, it also asserts that the error thrown will _not_ have a
   * message matching \`errMsgMatcher\`.
   *
   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);
   *     assert.doesNotThrow(fn, Error);
   *     assert.doesNotThrow(fn, errorInstance);
   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');
   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
   *     assert.doesNotThrow(fn, Error, /Error must not match this/);
   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
   *
   * @name doesNotThrow
   * @param {Function} fn
   * @param {ErrorConstructor} errorLike
   * @param {RegExp|String} errMsgMatcher
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */assert.doesNotThrow=function(fn,errorLike,errMsgMatcher,msg){if('string'===typeof errorLike||errorLike instanceof RegExp){errMsgMatcher=errorLike;errorLike=null;}new Assertion(fn,msg,assert.doesNotThrow,true).to.not.throw(errorLike,errMsgMatcher);};/**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using \`operator\`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.operator=function(val,operator,val2,msg){var ok;switch(operator){case'==':ok=val==val2;break;case'===':ok=val===val2;break;case'>':ok=val>val2;break;case'>=':ok=val>=val2;break;case'<':ok=val<val2;break;case'<=':ok=val<=val2;break;case'!=':ok=val!=val2;break;case'!==':ok=val!==val2;break;default:msg=msg?msg+': ':msg;throw new chai.AssertionError(msg+'Invalid operator "'+operator+'"',undefined,assert.operator);}var test=new Assertion(ok,msg,assert.operator,true);test.assert(true===flag(test,'object'),'expected '+util.inspect(val)+' to be '+operator+' '+util.inspect(val2),'expected '+util.inspect(val)+' to not be '+operator+' '+util.inspect(val2));};/**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal \`expected\`, to within a +/- \`delta\` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.closeTo=function(act,exp,delta,msg){new Assertion(act,msg,assert.closeTo,true).to.be.closeTo(exp,delta);};/**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal \`expected\`, to within a +/- \`delta\` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.approximately=function(act,exp,delta,msg){new Assertion(act,msg,assert.approximately,true).to.be.approximately(exp,delta);};/**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` have the same members in any order. Uses a
   * strict equality check (===).
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.sameMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.sameMembers,true).to.have.same.members(set2);};/**
   * ### .notSameMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` don't have the same members in any order.
   * Uses a strict equality check (===).
   *
   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
   *
   * @name notSameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notSameMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.notSameMembers,true).to.not.have.same.members(set2);};/**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` have the same members in any order. Uses a
   * deep equality check.
   *
   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.sameDeepMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.sameDeepMembers,true).to.have.same.deep.members(set2);};/**
   * ### .notSameDeepMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` don't have the same members in any order.
   * Uses a deep equality check.
   *
   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
   *
   * @name notSameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notSameDeepMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.notSameDeepMembers,true).to.not.have.same.deep.members(set2);};/**
   * ### .sameOrderedMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` have the same members in the same order.
   * Uses a strict equality check (===).
   *
   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
   *
   * @name sameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.sameOrderedMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.sameOrderedMembers,true).to.have.same.ordered.members(set2);};/**
   * ### .notSameOrderedMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` don't have the same members in the same
   * order. Uses a strict equality check (===).
   *
   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
   *
   * @name notSameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notSameOrderedMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.notSameOrderedMembers,true).to.not.have.same.ordered.members(set2);};/**
   * ### .sameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` have the same members in the same order.
   * Uses a deep equality check.
   *
   *     assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
   *
   * @name sameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.sameDeepOrderedMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.sameDeepOrderedMembers,true).to.have.same.deep.ordered.members(set2);};/**
   * ### .notSameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that \`set1\` and \`set2\` don't have the same members in the same
   * order. Uses a deep equality check.
   *
   *     assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
   *     assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
   *
   * @name notSameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notSameDeepOrderedMembers=function(set1,set2,msg){new Assertion(set1,msg,assert.notSameDeepOrderedMembers,true).to.not.have.same.deep.ordered.members(set2);};/**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` is included in \`superset\` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.includeMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.includeMembers,true).to.include.members(subset);};/**
   * ### .notIncludeMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` isn't included in \`superset\` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
   *
   * @name notIncludeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notIncludeMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.notIncludeMembers,true).to.not.include.members(subset);};/**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` is included in \`superset\` in any order. Uses a deep
   * equality check. Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.includeDeepMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.includeDeepMembers,true).to.include.deep.members(subset);};/**
   * ### .notIncludeDeepMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` isn't included in \`superset\` in any order. Uses a
   * deep equality check. Duplicates are ignored.
   *
   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
   *
   * @name notIncludeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notIncludeDeepMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.notIncludeDeepMembers,true).to.not.include.deep.members(subset);};/**
   * ### .includeOrderedMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` is included in \`superset\` in the same order
   * beginning with the first element in \`superset\`. Uses a strict equality
   * check (===).
   *
   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
   *
   * @name includeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.includeOrderedMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.includeOrderedMembers,true).to.include.ordered.members(subset);};/**
   * ### .notIncludeOrderedMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` isn't included in \`superset\` in the same order
   * beginning with the first element in \`superset\`. Uses a strict equality
   * check (===).
   *
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
   *
   * @name notIncludeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notIncludeOrderedMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.notIncludeOrderedMembers,true).to.not.include.ordered.members(subset);};/**
   * ### .includeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` is included in \`superset\` in the same order
   * beginning with the first element in \`superset\`. Uses a deep equality
   * check.
   *
   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
   *
   * @name includeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.includeDeepOrderedMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.includeDeepOrderedMembers,true).to.include.deep.ordered.members(subset);};/**
   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that \`subset\` isn't included in \`superset\` in the same order
   * beginning with the first element in \`superset\`. Uses a deep equality
   * check.
   *
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
   *
   * @name notIncludeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.notIncludeDeepOrderedMembers=function(superset,subset,msg){new Assertion(superset,msg,assert.notIncludeDeepOrderedMembers,true).to.not.include.deep.ordered.members(subset);};/**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value \`inList\` appears in the flat array \`list\`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */assert.oneOf=function(inList,list,msg){new Assertion(inList,msg,assert.oneOf,true).to.be.oneOf(list);};/**
   * ### .changes(function, object, property, [message])
   *
   * Asserts that a function changes the value of a property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.changes=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==='function'){msg=prop;prop=null;}new Assertion(fn,msg,assert.changes,true).to.change(obj,prop);};/**
  * ### .changesBy(function, object, property, delta, [message])
  *
  * Asserts that a function changes the value of a property by an amount (delta).
  *
  *     var obj = { val: 10 };
  *     var fn = function() { obj.val += 2 };
  *     assert.changesBy(fn, obj, 'val', 2);
  *
  * @name changesBy
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {Number} change amount (delta)
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */assert.changesBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}new Assertion(fn,msg,assert.changesBy,true).to.change(obj,prop).by(delta);};/**
  * ### .doesNotChange(function, object, property, [message])
  *
  * Asserts that a function does not change the value of a property.
  *
  *     var obj = { val: 10 };
  *     var fn = function() { console.log('foo'); };
  *     assert.doesNotChange(fn, obj, 'val');
  *
  * @name doesNotChange
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */assert.doesNotChange=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==='function'){msg=prop;prop=null;}return new Assertion(fn,msg,assert.doesNotChange,true).to.not.change(obj,prop);};/**
   * ### .changesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.changesButNotBy(fn, obj, 'val', 5);
   *
   * @name changesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.changesButNotBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}new Assertion(fn,msg,assert.changesButNotBy,true).to.change(obj,prop).but.not.by(delta);};/**
   * ### .increases(function, object, property, [message])
   *
   * Asserts that a function increases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.increases=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==='function'){msg=prop;prop=null;}return new Assertion(fn,msg,assert.increases,true).to.increase(obj,prop);};/**
   * ### .increasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.increasesBy(fn, obj, 'val', 10);
   *
   * @name increasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.increasesBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}new Assertion(fn,msg,assert.increasesBy,true).to.increase(obj,prop).by(delta);};/**
   * ### .doesNotIncrease(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.doesNotIncrease=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==='function'){msg=prop;prop=null;}return new Assertion(fn,msg,assert.doesNotIncrease,true).to.not.increase(obj,prop);};/**
   * ### .increasesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.increasesButNotBy(fn, obj, 'val', 10);
   *
   * @name increasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.increasesButNotBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}new Assertion(fn,msg,assert.increasesButNotBy,true).to.increase(obj,prop).but.not.by(delta);};/**
   * ### .decreases(function, object, property, [message])
   *
   * Asserts that a function decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.decreases=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==='function'){msg=prop;prop=null;}return new Assertion(fn,msg,assert.decreases,true).to.decrease(obj,prop);};/**
   * ### .decreasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val -= 5 };
   *     assert.decreasesBy(fn, obj, 'val', 5);
   *
   * @name decreasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.decreasesBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}new Assertion(fn,msg,assert.decreasesBy,true).to.decrease(obj,prop).by(delta);};/**
   * ### .doesNotDecrease(function, object, property, [message])
   *
   * Asserts that a function does not decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.doesNotDecrease=function(fn,obj,prop,msg){if(arguments.length===3&&typeof obj==='function'){msg=prop;prop=null;}return new Assertion(fn,msg,assert.doesNotDecrease,true).to.not.decrease(obj,prop);};/**
   * ### .doesNotDecreaseBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);
   *
   * @name doesNotDecreaseBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.doesNotDecreaseBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}return new Assertion(fn,msg,assert.doesNotDecreaseBy,true).to.not.decrease(obj,prop).by(delta);};/**
   * ### .decreasesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreasesButNotBy(fn, obj, 'val', 1);
   *
   * @name decreasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.decreasesButNotBy=function(fn,obj,prop,delta,msg){if(arguments.length===4&&typeof obj==='function'){var tmpMsg=delta;delta=prop;msg=tmpMsg;}else if(arguments.length===3){delta=prop;prop=null;}new Assertion(fn,msg,assert.decreasesButNotBy,true).to.decrease(obj,prop).but.not.by(delta);};/*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */assert.ifError=function(val){if(val){throw val;}};/**
   * ### .isExtensible(object)
   *
   * Asserts that \`object\` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isExtensible=function(obj,msg){new Assertion(obj,msg,assert.isExtensible,true).to.be.extensible;};/**
   * ### .isNotExtensible(object)
   *
   * Asserts that \`object\` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isNotExtensible=function(obj,msg){new Assertion(obj,msg,assert.isNotExtensible,true).to.not.be.extensible;};/**
   * ### .isSealed(object)
   *
   * Asserts that \`object\` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isSealed=function(obj,msg){new Assertion(obj,msg,assert.isSealed,true).to.be.sealed;};/**
   * ### .isNotSealed(object)
   *
   * Asserts that \`object\` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isNotSealed=function(obj,msg){new Assertion(obj,msg,assert.isNotSealed,true).to.not.be.sealed;};/**
   * ### .isFrozen(object)
   *
   * Asserts that \`object\` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isFrozen=function(obj,msg){new Assertion(obj,msg,assert.isFrozen,true).to.be.frozen;};/**
   * ### .isNotFrozen(object)
   *
   * Asserts that \`object\` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isNotFrozen=function(obj,msg){new Assertion(obj,msg,assert.isNotFrozen,true).to.not.be.frozen;};/**
   * ### .isEmpty(target)
   *
   * Asserts that the target does not contain any values.
   * For arrays and strings, it checks the \`length\` property.
   * For \`Map\` and \`Set\` instances, it checks the \`size\` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isEmpty([]);
   *     assert.isEmpty('');
   *     assert.isEmpty(new Map);
   *     assert.isEmpty({});
   *
   * @name isEmpty
   * @alias empty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isEmpty=function(val,msg){new Assertion(val,msg,assert.isEmpty,true).to.be.empty;};/**
   * ### .isNotEmpty(target)
   *
   * Asserts that the target contains values.
   * For arrays and strings, it checks the \`length\` property.
   * For \`Map\` and \`Set\` instances, it checks the \`size\` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isNotEmpty([1, 2]);
   *     assert.isNotEmpty('34');
   *     assert.isNotEmpty(new Set([5, 6]));
   *     assert.isNotEmpty({ key: 7 });
   *
   * @name isNotEmpty
   * @alias notEmpty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */assert.isNotEmpty=function(val,msg){new Assertion(val,msg,assert.isNotEmpty,true).to.not.be.empty;};/*!
   * Aliases.
   */(function alias(name,as){assert[as]=assert[name];return alias;})('isOk','ok')('isNotOk','notOk')('throws','throw')('throws','Throw')('isExtensible','extensible')('isNotExtensible','notExtensible')('isSealed','sealed')('isNotSealed','notSealed')('isFrozen','frozen')('isNotFrozen','notFrozen')('isEmpty','empty')('isNotEmpty','notEmpty');};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */var hasRequiredChai;function requireChai(){if(hasRequiredChai)return chai$3;hasRequiredChai=1;(function(exports){var used=[];/*!
     * Chai version
     */exports.version='4.3.8';/*!
     * Assertion Error
     */exports.AssertionError=assertionError;/*!
     * Utils for plugins (not exported)
     */var util=requireUtils();/**
     * # .use(function)
     *
     * Provides a way to extend the internals of Chai.
     *
     * @param {Function}
     * @returns {this} for chaining
     * @api public
     */exports.use=function(fn){if(!~used.indexOf(fn)){fn(exports,util);used.push(fn);}return exports;};/*!
     * Utility Functions
     */exports.util=util;/*!
     * Configuration
     */var config=config$5;exports.config=config;/*!
     * Primary \`Assertion\` prototype
     */var assertion$1=assertion;exports.use(assertion$1);/*!
     * Core Assertions
     */var core=assertions;exports.use(core);/*!
     * Expect interface
     */var expect=expect$1;exports.use(expect);/*!
     * Should interface
     */var should$1=should;exports.use(should$1);/*!
     * Assert interface
     */var assert=assert$1;exports.use(assert);})(chai$3);return chai$3;}var chai$1=requireChai();const chai$2=/*@__PURE__*/getDefaultExportFromCjs$2(chai$1);const expect=chai$2.expect;chai$2.version;chai$2.Assertion;chai$2.AssertionError;const util=chai$2.util;chai$2.config;const use=chai$2.use;chai$2.should;const assert=chai$2.assert;chai$2.core;var commonjsGlobal=typeof globalThis!=='undefined'?globalThis:typeof window!=='undefined'?window:typeof global!=='undefined'?global:typeof self!=='undefined'?self:{};function getDefaultExportFromCjs$1(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,'default')?x['default']:x;}// src/utils.ts
function R(e,t){if(!e)throw new Error(t);}function u(e,t){return typeof t===e;}function b(e){return e instanceof Promise;}function f(e,t,n){Object.defineProperty(e,t,n);}function i(e,t,n){Object.defineProperty(e,t,{value:n});}// src/constants.ts
var c=Symbol.for("tinyspy:spy");// src/internal.ts
var g=/* @__PURE__ */new Set(),C=e=>{e.called=!1,e.callCount=0,e.calls=[],e.results=[],e.next=[];},M=e=>(f(e,c,{value:{reset:()=>C(e[c])}}),e[c]),A=e=>e[c]||M(e);function I(e){R(u("function",e)||u("undefined",e),"cannot spy on a non-function value");let t=function(...s){let r=A(t);r.called=!0,r.callCount++,r.calls.push(s);let m=r.next.shift();if(m){r.results.push(m);let _m=_slicedToArray(m,2),l=_m[0],o=_m[1];if(l==="ok")return o;throw o;}let p,d="ok";if(r.impl)try{new.target?p=Reflect.construct(r.impl,s,new.target):p=r.impl.apply(this,s),d="ok";}catch(l){throw p=l,d="error",r.results.push([d,l]),l;}let a=[d,p];if(b(p)){let l=p.then(o=>a[1]=o).catch(o=>{throw a[0]="error",a[1]=o,o;});Object.assign(l,p),p=l;}return r.results.push(a),p;};i(t,"_isMockFunction",!0),i(t,"length",e?e.length:0),i(t,"name",e&&e.name||"spy");let n=A(t);return n.reset(),n.impl=e,t;}// src/spyOn.ts
var k=(e,t)=>Object.getOwnPropertyDescriptor(e,t),P=(e,t)=>{t!=null&&typeof t=="function"&&t.prototype!=null&&Object.setPrototypeOf(e.prototype,t.prototype);};function E(e,t,n){R(!u("undefined",e),"spyOn could not find an object to spy upon"),R(u("object",e)||u("function",e),"cannot spyOn on a primitive value");let _ref9=(()=>{if(!u("object",t))return[t,"value"];if("getter"in t&&"setter"in t)throw new Error("cannot spy on both getter and setter");if("getter"in t)return[t.getter,"get"];if("setter"in t)return[t.setter,"set"];throw new Error("specify getter or setter to spy on");})(),_ref10=_slicedToArray(_ref9,2),s=_ref10[0],r=_ref10[1],m=k(e,s),p=Object.getPrototypeOf(e),d=p&&k(p,s),a=m||d;R(a||s in e,\`\${String(s)} does not exist\`);let l=!1;r==="value"&&a&&!a.value&&a.get&&(r="get",l=!0,n=a.get());let o;a?o=a[r]:r!=="value"?o=()=>e[s]:o=e[s],n||(n=o);let y=I(n);r==="value"&&P(y,o);let O=h=>{let _ref11=a||{configurable:!0,writable:!0},G=_ref11.value,w=_objectWithoutProperties(_ref11,_excluded2);r!=="value"&&delete w.writable,w[r]=h,f(e,s,w);},K=()=>a?f(e,s,a):O(o),T=y[c];return i(T,"restore",K),i(T,"getOriginal",()=>l?o():o),i(T,"willCall",h=>(T.impl=h,y)),O(l?()=>(P(y,n),y):y),g.add(y),y;}const mocks=/* @__PURE__ */new Set();function isMockFunction(fn2){return typeof fn2==="function"&&"_isMockFunction"in fn2&&fn2._isMockFunction;}function spyOn(obj,method,accessType){const dictionary={get:"getter",set:"setter"};const objMethod=accessType?{[dictionary[accessType]]:method}:method;const stub=E(obj,objMethod);return enhanceSpy(stub);}let callOrder=0;function enhanceSpy(spy){const stub=spy;let implementation;let instances=[];let invocations=[];const state=A(spy);const mockContext={get calls(){return state.calls;},get instances(){return instances;},get invocationCallOrder(){return invocations;},get results(){return state.results.map(([callType,value])=>{const type=callType==="error"?"throw":"return";return{type,value};});},get lastCall(){return state.calls[state.calls.length-1];}};let onceImplementations=[];let implementationChangedTemporarily=false;function mockCall(...args){instances.push(this);invocations.push(++callOrder);const impl=implementationChangedTemporarily?implementation:onceImplementations.shift()||implementation||state.getOriginal()||(()=>{});return impl.apply(this,args);}let name=stub.name;stub.getMockName=()=>name||"vi.fn()";stub.mockName=n=>{name=n;return stub;};stub.mockClear=()=>{state.reset();instances=[];invocations=[];return stub;};stub.mockReset=()=>{stub.mockClear();implementation=()=>void 0;onceImplementations=[];return stub;};stub.mockRestore=()=>{stub.mockReset();state.restore();implementation=void 0;return stub;};stub.getMockImplementation=()=>implementation;stub.mockImplementation=fn2=>{implementation=fn2;state.willCall(mockCall);return stub;};stub.mockImplementationOnce=fn2=>{onceImplementations.push(fn2);return stub;};function withImplementation(fn2,cb){const originalImplementation=implementation;implementation=fn2;state.willCall(mockCall);implementationChangedTemporarily=true;const reset=()=>{implementation=originalImplementation;implementationChangedTemporarily=false;};const result=cb();if(result instanceof Promise){return result.then(()=>{reset();return stub;});}reset();return stub;}stub.withImplementation=withImplementation;stub.mockReturnThis=()=>stub.mockImplementation(function(){return this;});stub.mockReturnValue=val=>stub.mockImplementation(()=>val);stub.mockReturnValueOnce=val=>stub.mockImplementationOnce(()=>val);stub.mockResolvedValue=val=>stub.mockImplementation(()=>Promise.resolve(val));stub.mockResolvedValueOnce=val=>stub.mockImplementationOnce(()=>Promise.resolve(val));stub.mockRejectedValue=val=>stub.mockImplementation(()=>Promise.reject(val));stub.mockRejectedValueOnce=val=>stub.mockImplementationOnce(()=>Promise.reject(val));Object.defineProperty(stub,"mock",{get:()=>mockContext});state.willCall(mockCall);mocks.add(stub);return stub;}function fn(implementation){const enhancedSpy=enhanceSpy(E({spy:implementation||(()=>{})},"spy"));if(implementation)enhancedSpy.mockImplementation(implementation);return enhancedSpy;}const MATCHERS_OBJECT$1=Symbol.for("matchers-object");const JEST_MATCHERS_OBJECT$1=Symbol.for("$$jest-matchers-object");const GLOBAL_EXPECT$1=Symbol.for("expect-global");const ASYMMETRIC_MATCHERS_OBJECT$1=Symbol.for("asymmetric-matchers-object");if(!Object.prototype.hasOwnProperty.call(globalThis,MATCHERS_OBJECT$1)){const globalState=/* @__PURE__ */new WeakMap();const matchers=/* @__PURE__ */Object.create(null);const customEqualityTesters=[];const assymetricMatchers=/* @__PURE__ */Object.create(null);Object.defineProperty(globalThis,MATCHERS_OBJECT$1,{get:()=>globalState});Object.defineProperty(globalThis,JEST_MATCHERS_OBJECT$1,{configurable:true,get:()=>({state:globalState.get(globalThis[GLOBAL_EXPECT$1]),matchers,customEqualityTesters})});Object.defineProperty(globalThis,ASYMMETRIC_MATCHERS_OBJECT$1,{get:()=>assymetricMatchers});}function getState(expect){return globalThis[MATCHERS_OBJECT$1].get(expect);}function setState(state,expect){const map=globalThis[MATCHERS_OBJECT$1];const current=map.get(expect)||{};Object.assign(current,state);map.set(expect,current);}function getMatcherUtils(){const c=()=>getColors();const EXPECTED_COLOR=c().green;const RECEIVED_COLOR=c().red;const INVERTED_COLOR=c().inverse;const BOLD_WEIGHT=c().bold;const DIM_COLOR=c().dim;function matcherHint(matcherName,received="received",expected="expected",options={}){const _options$comment=options.comment,comment=_options$comment===void 0?"":_options$comment,_options$isDirectExpe=options.isDirectExpectCall,isDirectExpectCall=_options$isDirectExpe===void 0?false:_options$isDirectExpe,_options$isNot=options.isNot,isNot=_options$isNot===void 0?false:_options$isNot,_options$promise=options.promise,promise=_options$promise===void 0?"":_options$promise,_options$secondArgume=options.secondArgument,secondArgument=_options$secondArgume===void 0?"":_options$secondArgume,_options$expectedColo=options.expectedColor,expectedColor=_options$expectedColo===void 0?EXPECTED_COLOR:_options$expectedColo,_options$receivedColo=options.receivedColor,receivedColor=_options$receivedColo===void 0?RECEIVED_COLOR:_options$receivedColo,_options$secondArgume2=options.secondArgumentColor,secondArgumentColor=_options$secondArgume2===void 0?EXPECTED_COLOR:_options$secondArgume2;let hint="";let dimString="expect";if(!isDirectExpectCall&&received!==""){hint+=DIM_COLOR(\`\${dimString}(\`)+receivedColor(received);dimString=")";}if(promise!==""){hint+=DIM_COLOR(\`\${dimString}.\`)+promise;dimString="";}if(isNot){hint+=\`\${DIM_COLOR(\`\${dimString}.\`)}not\`;dimString="";}if(matcherName.includes(".")){dimString+=matcherName;}else{hint+=DIM_COLOR(\`\${dimString}.\`)+matcherName;dimString="";}if(expected===""){dimString+="()";}else{hint+=DIM_COLOR(\`\${dimString}(\`)+expectedColor(expected);if(secondArgument)hint+=DIM_COLOR(", ")+secondArgumentColor(secondArgument);dimString=")";}if(comment!=="")dimString+=\` // \${comment}\`;if(dimString!=="")hint+=DIM_COLOR(dimString);return hint;}const SPACE_SYMBOL="\\xB7";const replaceTrailingSpaces=text=>text.replace(/\\s+$/gm,spaces=>SPACE_SYMBOL.repeat(spaces.length));const printReceived=object=>RECEIVED_COLOR(replaceTrailingSpaces(stringify(object)));const printExpected=value=>EXPECTED_COLOR(replaceTrailingSpaces(stringify(value)));return{EXPECTED_COLOR,RECEIVED_COLOR,INVERTED_COLOR,BOLD_WEIGHT,DIM_COLOR,matcherHint,printReceived,printExpected};}function addCustomEqualityTesters(newTesters){if(!Array.isArray(newTesters)){throw new TypeError(\`expect.customEqualityTesters: Must be set to an array of Testers. Was given "\${getType$2(newTesters)}"\`);}globalThis[JEST_MATCHERS_OBJECT$1].customEqualityTesters.push(...newTesters);}function getCustomEqualityTesters(){return globalThis[JEST_MATCHERS_OBJECT$1].customEqualityTesters;}function equals(a,b,customTesters,strictCheck){customTesters=customTesters||[];return eq(a,b,[],[],customTesters,strictCheck?hasKey:hasDefinedKey);}function isAsymmetric(obj){return!!obj&&typeof obj==="object"&&"asymmetricMatch"in obj&&isA("Function",obj.asymmetricMatch);}function asymmetricMatch(a,b){const asymmetricA=isAsymmetric(a);const asymmetricB=isAsymmetric(b);if(asymmetricA&&asymmetricB)return void 0;if(asymmetricA)return a.asymmetricMatch(b);if(asymmetricB)return b.asymmetricMatch(a);}function eq(a,b,aStack,bStack,customTesters,hasKey2){let result=true;const asymmetricResult=asymmetricMatch(a,b);if(asymmetricResult!==void 0)return asymmetricResult;const testerContext={equals};for(let i=0;i<customTesters.length;i++){const customTesterResult=customTesters[i].call(testerContext,a,b,customTesters);if(customTesterResult!==void 0)return customTesterResult;}if(a instanceof Error&&b instanceof Error)return a.message===b.message;if(typeof URL==="function"&&a instanceof URL&&b instanceof URL)return a.href===b.href;if(Object.is(a,b))return true;if(a===null||b===null)return a===b;const className=Object.prototype.toString.call(a);if(className!==Object.prototype.toString.call(b))return false;switch(className){case"[object Boolean]":case"[object String]":case"[object Number]":if(typeof a!==typeof b){return false;}else if(typeof a!=="object"&&typeof b!=="object"){return Object.is(a,b);}else{return Object.is(a.valueOf(),b.valueOf());}case"[object Date]":{const numA=+a;const numB=+b;return numA===numB||Number.isNaN(numA)&&Number.isNaN(numB);}case"[object RegExp]":return a.source===b.source&&a.flags===b.flags;}if(typeof a!=="object"||typeof b!=="object")return false;if(isDomNode(a)&&isDomNode(b))return a.isEqualNode(b);let length=aStack.length;while(length--){if(aStack[length]===a)return bStack[length]===b;else if(bStack[length]===b)return false;}aStack.push(a);bStack.push(b);if(className==="[object Array]"&&a.length!==b.length)return false;const aKeys=keys(a,hasKey2);let key;let size=aKeys.length;if(keys(b,hasKey2).length!==size)return false;while(size--){key=aKeys[size];result=hasKey2(b,key)&&eq(a[key],b[key],aStack,bStack,customTesters,hasKey2);if(!result)return false;}aStack.pop();bStack.pop();return result;}function keys(obj,hasKey2){const keys2=[];for(const key in obj){if(hasKey2(obj,key))keys2.push(key);}return keys2.concat(Object.getOwnPropertySymbols(obj).filter(symbol=>Object.getOwnPropertyDescriptor(obj,symbol).enumerable));}function hasDefinedKey(obj,key){return hasKey(obj,key)&&obj[key]!==void 0;}function hasKey(obj,key){return Object.prototype.hasOwnProperty.call(obj,key);}function isA(typeName,value){return Object.prototype.toString.apply(value)===\`[object \${typeName}]\`;}function isDomNode(obj){return obj!==null&&typeof obj==="object"&&"nodeType"in obj&&typeof obj.nodeType==="number"&&"nodeName"in obj&&typeof obj.nodeName==="string"&&"isEqualNode"in obj&&typeof obj.isEqualNode==="function";}const IS_KEYED_SENTINEL="@@__IMMUTABLE_KEYED__@@";const IS_SET_SENTINEL="@@__IMMUTABLE_SET__@@";const IS_ORDERED_SENTINEL="@@__IMMUTABLE_ORDERED__@@";function isImmutableUnorderedKeyed(maybeKeyed){return!!(maybeKeyed&&maybeKeyed[IS_KEYED_SENTINEL]&&!maybeKeyed[IS_ORDERED_SENTINEL]);}function isImmutableUnorderedSet(maybeSet){return!!(maybeSet&&maybeSet[IS_SET_SENTINEL]&&!maybeSet[IS_ORDERED_SENTINEL]);}const IteratorSymbol=Symbol.iterator;function hasIterator(object){return!!(object!=null&&object[IteratorSymbol]);}function iterableEquality(a,b,customTesters=[],aStack=[],bStack=[]){if(typeof a!=="object"||typeof b!=="object"||Array.isArray(a)||Array.isArray(b)||!hasIterator(a)||!hasIterator(b))return void 0;if(a.constructor!==b.constructor)return false;let length=aStack.length;while(length--){if(aStack[length]===a)return bStack[length]===b;}aStack.push(a);bStack.push(b);const filteredCustomTesters=[...customTesters.filter(t=>t!==iterableEquality),iterableEqualityWithStack];function iterableEqualityWithStack(a2,b2){return iterableEquality(a2,b2,[...customTesters],[...aStack],[...bStack]);}if(a.size!==void 0){if(a.size!==b.size){return false;}else if(isA("Set",a)||isImmutableUnorderedSet(a)){let allFound=true;for(const aValue of a){if(!b.has(aValue)){let has=false;for(const bValue of b){const isEqual=equals(aValue,bValue,filteredCustomTesters);if(isEqual===true)has=true;}if(has===false){allFound=false;break;}}}aStack.pop();bStack.pop();return allFound;}else if(isA("Map",a)||isImmutableUnorderedKeyed(a)){let allFound=true;for(const aEntry of a){if(!b.has(aEntry[0])||!equals(aEntry[1],b.get(aEntry[0]),filteredCustomTesters)){let has=false;for(const bEntry of b){const matchedKey=equals(aEntry[0],bEntry[0],filteredCustomTesters);let matchedValue=false;if(matchedKey===true)matchedValue=equals(aEntry[1],bEntry[1],filteredCustomTesters);if(matchedValue===true)has=true;}if(has===false){allFound=false;break;}}}aStack.pop();bStack.pop();return allFound;}}const bIterator=b[IteratorSymbol]();for(const aValue of a){const nextB=bIterator.next();if(nextB.done||!equals(aValue,nextB.value,filteredCustomTesters))return false;}if(!bIterator.next().done)return false;const aEntries=Object.entries(a);const bEntries=Object.entries(b);if(!equals(aEntries,bEntries))return false;aStack.pop();bStack.pop();return true;}function hasPropertyInObject(object,key){const shouldTerminate=!object||typeof object!=="object"||object===Object.prototype;if(shouldTerminate)return false;return Object.prototype.hasOwnProperty.call(object,key)||hasPropertyInObject(Object.getPrototypeOf(object),key);}function isObjectWithKeys(a){return isObject$1(a)&&!(a instanceof Error)&&!Array.isArray(a)&&!(a instanceof Date);}function subsetEquality(object,subset,customTesters=[]){const filteredCustomTesters=customTesters.filter(t=>t!==subsetEquality);const subsetEqualityWithContext=(seenReferences=/* @__PURE__ */new WeakMap())=>(object2,subset2)=>{if(!isObjectWithKeys(subset2))return void 0;return Object.keys(subset2).every(key=>{if(subset2[key]!=null&&typeof subset2[key]==="object"){if(seenReferences.has(subset2[key]))return equals(object2[key],subset2[key],filteredCustomTesters);seenReferences.set(subset2[key],true);}const result=object2!=null&&hasPropertyInObject(object2,key)&&equals(object2[key],subset2[key],[...filteredCustomTesters,subsetEqualityWithContext(seenReferences)]);seenReferences.delete(subset2[key]);return result;});};return subsetEqualityWithContext()(object,subset);}function typeEquality(a,b){if(a==null||b==null||a.constructor===b.constructor)return void 0;return false;}function arrayBufferEquality(a,b){let dataViewA=a;let dataViewB=b;if(!(a instanceof DataView&&b instanceof DataView)){if(!(a instanceof ArrayBuffer)||!(b instanceof ArrayBuffer))return void 0;try{dataViewA=new DataView(a);dataViewB=new DataView(b);}catch{return void 0;}}if(dataViewA.byteLength!==dataViewB.byteLength)return false;for(let i=0;i<dataViewA.byteLength;i++){if(dataViewA.getUint8(i)!==dataViewB.getUint8(i))return false;}return true;}function sparseArrayEquality(a,b,customTesters=[]){if(!Array.isArray(a)||!Array.isArray(b))return void 0;const aKeys=Object.keys(a);const bKeys=Object.keys(b);const filteredCustomTesters=customTesters.filter(t=>t!==sparseArrayEquality);return equals(a,b,filteredCustomTesters,true)&&equals(aKeys,bKeys);}function generateToBeMessage(deepEqualityName,expected="#{this}",actual="#{exp}"){const toBeMessage=\`expected \${expected} to be \${actual} // Object.is equality\`;if(["toStrictEqual","toEqual"].includes(deepEqualityName))return\`\${toBeMessage}

If it should pass with deep equality, replace "toBe" with "\${deepEqualityName}"

Expected: \${expected}
Received: serializes to the same string
\`;return toBeMessage;}function pluralize(word,count){return\`\${count} \${word}\${count===1?"":"s"}\`;}function getObjectKeys(object){return[...Object.keys(object),...Object.getOwnPropertySymbols(object).filter(s=>{var _a;return(_a=Object.getOwnPropertyDescriptor(object,s))==null?void 0:_a.enumerable;})];}function getObjectSubset(object,subset,customTesters=[]){let stripped=0;const getObjectSubsetWithContext=(seenReferences=/* @__PURE__ */new WeakMap())=>(object2,subset2)=>{if(Array.isArray(object2)){if(Array.isArray(subset2)&&subset2.length===object2.length){return subset2.map((sub,i)=>getObjectSubsetWithContext(seenReferences)(object2[i],sub));}}else if(object2 instanceof Date){return object2;}else if(isObject$1(object2)&&isObject$1(subset2)){if(equals(object2,subset2,[...customTesters,iterableEquality,subsetEquality])){return subset2;}const trimmed={};seenReferences.set(object2,trimmed);for(const key of getObjectKeys(object2)){if(hasPropertyInObject(subset2,key)){trimmed[key]=seenReferences.has(object2[key])?seenReferences.get(object2[key]):getObjectSubsetWithContext(seenReferences)(object2[key],subset2[key]);}else{if(!seenReferences.has(object2[key])){stripped+=1;if(isObject$1(object2[key]))stripped+=getObjectKeys(object2[key]).length;getObjectSubsetWithContext(seenReferences)(object2[key],subset2[key]);}}}if(getObjectKeys(trimmed).length>0)return trimmed;}return object2;};return{subset:getObjectSubsetWithContext()(object,subset),stripped};}let AsymmetricMatcher$1=class AsymmetricMatcher{constructor(sample,inverse=false){this.sample=sample;this.inverse=inverse;}// should have "jest" to be compatible with its ecosystem
$$typeof=Symbol.for("jest.asymmetricMatcher");getMatcherContext(expect){return _objectSpread(_objectSpread({},getState(expect||globalThis[GLOBAL_EXPECT$1])),{},{equals,isNot:this.inverse,customTesters:getCustomEqualityTesters(),utils:_objectSpread(_objectSpread({},getMatcherUtils()),{},{diff,stringify,iterableEquality,subsetEquality})});}// implement custom chai/loupe inspect for better AssertionError.message formatting
// https://github.com/chaijs/loupe/blob/9b8a6deabcd50adc056a64fb705896194710c5c6/src/index.ts#L29
[Symbol.for("chai/inspect")](options){const result=stringify(this,options.depth,{min:true});if(result.length<=options.truncate)return result;return\`\${this.toString()}{\\u2026}\`;}};class StringContaining extends AsymmetricMatcher$1{constructor(sample,inverse=false){if(!isA("String",sample))throw new Error("Expected is not a string");super(sample,inverse);}asymmetricMatch(other){const result=isA("String",other)&&other.includes(this.sample);return this.inverse?!result:result;}toString(){return\`String\${this.inverse?"Not":""}Containing\`;}getExpectedType(){return"string";}}class Anything extends AsymmetricMatcher$1{asymmetricMatch(other){return other!=null;}toString(){return"Anything";}toAsymmetricMatcher(){return"Anything";}}class ObjectContaining extends AsymmetricMatcher$1{constructor(sample,inverse=false){super(sample,inverse);}getPrototype(obj){if(Object.getPrototypeOf)return Object.getPrototypeOf(obj);if(obj.constructor.prototype===obj)return null;return obj.constructor.prototype;}hasProperty(obj,property){if(!obj)return false;if(Object.prototype.hasOwnProperty.call(obj,property))return true;return this.hasProperty(this.getPrototype(obj),property);}asymmetricMatch(other){if(typeof this.sample!=="object"){throw new TypeError(\`You must provide an object to \${this.toString()}, not '\${typeof this.sample}'.\`);}let result=true;const matcherContext=this.getMatcherContext();for(const property in this.sample){if(!this.hasProperty(other,property)||!equals(this.sample[property],other[property],matcherContext.customTesters)){result=false;break;}}return this.inverse?!result:result;}toString(){return\`Object\${this.inverse?"Not":""}Containing\`;}getExpectedType(){return"object";}}class ArrayContaining extends AsymmetricMatcher$1{constructor(sample,inverse=false){super(sample,inverse);}asymmetricMatch(other){if(!Array.isArray(this.sample)){throw new TypeError(\`You must provide an array to \${this.toString()}, not '\${typeof this.sample}'.\`);}const matcherContext=this.getMatcherContext();const result=this.sample.length===0||Array.isArray(other)&&this.sample.every(item=>other.some(another=>equals(item,another,matcherContext.customTesters)));return this.inverse?!result:result;}toString(){return\`Array\${this.inverse?"Not":""}Containing\`;}getExpectedType(){return"array";}}class Any extends AsymmetricMatcher$1{constructor(sample){if(typeof sample==="undefined"){throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");}super(sample);}fnNameFor(func){if(func.name)return func.name;const functionToString=Function.prototype.toString;const matches=functionToString.call(func).match(/^(?:async)?\\s*function\\s*\\*?\\s*([\\w$]+)\\s*\\(/);return matches?matches[1]:"<anonymous>";}asymmetricMatch(other){if(this.sample===String)return typeof other=="string"||other instanceof String;if(this.sample===Number)return typeof other=="number"||other instanceof Number;if(this.sample===Function)return typeof other=="function"||other instanceof Function;if(this.sample===Boolean)return typeof other=="boolean"||other instanceof Boolean;if(this.sample===BigInt)return typeof other=="bigint"||other instanceof BigInt;if(this.sample===Symbol)return typeof other=="symbol"||other instanceof Symbol;if(this.sample===Object)return typeof other=="object";return other instanceof this.sample;}toString(){return"Any";}getExpectedType(){if(this.sample===String)return"string";if(this.sample===Number)return"number";if(this.sample===Function)return"function";if(this.sample===Object)return"object";if(this.sample===Boolean)return"boolean";return this.fnNameFor(this.sample);}toAsymmetricMatcher(){return\`Any<\${this.fnNameFor(this.sample)}>\`;}}class StringMatching extends AsymmetricMatcher$1{constructor(sample,inverse=false){if(!isA("String",sample)&&!isA("RegExp",sample))throw new Error("Expected is not a String or a RegExp");super(new RegExp(sample),inverse);}asymmetricMatch(other){const result=isA("String",other)&&this.sample.test(other);return this.inverse?!result:result;}toString(){return\`String\${this.inverse?"Not":""}Matching\`;}getExpectedType(){return"string";}}class CloseTo extends AsymmetricMatcher$1{precision;constructor(sample,precision=2,inverse=false){if(!isA("Number",sample))throw new Error("Expected is not a Number");if(!isA("Number",precision))throw new Error("Precision is not a Number");super(sample);this.inverse=inverse;this.precision=precision;}asymmetricMatch(other){if(!isA("Number",other))return false;let result=false;if(other===Number.POSITIVE_INFINITY&&this.sample===Number.POSITIVE_INFINITY){result=true;}else if(other===Number.NEGATIVE_INFINITY&&this.sample===Number.NEGATIVE_INFINITY){result=true;}else{result=Math.abs(this.sample-other)<10**-this.precision/2;}return this.inverse?!result:result;}toString(){return\`Number\${this.inverse?"Not":""}CloseTo\`;}getExpectedType(){return"number";}toAsymmetricMatcher(){return[this.toString(),this.sample,\`(\${pluralize("digit",this.precision)})\`].join(" ");}}const JestAsymmetricMatchers=(chai,utils)=>{utils.addMethod(chai.expect,"anything",()=>new Anything());utils.addMethod(chai.expect,"any",expected=>new Any(expected));utils.addMethod(chai.expect,"stringContaining",expected=>new StringContaining(expected));utils.addMethod(chai.expect,"objectContaining",expected=>new ObjectContaining(expected));utils.addMethod(chai.expect,"arrayContaining",expected=>new ArrayContaining(expected));utils.addMethod(chai.expect,"stringMatching",expected=>new StringMatching(expected));utils.addMethod(chai.expect,"closeTo",(expected,precision)=>new CloseTo(expected,precision));chai.expect.not={stringContaining:expected=>new StringContaining(expected,true),objectContaining:expected=>new ObjectContaining(expected,true),arrayContaining:expected=>new ArrayContaining(expected,true),stringMatching:expected=>new StringMatching(expected,true),closeTo:(expected,precision)=>new CloseTo(expected,precision,true)};};function recordAsyncExpect$1(test,promise){if(test&&promise instanceof Promise){promise=promise.finally(()=>{const index=test.promises.indexOf(promise);if(index!==-1)test.promises.splice(index,1);});if(!test.promises)test.promises=[];test.promises.push(promise);}return promise;}function wrapSoft(utils,fn){return function(...args){var _a;const test=utils.flag(this,"vitest-test");const state=(test==null?void 0:test.context._local)?test.context.expect.getState():getState(globalThis[GLOBAL_EXPECT$1]);if(!state.soft)return fn.apply(this,args);if(!test)throw new Error("expect.soft() can only be used inside a test");try{return fn.apply(this,args);}catch(err){test.result||(test.result={state:"fail"});test.result.state="fail";(_a=test.result).errors||(_a.errors=[]);test.result.errors.push(processError(err));}};}const JestChaiExpect=(chai,utils)=>{const AssertionError=chai.AssertionError;const c=()=>getColors();const customTesters=getCustomEqualityTesters();function def(name,fn){const addMethod=n=>{const softWrapper=wrapSoft(utils,fn);utils.addMethod(chai.Assertion.prototype,n,softWrapper);utils.addMethod(globalThis[JEST_MATCHERS_OBJECT$1].matchers,n,softWrapper);};if(Array.isArray(name))name.forEach(n=>addMethod(n));else addMethod(name);}["throw","throws","Throw"].forEach(m=>{utils.overwriteMethod(chai.Assertion.prototype,m,_super=>{return function(...args){const promise=utils.flag(this,"promise");const object=utils.flag(this,"object");const isNot=utils.flag(this,"negate");if(promise==="rejects"){utils.flag(this,"object",()=>{throw object;});}else if(promise==="resolves"&&typeof object!=="function"){if(!isNot){const message=utils.flag(this,"message")||"expected promise to throw an error, but it didn't";const error={showDiff:false};throw new AssertionError(message,error,utils.flag(this,"ssfi"));}else{return;}}_super.apply(this,args);};});});def("withTest",function(test){utils.flag(this,"vitest-test",test);return this;});def("toEqual",function(expected){const actual=utils.flag(this,"object");const equal=equals(actual,expected,[...customTesters,iterableEquality]);return this.assert(equal,"expected #{this} to deeply equal #{exp}","expected #{this} to not deeply equal #{exp}",expected,actual);});def("toStrictEqual",function(expected){const obj=utils.flag(this,"object");const equal=equals(obj,expected,[...customTesters,iterableEquality,typeEquality,sparseArrayEquality,arrayBufferEquality],true);return this.assert(equal,"expected #{this} to strictly equal #{exp}","expected #{this} to not strictly equal #{exp}",expected,obj);});def("toBe",function(expected){const actual=this._obj;const pass=Object.is(actual,expected);let deepEqualityName="";if(!pass){const toStrictEqualPass=equals(actual,expected,[...customTesters,iterableEquality,typeEquality,sparseArrayEquality,arrayBufferEquality],true);if(toStrictEqualPass){deepEqualityName="toStrictEqual";}else{const toEqualPass=equals(actual,expected,[...customTesters,iterableEquality]);if(toEqualPass)deepEqualityName="toEqual";}}return this.assert(pass,generateToBeMessage(deepEqualityName),"expected #{this} not to be #{exp} // Object.is equality",expected,actual);});def("toMatchObject",function(expected){const actual=this._obj;const pass=equals(actual,expected,[...customTesters,iterableEquality,subsetEquality]);const isNot=utils.flag(this,"negate");const _getObjectSubset=getObjectSubset(actual,expected),actualSubset=_getObjectSubset.subset,stripped=_getObjectSubset.stripped;if(pass&&isNot||!pass&&!isNot){const msg=utils.getMessage(this,[pass,"expected #{this} to match object #{exp}","expected #{this} to not match object #{exp}",expected,actualSubset,false]);const message=stripped===0?msg:\`\${msg}
(\${stripped} matching \${stripped===1?"property":"properties"} omitted from actual)\`;throw new AssertionError(message,{showDiff:true,expected,actual:actualSubset});}});def("toMatch",function(expected){const actual=this._obj;if(typeof actual!=="string")throw new TypeError(\`.toMatch() expects to receive a string, but got \${typeof actual}\`);return this.assert(typeof expected==="string"?actual.includes(expected):actual.match(expected),\`expected #{this} to match #{exp}\`,\`expected #{this} not to match #{exp}\`,expected,actual);});def("toContain",function(item){const actual=this._obj;if(typeof Node!=="undefined"&&actual instanceof Node){if(!(item instanceof Node))throw new TypeError(\`toContain() expected a DOM node as the argument, but got \${typeof item}\`);return this.assert(actual.contains(item),"expected #{this} to contain element #{exp}","expected #{this} not to contain element #{exp}",item,actual);}if(typeof DOMTokenList!=="undefined"&&actual instanceof DOMTokenList){assertTypes(item,"class name",["string"]);const isNot=utils.flag(this,"negate");const expectedClassList=isNot?actual.value.replace(item,"").trim():\`\${actual.value} \${item}\`;return this.assert(actual.contains(item),\`expected "\${actual.value}" to contain "\${item}"\`,\`expected "\${actual.value}" not to contain "\${item}"\`,expectedClassList,actual.value);}if(typeof actual==="string"&&typeof item==="string"){return this.assert(actual.includes(item),\`expected #{this} to contain #{exp}\`,\`expected #{this} not to contain #{exp}\`,item,actual);}if(actual!=null&&typeof actual!=="string")utils.flag(this,"object",Array.from(actual));return this.contain(item);});def("toContainEqual",function(expected){const obj=utils.flag(this,"object");const index=Array.from(obj).findIndex(item=>{return equals(item,expected,customTesters);});this.assert(index!==-1,"expected #{this} to deep equally contain #{exp}","expected #{this} to not deep equally contain #{exp}",expected);});def("toBeTruthy",function(){const obj=utils.flag(this,"object");this.assert(Boolean(obj),"expected #{this} to be truthy","expected #{this} to not be truthy",obj,false);});def("toBeFalsy",function(){const obj=utils.flag(this,"object");this.assert(!obj,"expected #{this} to be falsy","expected #{this} to not be falsy",obj,false);});def("toBeGreaterThan",function(expected){const actual=this._obj;assertTypes(actual,"actual",["number","bigint"]);assertTypes(expected,"expected",["number","bigint"]);return this.assert(actual>expected,\`expected \${actual} to be greater than \${expected}\`,\`expected \${actual} to be not greater than \${expected}\`,actual,expected,false);});def("toBeGreaterThanOrEqual",function(expected){const actual=this._obj;assertTypes(actual,"actual",["number","bigint"]);assertTypes(expected,"expected",["number","bigint"]);return this.assert(actual>=expected,\`expected \${actual} to be greater than or equal to \${expected}\`,\`expected \${actual} to be not greater than or equal to \${expected}\`,actual,expected,false);});def("toBeLessThan",function(expected){const actual=this._obj;assertTypes(actual,"actual",["number","bigint"]);assertTypes(expected,"expected",["number","bigint"]);return this.assert(actual<expected,\`expected \${actual} to be less than \${expected}\`,\`expected \${actual} to be not less than \${expected}\`,actual,expected,false);});def("toBeLessThanOrEqual",function(expected){const actual=this._obj;assertTypes(actual,"actual",["number","bigint"]);assertTypes(expected,"expected",["number","bigint"]);return this.assert(actual<=expected,\`expected \${actual} to be less than or equal to \${expected}\`,\`expected \${actual} to be not less than or equal to \${expected}\`,actual,expected,false);});def("toBeNaN",function(){return this.be.NaN;});def("toBeUndefined",function(){return this.be.undefined;});def("toBeNull",function(){return this.be.null;});def("toBeDefined",function(){const negate=utils.flag(this,"negate");utils.flag(this,"negate",false);if(negate)return this.be.undefined;return this.not.be.undefined;});def("toBeTypeOf",function(expected){const actual=typeof this._obj;const equal=expected===actual;return this.assert(equal,"expected #{this} to be type of #{exp}","expected #{this} not to be type of #{exp}",expected,actual);});def("toBeInstanceOf",function(obj){return this.instanceOf(obj);});def("toHaveLength",function(length){return this.have.length(length);});def("toHaveProperty",function(...args){if(Array.isArray(args[0]))args[0]=args[0].map(key=>String(key).replace(/([.[\\]])/g,"\\\\$1")).join(".");const actual=this._obj;const propertyName=args[0],expected=args[1];const getValue=()=>{const hasOwn=Object.prototype.hasOwnProperty.call(actual,propertyName);if(hasOwn)return{value:actual[propertyName],exists:true};return utils.getPathInfo(actual,propertyName);};const _getValue=getValue(),value=_getValue.value,exists=_getValue.exists;const pass=exists&&(args.length===1||equals(expected,value,customTesters));const valueString=args.length===1?"":\` with value \${utils.objDisplay(expected)}\`;return this.assert(pass,\`expected #{this} to have property "\${propertyName}"\${valueString}\`,\`expected #{this} to not have property "\${propertyName}"\${valueString}\`,expected,exists?value:void 0);});def("toBeCloseTo",function(received,precision=2){const expected=this._obj;let pass=false;let expectedDiff=0;let receivedDiff=0;if(received===Number.POSITIVE_INFINITY&&expected===Number.POSITIVE_INFINITY){pass=true;}else if(received===Number.NEGATIVE_INFINITY&&expected===Number.NEGATIVE_INFINITY){pass=true;}else{expectedDiff=10**-precision/2;receivedDiff=Math.abs(expected-received);pass=receivedDiff<expectedDiff;}return this.assert(pass,\`expected #{this} to be close to #{exp}, received difference is \${receivedDiff}, but expected \${expectedDiff}\`,\`expected #{this} to not be close to #{exp}, received difference is \${receivedDiff}, but expected \${expectedDiff}\`,received,expected,false);});const assertIsMock=assertion=>{if(!isMockFunction(assertion._obj))throw new TypeError(\`\${utils.inspect(assertion._obj)} is not a spy or a call to a spy!\`);};const getSpy=assertion=>{assertIsMock(assertion);return assertion._obj;};const ordinalOf=i=>{const j=i%10;const k=i%100;if(j===1&&k!==11)return\`\${i}st\`;if(j===2&&k!==12)return\`\${i}nd\`;if(j===3&&k!==13)return\`\${i}rd\`;return\`\${i}th\`;};const formatCalls=(spy,msg,actualCall)=>{if(spy.mock.calls){msg+=c().gray(\`

Received: 

\${spy.mock.calls.map((callArg,i)=>{let methodCall=c().bold(\`  \${ordinalOf(i+1)} \${spy.getMockName()} call:

\`);if(actualCall)methodCall+=diff(actualCall,callArg,{omitAnnotationLines:true});else methodCall+=stringify(callArg).split("\\n").map(line=>\`    \${line}\`).join("\\n");methodCall+="\\n";return methodCall;}).join("\\n")}\`);}msg+=c().gray(\`

Number of calls: \${c().bold(spy.mock.calls.length)}
\`);return msg;};const formatReturns=(spy,msg,actualReturn)=>{msg+=c().gray(\`

Received: 

\${spy.mock.results.map((callReturn,i)=>{let methodCall=c().bold(\`  \${ordinalOf(i+1)} \${spy.getMockName()} call return:

\`);if(actualReturn)methodCall+=diff(actualReturn,callReturn.value,{omitAnnotationLines:true});else methodCall+=stringify(callReturn).split("\\n").map(line=>\`    \${line}\`).join("\\n");methodCall+="\\n";return methodCall;}).join("\\n")}\`);msg+=c().gray(\`

Number of calls: \${c().bold(spy.mock.calls.length)}
\`);return msg;};def(["toHaveBeenCalledTimes","toBeCalledTimes"],function(number){const spy=getSpy(this);const spyName=spy.getMockName();const callCount=spy.mock.calls.length;return this.assert(callCount===number,\`expected "\${spyName}" to be called #{exp} times, but got \${callCount} times\`,\`expected "\${spyName}" to not be called #{exp} times\`,number,callCount,false);});def("toHaveBeenCalledOnce",function(){const spy=getSpy(this);const spyName=spy.getMockName();const callCount=spy.mock.calls.length;return this.assert(callCount===1,\`expected "\${spyName}" to be called once, but got \${callCount} times\`,\`expected "\${spyName}" to not be called once\`,1,callCount,false);});def(["toHaveBeenCalled","toBeCalled"],function(){const spy=getSpy(this);const spyName=spy.getMockName();const callCount=spy.mock.calls.length;const called=callCount>0;const isNot=utils.flag(this,"negate");let msg=utils.getMessage(this,[called,\`expected "\${spyName}" to be called at least once\`,\`expected "\${spyName}" to not be called at all, but actually been called \${callCount} times\`,true,called]);if(called&&isNot)msg=formatCalls(spy,msg);if(called&&isNot||!called&&!isNot)throw new AssertionError(msg);});def(["toHaveBeenCalledWith","toBeCalledWith"],function(...args){const spy=getSpy(this);const spyName=spy.getMockName();const pass=spy.mock.calls.some(callArg=>equals(callArg,args,[...customTesters,iterableEquality]));const isNot=utils.flag(this,"negate");const msg=utils.getMessage(this,[pass,\`expected "\${spyName}" to be called with arguments: #{exp}\`,\`expected "\${spyName}" to not be called with arguments: #{exp}\`,args]);if(pass&&isNot||!pass&&!isNot)throw new AssertionError(formatCalls(spy,msg,args));});def(["toHaveBeenNthCalledWith","nthCalledWith"],function(times,...args){const spy=getSpy(this);const spyName=spy.getMockName();const nthCall=spy.mock.calls[times-1];const callCount=spy.mock.calls.length;const isCalled=times<=callCount;this.assert(equals(nthCall,args,[...customTesters,iterableEquality]),\`expected \${ordinalOf(times)} "\${spyName}" call to have been called with #{exp}\${isCalled?\`\`:\`, but called only \${callCount} times\`}\`,\`expected \${ordinalOf(times)} "\${spyName}" call to not have been called with #{exp}\`,args,nthCall,isCalled);});def(["toHaveBeenLastCalledWith","lastCalledWith"],function(...args){const spy=getSpy(this);const spyName=spy.getMockName();const lastCall=spy.mock.calls[spy.mock.calls.length-1];this.assert(equals(lastCall,args,[...customTesters,iterableEquality]),\`expected last "\${spyName}" call to have been called with #{exp}\`,\`expected last "\${spyName}" call to not have been called with #{exp}\`,args,lastCall);});def(["toThrow","toThrowError"],function(expected){if(typeof expected==="string"||typeof expected==="undefined"||expected instanceof RegExp)return this.throws(expected);const obj=this._obj;const promise=utils.flag(this,"promise");const isNot=utils.flag(this,"negate");let thrown=null;if(promise==="rejects"){thrown=obj;}else if(promise==="resolves"&&typeof obj!=="function"){if(!isNot){const message=utils.flag(this,"message")||"expected promise to throw an error, but it didn't";const error={showDiff:false};throw new AssertionError(message,error,utils.flag(this,"ssfi"));}else{return;}}else{let isThrow=false;try{obj();}catch(err){isThrow=true;thrown=err;}if(!isThrow&&!isNot){const message=utils.flag(this,"message")||"expected function to throw an error, but it didn't";const error={showDiff:false};throw new AssertionError(message,error,utils.flag(this,"ssfi"));}}if(typeof expected==="function"){const name=expected.name||expected.prototype.constructor.name;return this.assert(thrown&&thrown instanceof expected,\`expected error to be instance of \${name}\`,\`expected error not to be instance of \${name}\`,expected,thrown);}if(expected instanceof Error){return this.assert(thrown&&expected.message===thrown.message,\`expected error to have message: \${expected.message}\`,\`expected error not to have message: \${expected.message}\`,expected.message,thrown&&thrown.message);}if(typeof expected==="object"&&"asymmetricMatch"in expected&&typeof expected.asymmetricMatch==="function"){const matcher=expected;return this.assert(thrown&&matcher.asymmetricMatch(thrown),"expected error to match asymmetric matcher","expected error not to match asymmetric matcher",matcher,thrown);}throw new Error(\`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "\${typeof expected}"\`);});def(["toHaveReturned","toReturn"],function(){const spy=getSpy(this);const spyName=spy.getMockName();const calledAndNotThrew=spy.mock.calls.length>0&&spy.mock.results.some(({type})=>type!=="throw");this.assert(calledAndNotThrew,\`expected "\${spyName}" to be successfully called at least once\`,\`expected "\${spyName}" to not be successfully called\`,calledAndNotThrew,!calledAndNotThrew,false);});def(["toHaveReturnedTimes","toReturnTimes"],function(times){const spy=getSpy(this);const spyName=spy.getMockName();const successfulReturns=spy.mock.results.reduce((success,{type})=>type==="throw"?success:++success,0);this.assert(successfulReturns===times,\`expected "\${spyName}" to be successfully called \${times} times\`,\`expected "\${spyName}" to not be successfully called \${times} times\`,\`expected number of returns: \${times}\`,\`received number of returns: \${successfulReturns}\`,false);});def(["toHaveReturnedWith","toReturnWith"],function(value){const spy=getSpy(this);const spyName=spy.getMockName();const pass=spy.mock.results.some(({type,value:result})=>type==="return"&&equals(value,result));const isNot=utils.flag(this,"negate");const msg=utils.getMessage(this,[pass,\`expected "\${spyName}" to return with: #{exp} at least once\`,\`expected "\${spyName}" to not return with: #{exp}\`,value]);if(pass&&isNot||!pass&&!isNot)throw new AssertionError(formatReturns(spy,msg,value));});def(["toHaveLastReturnedWith","lastReturnedWith"],function(value){const spy=getSpy(this);const spyName=spy.getMockName();const lastResult=spy.mock.results[spy.mock.results.length-1].value;const pass=equals(lastResult,value);this.assert(pass,\`expected last "\${spyName}" call to return #{exp}\`,\`expected last "\${spyName}" call to not return #{exp}\`,value,lastResult);});def(["toHaveNthReturnedWith","nthReturnedWith"],function(nthCall,value){const spy=getSpy(this);const spyName=spy.getMockName();const isNot=utils.flag(this,"negate");const _spy$mock$results=spy.mock.results[nthCall-1],callType=_spy$mock$results.type,callResult=_spy$mock$results.value;const ordinalCall=\`\${ordinalOf(nthCall)} call\`;if(!isNot&&callType==="throw")chai.assert.fail(\`expected \${ordinalCall} to return #{exp}, but instead it threw an error\`);const nthCallReturn=equals(callResult,value);this.assert(nthCallReturn,\`expected \${ordinalCall} "\${spyName}" call to return #{exp}\`,\`expected \${ordinalCall} "\${spyName}" call to not return #{exp}\`,value,callResult);});def("toSatisfy",function(matcher,message){return this.be.satisfy(matcher,message);});utils.addProperty(chai.Assertion.prototype,"resolves",function __VITEST_RESOLVES__(){const error=new Error("resolves");utils.flag(this,"promise","resolves");utils.flag(this,"error",error);const test=utils.flag(this,"vitest-test");const obj=utils.flag(this,"object");if(typeof(obj==null?void 0:obj.then)!=="function")throw new TypeError(\`You must provide a Promise to expect() when using .resolves, not '\${typeof obj}'.\`);const proxy=new Proxy(this,{get:(target,key,receiver)=>{const result=Reflect.get(target,key,receiver);if(typeof result!=="function")return result instanceof chai.Assertion?proxy:result;return async(...args)=>{const promise=obj.then(value=>{utils.flag(this,"object",value);return result.call(this,...args);},err=>{const _error=new AssertionError(\`promise rejected "\${utils.inspect(err)}" instead of resolving\`,{showDiff:false});_error.cause=err;_error.stack=error.stack.replace(error.message,_error.message);throw _error;});return recordAsyncExpect$1(test,promise);};}});return proxy;});utils.addProperty(chai.Assertion.prototype,"rejects",function __VITEST_REJECTS__(){const error=new Error("rejects");utils.flag(this,"promise","rejects");utils.flag(this,"error",error);const test=utils.flag(this,"vitest-test");const obj=utils.flag(this,"object");const wrapper=typeof obj==="function"?obj():obj;if(typeof(wrapper==null?void 0:wrapper.then)!=="function")throw new TypeError(\`You must provide a Promise to expect() when using .rejects, not '\${typeof wrapper}'.\`);const proxy=new Proxy(this,{get:(target,key,receiver)=>{const result=Reflect.get(target,key,receiver);if(typeof result!=="function")return result instanceof chai.Assertion?proxy:result;return async(...args)=>{const promise=wrapper.then(value=>{const _error=new AssertionError(\`promise resolved "\${utils.inspect(value)}" instead of rejecting\`,{showDiff:true,expected:new Error("rejected promise"),actual:value});_error.stack=error.stack.replace(error.message,_error.message);throw _error;},err=>{utils.flag(this,"object",err);return result.call(this,...args);});return recordAsyncExpect$1(test,promise);};}});return proxy;});};function getMatcherState(assertion,expect){const obj=assertion._obj;const isNot=util.flag(assertion,"negate");const promise=util.flag(assertion,"promise")||"";const jestUtils=_objectSpread(_objectSpread({},getMatcherUtils()),{},{diff,stringify,iterableEquality,subsetEquality});const matcherState=_objectSpread(_objectSpread({},getState(expect)),{},{customTesters:getCustomEqualityTesters(),isNot,utils:jestUtils,promise,equals,// needed for built-in jest-snapshots, but we don't use it
suppressedErrors:[]});return{state:matcherState,isNot,obj};}class JestExtendError extends Error{constructor(message,actual,expected){super(message);this.actual=actual;this.expected=expected;}}function JestExtendPlugin(expect,matchers){return(c,utils)=>{Object.entries(matchers).forEach(([expectAssertionName,expectAssertion])=>{function expectWrapper(...args){const _getMatcherState=getMatcherState(this,expect),state=_getMatcherState.state,isNot=_getMatcherState.isNot,obj=_getMatcherState.obj;const result=expectAssertion.call(state,obj,...args);if(result&&typeof result==="object"&&result instanceof Promise){return result.then(({pass:pass2,message:message2,actual:actual2,expected:expected2})=>{if(pass2&&isNot||!pass2&&!isNot)throw new JestExtendError(message2(),actual2,expected2);});}const pass=result.pass,message=result.message,actual=result.actual,expected=result.expected;if(pass&&isNot||!pass&&!isNot)throw new JestExtendError(message(),actual,expected);}const softWrapper=wrapSoft(utils,expectWrapper);utils.addMethod(globalThis[JEST_MATCHERS_OBJECT$1].matchers,expectAssertionName,softWrapper);utils.addMethod(c.Assertion.prototype,expectAssertionName,softWrapper);class CustomMatcher extends AsymmetricMatcher$1{constructor(inverse=false,...sample){super(sample,inverse);}asymmetricMatch(other){const _expectAssertion$call=expectAssertion.call(this.getMatcherContext(expect),other,...this.sample),pass=_expectAssertion$call.pass;return this.inverse?!pass:pass;}toString(){return\`\${this.inverse?"not.":""}\${expectAssertionName}\`;}getExpectedType(){return"any";}toAsymmetricMatcher(){return\`\${this.toString()}<\${this.sample.map(String).join(", ")}>\`;}}const customMatcher=(...sample)=>new CustomMatcher(false,...sample);Object.defineProperty(expect,expectAssertionName,{configurable:true,enumerable:true,value:customMatcher,writable:true});Object.defineProperty(expect.not,expectAssertionName,{configurable:true,enumerable:true,value:(...sample)=>new CustomMatcher(true,...sample),writable:true});Object.defineProperty(globalThis[ASYMMETRIC_MATCHERS_OBJECT$1],expectAssertionName,{configurable:true,enumerable:true,value:customMatcher,writable:true});});};}const JestExtend=(chai,utils)=>{utils.addMethod(chai.expect,"extend",(expect,expects)=>{chai.use(JestExtendPlugin(expect,expects));});};function getDefaultExportFromCjs(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,'default')?x['default']:x;}var naturalCompare$2={exports:{}};/*
 * @version    1.4.0
 * @date       2015-10-26
 * @stability  3 - Stable
 * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
 * @license    MIT License
 */var naturalCompare=function(a,b){var i,codeA,codeB=1,posA=0,posB=0,alphabet=String.alphabet;function getCode(str,pos,code){if(code){for(i=pos;code=getCode(str,i),code<76&&code>65;)++i;return+str.slice(pos-1,i);}code=alphabet&&alphabet.indexOf(str.charAt(pos));return code>-1?code+76:(code=str.charCodeAt(pos)||0,code<45||code>127)?code:code<46?65// -
:code<48?code-1:code<58?code+18// 0-9
:code<65?code-11:code<91?code+11// A-Z
:code<97?code-37:code<123?code+5// a-z
:code-63;}if((a+="")!=(b+=""))for(;codeB;){codeA=getCode(a,posA++);codeB=getCode(b,posB++);if(codeA<76&&codeB<76&&codeA>66&&codeB>66){codeA=getCode(a,posA,posA);codeB=getCode(b,posB,posA=i);posB=i;}if(codeA!=codeB)return codeA<codeB?-1:1;}return 0;};try{naturalCompare$2.exports=naturalCompare;}catch(e){String.naturalCompare=naturalCompare;}var naturalCompareExports=naturalCompare$2.exports;var naturalCompare$1=/*@__PURE__*/getDefaultExportFromCjs(naturalCompareExports);function notNullish(v){return v!=null;}function isPrimitive(value){return value===null||typeof value!=="function"&&typeof value!=="object";}function isObject(item){return item!=null&&typeof item==="object"&&!Array.isArray(item);}function getCallLastIndex(code){let charIndex=-1;let inString=null;let startedBracers=0;let endedBracers=0;let beforeChar=null;while(charIndex<=code.length){beforeChar=code[charIndex];charIndex++;const char=code[charIndex];const isCharString=char==='"'||char==="'"||char==="\`";if(isCharString&&beforeChar!=="\\\\"){if(inString===char)inString=null;else if(!inString)inString=char;}if(!inString){if(char==="(")startedBracers++;if(char===")")endedBracers++;}if(startedBracers&&endedBracers&&startedBracers===endedBracers)return charIndex;}return null;}let getPromiseValue=()=>'Promise{…}';try{const _process$binding2=process.binding('util'),getPromiseDetails=_process$binding2.getPromiseDetails,kPending=_process$binding2.kPending,kRejected=_process$binding2.kRejected;if(Array.isArray(getPromiseDetails(Promise.resolve()))){getPromiseValue=(value,options)=>{const _getPromiseDetails3=getPromiseDetails(value),_getPromiseDetails4=_slicedToArray(_getPromiseDetails3,2),state=_getPromiseDetails4[0],innerValue=_getPromiseDetails4[1];if(state===kPending){return'Promise{<pending>}';}return\`Promise\${state===kRejected?'!':''}{\${options.inspect(innerValue,options)}}\`;};}}catch(notNode){/* ignore */}/* !
 * loupe
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */let nodeInspect=false;try{// eslint-disable-next-line global-require
const nodeUtil=require('util');nodeInspect=nodeUtil.inspect?nodeUtil.inspect.custom:false;}catch(noNodeInspect){nodeInspect=false;}const lineSplitRE=/\\r?\\n/;function positionToOffset(source,lineNumber,columnNumber){const lines=source.split(lineSplitRE);const nl=/\\r\\n/.test(source)?2:1;let start=0;if(lineNumber>lines.length)return source.length;for(let i=0;i<lineNumber-1;i++)start+=lines[i].length+nl;return start+columnNumber;}function offsetToLineNumber(source,offset){if(offset>source.length){throw new Error(\`offset is longer than source length! offset \${offset} > length \${source.length}\`);}const lines=source.split(lineSplitRE);const nl=/\\r\\n/.test(source)?2:1;let counted=0;let line=0;for(;line<lines.length;line++){const lineLength=lines[line].length+nl;if(counted+lineLength>=offset)break;counted+=lineLength;}return line+1;}// Copyright 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023 Simon Lydell
// License: MIT.
var LineTerminatorSequence;LineTerminatorSequence=/\\r?\\n|[\\r\\u2028\\u2029]/y;RegExp(LineTerminatorSequence.source);// src/index.ts
var reservedWords={keyword:["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"],strict:["implements","interface","let","package","private","protected","public","static","yield"]};new Set(reservedWords.keyword);new Set(reservedWords.strict);const serialize$1=(val,config,indentation,depth,refs,printer)=>{const name=val.getMockName();const nameString=name==="vi.fn()"?"":\` \${name}\`;let callsString="";if(val.mock.calls.length!==0){const indentationNext=indentation+config.indent;callsString=\` {\${config.spacingOuter}\${indentationNext}"calls": \${printer(val.mock.calls,config,indentationNext,depth,refs)}\${config.min?", ":","}\${config.spacingOuter}\${indentationNext}"results": \${printer(val.mock.results,config,indentationNext,depth,refs)}\${config.min?"":","}\${config.spacingOuter}\${indentation}}\`;}return\`[MockFunction\${nameString}]\${callsString}\`;};const test=val=>val&&!!val._isMockFunction;const plugin={serialize:serialize$1,test};const _plugins_3=plugins_1,DOMCollection=_plugins_3.DOMCollection,DOMElement=_plugins_3.DOMElement,Immutable=_plugins_3.Immutable,ReactElement=_plugins_3.ReactElement,ReactTestComponent=_plugins_3.ReactTestComponent,AsymmetricMatcher=_plugins_3.AsymmetricMatcher;let PLUGINS=[ReactTestComponent,ReactElement,DOMElement,DOMCollection,Immutable,AsymmetricMatcher,plugin];function addSerializer(plugin){PLUGINS=[plugin].concat(PLUGINS);}function getSerializers(){return PLUGINS;}function testNameToKey(testName,count){return\`\${testName} \${count}\`;}function keyToTestName(key){if(!/ \\d+$/.test(key))throw new Error("Snapshot keys must end with a number.");return key.replace(/ \\d+$/,"");}function getSnapshotData(content,options){const update=options.updateSnapshot;const data=/* @__PURE__ */Object.create(null);let snapshotContents="";let dirty=false;if(content!=null){try{snapshotContents=content;const populate=new Function("exports",snapshotContents);populate(data);}catch{}}const isInvalid=snapshotContents;if((update==="all"||update==="new")&&isInvalid)dirty=true;return{data,dirty};}function addExtraLineBreaks(string){return string.includes("\\n")?\`
\${string}
\`:string;}function removeExtraLineBreaks(string){return string.length>2&&string.startsWith("\\n")&&string.endsWith("\\n")?string.slice(1,-1):string;}const escapeRegex=true;const printFunctionName=false;function serialize(val,indent=2,formatOverrides={}){return normalizeNewlines(format_1(val,_objectSpread({escapeRegex,indent,plugins:getSerializers(),printFunctionName},formatOverrides)));}function escapeBacktickString(str){return str.replace(/\`|\\\\|\\\${/g,"\\\\$&");}function printBacktickString(str){return\`\\\`\${escapeBacktickString(str)}\\\`\`;}function normalizeNewlines(string){return string.replace(/\\r\\n|\\r/g,"\\n");}async function saveSnapshotFile(environment,snapshotData,snapshotPath){const snapshots=Object.keys(snapshotData).sort(naturalCompare$1).map(key=>\`exports[\${printBacktickString(key)}] = \${printBacktickString(normalizeNewlines(snapshotData[key]))};\`);const content=\`\${environment.getHeader()}

\${snapshots.join("\\n\\n")}
\`;const oldContent=await environment.readSnapshotFile(snapshotPath);const skipWriting=oldContent!=null&&oldContent===content;if(skipWriting)return;await environment.saveSnapshotFile(snapshotPath,content);}function prepareExpected(expected){function findStartIndent(){var _a,_b;const matchObject=/^( +)}\\s+$/m.exec(expected||"");const objectIndent=(_a=matchObject==null?void 0:matchObject[1])==null?void 0:_a.length;if(objectIndent)return objectIndent;const matchText=/^\\n( +)"/.exec(expected||"");return((_b=matchText==null?void 0:matchText[1])==null?void 0:_b.length)||0;}const startIndent=findStartIndent();let expectedTrimmed=expected==null?void 0:expected.trim();if(startIndent){expectedTrimmed=expectedTrimmed==null?void 0:expectedTrimmed.replace(new RegExp(\`^\${" ".repeat(startIndent)}\`,"gm"),"").replace(/ +}$/,"}");}return expectedTrimmed;}function deepMergeArray(target=[],source=[]){const mergedOutput=Array.from(target);source.forEach((sourceElement,index)=>{const targetElement=mergedOutput[index];if(Array.isArray(target[index])){mergedOutput[index]=deepMergeArray(target[index],sourceElement);}else if(isObject(targetElement)){mergedOutput[index]=deepMergeSnapshot(target[index],sourceElement);}else{mergedOutput[index]=sourceElement;}});return mergedOutput;}function deepMergeSnapshot(target,source){if(isObject(target)&&isObject(source)){const mergedOutput=_objectSpread({},target);Object.keys(source).forEach(key=>{if(isObject(source[key])&&!source[key].$$typeof){if(!(key in target))Object.assign(mergedOutput,{[key]:source[key]});else mergedOutput[key]=deepMergeSnapshot(target[key],source[key]);}else if(Array.isArray(source[key])){mergedOutput[key]=deepMergeArray(target[key],source[key]);}else{Object.assign(mergedOutput,{[key]:source[key]});}});return mergedOutput;}else if(Array.isArray(target)&&Array.isArray(source)){return deepMergeArray(target,source);}return target;}const comma=','.charCodeAt(0);const chars='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';const intToChar=new Uint8Array(64);// 64 possible chars.
const charToInt=new Uint8Array(128);// z is 122 in ASCII
for(let i=0;i<chars.length;i++){const c=chars.charCodeAt(i);intToChar[i]=c;charToInt[c]=i;}function decode(mappings){const state=new Int32Array(5);const decoded=[];let index=0;do{const semi=indexOf(mappings,index);const line=[];let sorted=true;let lastCol=0;state[0]=0;for(let i=index;i<semi;i++){let seg;i=decodeInteger(mappings,i,state,0);// genColumn
const col=state[0];if(col<lastCol)sorted=false;lastCol=col;if(hasMoreVlq(mappings,i,semi)){i=decodeInteger(mappings,i,state,1);// sourcesIndex
i=decodeInteger(mappings,i,state,2);// sourceLine
i=decodeInteger(mappings,i,state,3);// sourceColumn
if(hasMoreVlq(mappings,i,semi)){i=decodeInteger(mappings,i,state,4);// namesIndex
seg=[col,state[1],state[2],state[3],state[4]];}else{seg=[col,state[1],state[2],state[3]];}}else{seg=[col];}line.push(seg);}if(!sorted)sort$1(line);decoded.push(line);index=semi+1;}while(index<=mappings.length);return decoded;}function indexOf(mappings,index){const idx=mappings.indexOf(';',index);return idx===-1?mappings.length:idx;}function decodeInteger(mappings,pos,state,j){let value=0;let shift=0;let integer=0;do{const c=mappings.charCodeAt(pos++);integer=charToInt[c];value|=(integer&31)<<shift;shift+=5;}while(integer&32);const shouldNegate=value&1;value>>>=1;if(shouldNegate){value=-0x80000000|-value;}state[j]+=value;return pos;}function hasMoreVlq(mappings,i,length){if(i>=length)return false;return mappings.charCodeAt(i)!==comma;}function sort$1(line){line.sort(sortComparator$1);}function sortComparator$1(a,b){return a[0]-b[0];}// Matches the scheme of a URL, eg "http://"
const schemeRegex=/^[\\w+.-]+:\\/\\//;/**
 * Matches the parts of a URL:
 * 1. Scheme, including ":", guaranteed.
 * 2. User/password, including "@", optional.
 * 3. Host, guaranteed.
 * 4. Port, including ":", optional.
 * 5. Path, including "/", optional.
 * 6. Query, including "?", optional.
 * 7. Hash, including "#", optional.
 */const urlRegex=/^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;/**
 * File URLs are weird. They dont' need the regular \`//\` in the scheme, they may or may not start
 * with a leading \`/\`, they can have a domain (but only if they don't start with a Windows drive).
 *
 * 1. Host, optional.
 * 2. Path, which may include "/", guaranteed.
 * 3. Query, including "?", optional.
 * 4. Hash, including "#", optional.
 */const fileRegex=/^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;var UrlType;(function(UrlType){UrlType[UrlType["Empty"]=1]="Empty";UrlType[UrlType["Hash"]=2]="Hash";UrlType[UrlType["Query"]=3]="Query";UrlType[UrlType["RelativePath"]=4]="RelativePath";UrlType[UrlType["AbsolutePath"]=5]="AbsolutePath";UrlType[UrlType["SchemeRelative"]=6]="SchemeRelative";UrlType[UrlType["Absolute"]=7]="Absolute";})(UrlType||(UrlType={}));function isAbsoluteUrl(input){return schemeRegex.test(input);}function isSchemeRelativeUrl(input){return input.startsWith('//');}function isAbsolutePath(input){return input.startsWith('/');}function isFileUrl(input){return input.startsWith('file:');}function isRelative(input){return /^[.?#]/.test(input);}function parseAbsoluteUrl(input){const match=urlRegex.exec(input);return makeUrl(match[1],match[2]||'',match[3],match[4]||'',match[5]||'/',match[6]||'',match[7]||'');}function parseFileUrl(input){const match=fileRegex.exec(input);const path=match[2];return makeUrl('file:','',match[1]||'','',isAbsolutePath(path)?path:'/'+path,match[3]||'',match[4]||'');}function makeUrl(scheme,user,host,port,path,query,hash){return{scheme,user,host,port,path,query,hash,type:UrlType.Absolute};}function parseUrl(input){if(isSchemeRelativeUrl(input)){const url=parseAbsoluteUrl('http:'+input);url.scheme='';url.type=UrlType.SchemeRelative;return url;}if(isAbsolutePath(input)){const url=parseAbsoluteUrl('http://foo.com'+input);url.scheme='';url.host='';url.type=UrlType.AbsolutePath;return url;}if(isFileUrl(input))return parseFileUrl(input);if(isAbsoluteUrl(input))return parseAbsoluteUrl(input);const url=parseAbsoluteUrl('http://foo.com/'+input);url.scheme='';url.host='';url.type=input?input.startsWith('?')?UrlType.Query:input.startsWith('#')?UrlType.Hash:UrlType.RelativePath:UrlType.Empty;return url;}function stripPathFilename(path){// If a path ends with a parent directory "..", then it's a relative path with excess parent
// paths. It's not a file, so we can't strip it.
if(path.endsWith('/..'))return path;const index=path.lastIndexOf('/');return path.slice(0,index+1);}function mergePaths(url,base){normalizePath(base,base.type);// If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
// path).
if(url.path==='/'){url.path=base.path;}else{// Resolution happens relative to the base path's directory, not the file.
url.path=stripPathFilename(base.path)+url.path;}}/**
 * The path can have empty directories "//", unneeded parents "foo/..", or current directory
 * "foo/.". We need to normalize to a standard representation.
 */function normalizePath(url,type){const rel=type<=UrlType.RelativePath;const pieces=url.path.split('/');// We need to preserve the first piece always, so that we output a leading slash. The item at
// pieces[0] is an empty string.
let pointer=1;// Positive is the number of real directories we've output, used for popping a parent directory.
// Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
let positive=0;// We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
// generate \`["foo", ""]\` pieces). And, if we pop a parent directory. But once we encounter a
// real directory, we won't need to append, unless the other conditions happen again.
let addTrailingSlash=false;for(let i=1;i<pieces.length;i++){const piece=pieces[i];// An empty directory, could be a trailing slash, or just a double "//" in the path.
if(!piece){addTrailingSlash=true;continue;}// If we encounter a real directory, then we don't need to append anymore.
addTrailingSlash=false;// A current directory, which we can always drop.
if(piece==='.')continue;// A parent directory, we need to see if there are any real directories we can pop. Else, we
// have an excess of parents, and we'll need to keep the "..".
if(piece==='..'){if(positive){addTrailingSlash=true;positive--;pointer--;}else if(rel){// If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
// URL, protocol relative URL, or an absolute path, we don't need to keep excess.
pieces[pointer++]=piece;}continue;}// We've encountered a real directory. Move it to the next insertion pointer, which accounts for
// any popped or dropped directories.
pieces[pointer++]=piece;positive++;}let path='';for(let i=1;i<pointer;i++){path+='/'+pieces[i];}if(!path||addTrailingSlash&&!path.endsWith('/..')){path+='/';}url.path=path;}/**
 * Attempts to resolve \`input\` URL/path relative to \`base\`.
 */function resolve$1(input,base){if(!input&&!base)return'';const url=parseUrl(input);let inputType=url.type;if(base&&inputType!==UrlType.Absolute){const baseUrl=parseUrl(base);const baseType=baseUrl.type;switch(inputType){case UrlType.Empty:url.hash=baseUrl.hash;// fall through
case UrlType.Hash:url.query=baseUrl.query;// fall through
case UrlType.Query:case UrlType.RelativePath:mergePaths(url,baseUrl);// fall through
case UrlType.AbsolutePath:// The host, user, and port are joined, you can't copy one without the others.
url.user=baseUrl.user;url.host=baseUrl.host;url.port=baseUrl.port;// fall through
case UrlType.SchemeRelative:// The input doesn't have a schema at least, so we need to copy at least that over.
url.scheme=baseUrl.scheme;}if(baseType>inputType)inputType=baseType;}normalizePath(url,inputType);const queryHash=url.query+url.hash;switch(inputType){// This is impossible, because of the empty checks at the start of the function.
// case UrlType.Empty:
case UrlType.Hash:case UrlType.Query:return queryHash;case UrlType.RelativePath:{// The first char is always a "/", and we need it to be relative.
const path=url.path.slice(1);if(!path)return queryHash||'.';if(isRelative(base||input)&&!isRelative(path)){// If base started with a leading ".", or there is no base and input started with a ".",
// then we need to ensure that the relative path starts with a ".". We don't know if
// relative starts with a "..", though, so check before prepending.
return'./'+path+queryHash;}return path+queryHash;}case UrlType.AbsolutePath:return url.path+queryHash;default:return url.scheme+'//'+url.user+url.host+url.port+url.path+queryHash;}}function resolve(input,base){// The base is always treated as a directory, if it's not empty.
// https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327
// https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401
if(base&&!base.endsWith('/'))base+='/';return resolve$1(input,base);}/**
 * Removes everything after the last "/", but leaves the slash.
 */function stripFilename(path){if(!path)return'';const index=path.lastIndexOf('/');return path.slice(0,index+1);}const COLUMN=0;const SOURCES_INDEX=1;const SOURCE_LINE=2;const SOURCE_COLUMN=3;const NAMES_INDEX=4;function maybeSort(mappings,owned){const unsortedIndex=nextUnsortedSegmentLine(mappings,0);if(unsortedIndex===mappings.length)return mappings;// If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If
// not, we do not want to modify the consumer's input array.
if(!owned)mappings=mappings.slice();for(let i=unsortedIndex;i<mappings.length;i=nextUnsortedSegmentLine(mappings,i+1)){mappings[i]=sortSegments(mappings[i],owned);}return mappings;}function nextUnsortedSegmentLine(mappings,start){for(let i=start;i<mappings.length;i++){if(!isSorted(mappings[i]))return i;}return mappings.length;}function isSorted(line){for(let j=1;j<line.length;j++){if(line[j][COLUMN]<line[j-1][COLUMN]){return false;}}return true;}function sortSegments(line,owned){if(!owned)line=line.slice();return line.sort(sortComparator);}function sortComparator(a,b){return a[COLUMN]-b[COLUMN];}let found=false;/**
 * A binary search implementation that returns the index if a match is found.
 * If no match is found, then the left-index (the index associated with the item that comes just
 * before the desired index) is returned. To maintain proper sort order, a splice would happen at
 * the next index:
 *
 * \`\`\`js
 * const array = [1, 3];
 * const needle = 2;
 * const index = binarySearch(array, needle, (item, needle) => item - needle);
 *
 * assert.equal(index, 0);
 * array.splice(index + 1, 0, needle);
 * assert.deepEqual(array, [1, 2, 3]);
 * \`\`\`
 */function binarySearch(haystack,needle,low,high){while(low<=high){const mid=low+(high-low>>1);const cmp=haystack[mid][COLUMN]-needle;if(cmp===0){found=true;return mid;}if(cmp<0){low=mid+1;}else{high=mid-1;}}found=false;return low-1;}function upperBound(haystack,needle,index){for(let i=index+1;i<haystack.length;index=i++){if(haystack[i][COLUMN]!==needle)break;}return index;}function lowerBound(haystack,needle,index){for(let i=index-1;i>=0;index=i--){if(haystack[i][COLUMN]!==needle)break;}return index;}function memoizedState(){return{lastKey:-1,lastNeedle:-1,lastIndex:-1};}/**
 * This overly complicated beast is just to record the last tested line/column and the resulting
 * index, allowing us to skip a few tests if mappings are monotonically increasing.
 */function memoizedBinarySearch(haystack,needle,state,key){const lastKey=state.lastKey,lastNeedle=state.lastNeedle,lastIndex=state.lastIndex;let low=0;let high=haystack.length-1;if(key===lastKey){if(needle===lastNeedle){found=lastIndex!==-1&&haystack[lastIndex][COLUMN]===needle;return lastIndex;}if(needle>=lastNeedle){// lastIndex may be -1 if the previous needle was not found.
low=lastIndex===-1?0:lastIndex;}else{high=lastIndex;}}state.lastKey=key;state.lastNeedle=needle;return state.lastIndex=binarySearch(haystack,needle,low,high);}const LINE_GTR_ZERO='\`line\` must be greater than 0 (lines start at line 1)';const COL_GTR_EQ_ZERO='\`column\` must be greater than or equal to 0 (columns start at column 0)';const LEAST_UPPER_BOUND=-1;const GREATEST_LOWER_BOUND=1;/**
 * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.
 */let decodedMappings;/**
 * A higher-level API to find the source/line/column associated with a generated line/column
 * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
 * \`source-map\` library.
 */let originalPositionFor;class TraceMap{constructor(map,mapUrl){const isString=typeof map==='string';if(!isString&&map._decodedMemo)return map;const parsed=isString?JSON.parse(map):map;const version=parsed.version,file=parsed.file,names=parsed.names,sourceRoot=parsed.sourceRoot,sources=parsed.sources,sourcesContent=parsed.sourcesContent;this.version=version;this.file=file;this.names=names||[];this.sourceRoot=sourceRoot;this.sources=sources;this.sourcesContent=sourcesContent;const from=resolve(sourceRoot||'',stripFilename(mapUrl));this.resolvedSources=sources.map(s=>resolve(s||'',from));const mappings=parsed.mappings;if(typeof mappings==='string'){this._encoded=mappings;this._decoded=undefined;}else{this._encoded=undefined;this._decoded=maybeSort(mappings,isString);}this._decodedMemo=memoizedState();this._bySources=undefined;this._bySourceMemos=undefined;}}(()=>{decodedMappings=map=>{return map._decoded||(map._decoded=decode(map._encoded));};originalPositionFor=(map,{line,column,bias})=>{line--;if(line<0)throw new Error(LINE_GTR_ZERO);if(column<0)throw new Error(COL_GTR_EQ_ZERO);const decoded=decodedMappings(map);// It's common for parent source maps to have pointers to lines that have no
// mapping (like a "//# sourceMappingURL=") at the end of the child file.
if(line>=decoded.length)return OMapping(null,null,null,null);const segments=decoded[line];const index=traceSegmentInternal(segments,map._decodedMemo,line,column,bias||GREATEST_LOWER_BOUND);if(index===-1)return OMapping(null,null,null,null);const segment=segments[index];if(segment.length===1)return OMapping(null,null,null,null);const names=map.names,resolvedSources=map.resolvedSources;return OMapping(resolvedSources[segment[SOURCES_INDEX]],segment[SOURCE_LINE]+1,segment[SOURCE_COLUMN],segment.length===5?names[segment[NAMES_INDEX]]:null);};})();function OMapping(source,line,column,name){return{source,line,column,name};}function traceSegmentInternal(segments,memo,line,column,bias){let index=memoizedBinarySearch(segments,column,memo,line);if(found){index=(bias===LEAST_UPPER_BOUND?upperBound:lowerBound)(segments,column,index);}else if(bias===LEAST_UPPER_BOUND)index++;if(index===-1||index===segments.length)return-1;return index;}const CHROME_IE_STACK_REGEXP=/^\\s*at .*(\\S+:\\d+|\\(native\\))/m;const SAFARI_NATIVE_CODE_REGEXP=/^(eval@)?(\\[native code])?$/;const stackIgnorePatterns=["node:internal",/\\/packages\\/\\w+\\/dist\\//,/\\/@vitest\\/\\w+\\/dist\\//,"/vitest/dist/","/vitest/src/","/vite-node/dist/","/vite-node/src/","/node_modules/chai/","/node_modules/tinypool/","/node_modules/tinyspy/","/deps/chai.js",/__vitest_browser__/];function extractLocation(urlLike){if(!urlLike.includes(":"))return[urlLike];const regExp=/(.+?)(?::(\\d+))?(?::(\\d+))?$/;const parts=regExp.exec(urlLike.replace(/^\\(|\\)$/g,""));if(!parts)return[urlLike];let url=parts[1];if(url.startsWith("http:")||url.startsWith("https:")){const urlObj=new URL(url);url=urlObj.pathname;}if(url.startsWith("/@fs/")){url=url.slice(typeof process!=="undefined"&&process.platform==="win32"?5:4);}return[url,parts[2]||void 0,parts[3]||void 0];}function parseSingleFFOrSafariStack(raw){let line=raw.trim();if(SAFARI_NATIVE_CODE_REGEXP.test(line))return null;if(line.includes(" > eval"))line=line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,":$1");if(!line.includes("@")&&!line.includes(":"))return null;const functionNameRegex=/((.*".+"[^@]*)?[^@]*)(?:@)/;const matches=line.match(functionNameRegex);const functionName=matches&&matches[1]?matches[1]:void 0;const _extractLocation=extractLocation(line.replace(functionNameRegex,"")),_extractLocation2=_slicedToArray(_extractLocation,3),url=_extractLocation2[0],lineNumber=_extractLocation2[1],columnNumber=_extractLocation2[2];if(!url||!lineNumber||!columnNumber)return null;return{file:url,method:functionName||"",line:Number.parseInt(lineNumber),column:Number.parseInt(columnNumber)};}function parseSingleV8Stack(raw){let line=raw.trim();if(!CHROME_IE_STACK_REGEXP.test(line))return null;if(line.includes("(eval "))line=line.replace(/eval code/g,"eval").replace(/(\\(eval at [^()]*)|(,.*$)/g,"");let sanitizedLine=line.replace(/^\\s+/,"").replace(/\\(eval code/g,"(").replace(/^.*?\\s+/,"");const location=sanitizedLine.match(/ (\\(.+\\)$)/);sanitizedLine=location?sanitizedLine.replace(location[0],""):sanitizedLine;const _extractLocation3=extractLocation(location?location[1]:sanitizedLine),_extractLocation4=_slicedToArray(_extractLocation3,3),url=_extractLocation4[0],lineNumber=_extractLocation4[1],columnNumber=_extractLocation4[2];let method=location&&sanitizedLine||"";let file=url&&["eval","<anonymous>"].includes(url)?void 0:url;if(!file||!lineNumber||!columnNumber)return null;if(method.startsWith("async "))method=method.slice(6);if(file.startsWith("file://"))file=file.slice(7);file=resolve$3(file);if(method)method=method.replace(/__vite_ssr_import_\\d+__\\./g,"");return{method,file,line:Number.parseInt(lineNumber),column:Number.parseInt(columnNumber)};}function parseStacktrace(stack,options={}){const _options$ignoreStackE=options.ignoreStackEntries,ignoreStackEntries=_options$ignoreStackE===void 0?stackIgnorePatterns:_options$ignoreStackE;let stacks=!CHROME_IE_STACK_REGEXP.test(stack)?parseFFOrSafariStackTrace(stack):parseV8Stacktrace(stack);if(ignoreStackEntries.length)stacks=stacks.filter(stack2=>!ignoreStackEntries.some(p=>stack2.file.match(p)));return stacks.map(stack2=>{var _a;const map=(_a=options.getSourceMap)==null?void 0:_a.call(options,stack2.file);if(!map||typeof map!=="object"||!map.version)return stack2;const traceMap=new TraceMap(map);const _originalPositionFor=originalPositionFor(traceMap,stack2),line=_originalPositionFor.line,column=_originalPositionFor.column;if(line!=null&&column!=null)return _objectSpread(_objectSpread({},stack2),{},{line,column});return stack2;});}function parseFFOrSafariStackTrace(stack){return stack.split("\\n").map(line=>parseSingleFFOrSafariStack(line)).filter(notNullish);}function parseV8Stacktrace(stack){return stack.split("\\n").map(line=>parseSingleV8Stack(line)).filter(notNullish);}function parseErrorStacktrace(e,options={}){if(!e||isPrimitive(e))return[];if(e.stacks)return e.stacks;const stackStr=e.stack||e.stackStr||"";let stackFrames=parseStacktrace(stackStr,options);if(options.frameFilter)stackFrames=stackFrames.filter(f=>options.frameFilter(e,f)!==false);e.stacks=stackFrames;return stackFrames;}async function saveInlineSnapshots(environment,snapshots){const MagicString=(await import('./bundle-D7lcxiVj.js')).default;const files=new Set(snapshots.map(i=>i.file));await Promise.all(Array.from(files).map(async file=>{const snaps=snapshots.filter(i=>i.file===file);const code=await environment.readSnapshotFile(file);const s=new MagicString(code);for(const snap of snaps){const index=positionToOffset(code,snap.line,snap.column);replaceInlineSnap(code,s,index,snap.snapshot);}const transformed=s.toString();if(transformed!==code)await environment.saveSnapshotFile(file,transformed);}));}const startObjectRegex=/(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\\s*\\(\\s*(?:\\/\\*[\\S\\s]*\\*\\/\\s*|\\/\\/.*\\s+)*\\s*({)/m;function replaceObjectSnap(code,s,index,newSnap){let _code=code.slice(index);const startMatch=startObjectRegex.exec(_code);if(!startMatch)return false;_code=_code.slice(startMatch.index);let callEnd=getCallLastIndex(_code);if(callEnd===null)return false;callEnd+=index+startMatch.index;const shapeStart=index+startMatch.index+startMatch[0].length;const shapeEnd=getObjectShapeEndIndex(code,shapeStart);const snap=\`, \${prepareSnapString(newSnap,code,index)}\`;if(shapeEnd===callEnd){s.appendLeft(callEnd,snap);}else{s.overwrite(shapeEnd,callEnd,snap);}return true;}function getObjectShapeEndIndex(code,index){let startBraces=1;let endBraces=0;while(startBraces!==endBraces&&index<code.length){const s=code[index++];if(s==="{")startBraces++;else if(s==="}")endBraces++;}return index;}function prepareSnapString(snap,source,index){const lineNumber=offsetToLineNumber(source,index);const line=source.split(lineSplitRE)[lineNumber-1];const indent=line.match(/^\\s*/)[0]||"";const indentNext=indent.includes("	")?\`\${indent}	\`:\`\${indent}  \`;const lines=snap.trim().replace(/\\\\/g,"\\\\\\\\").split(/\\n/g);const isOneline=lines.length<=1;const quote="\`";if(isOneline)return\`\${quote}\${lines.join("\\n").replace(/\`/g,"\\\\\`").replace(/\\\${/g,"\\\\\${")}\${quote}\`;return\`\${quote}
\${lines.map(i=>i?indentNext+i:"").join("\\n").replace(/\`/g,"\\\\\`").replace(/\\\${/g,"\\\\\${")}
\${indent}\${quote}\`;}const startRegex=/(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\\s*\\(\\s*(?:\\/\\*[\\S\\s]*\\*\\/\\s*|\\/\\/.*\\s+)*\\s*[\\w_$]*(['"\`\\)])/m;function replaceInlineSnap(code,s,index,newSnap){const codeStartingAtIndex=code.slice(index);const startMatch=startRegex.exec(codeStartingAtIndex);const firstKeywordMatch=/toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot/.exec(codeStartingAtIndex);if(!startMatch||startMatch.index!==(firstKeywordMatch==null?void 0:firstKeywordMatch.index))return replaceObjectSnap(code,s,index,newSnap);const quote=startMatch[1];const startIndex=index+startMatch.index+startMatch[0].length;const snapString=prepareSnapString(newSnap,code,index);if(quote===")"){s.appendRight(startIndex-1,snapString);return true;}const quoteEndRE=new RegExp(\`(?:^|[^\\\\\\\\])\${quote}\`);const endMatch=quoteEndRE.exec(code.slice(startIndex));if(!endMatch)return false;const endIndex=startIndex+endMatch.index+endMatch[0].length;s.overwrite(startIndex-1,endIndex,snapString);return true;}const INDENTATION_REGEX=/^([^\\S\\n]*)\\S/m;function stripSnapshotIndentation(inlineSnapshot){const match=inlineSnapshot.match(INDENTATION_REGEX);if(!match||!match[1]){return inlineSnapshot;}const indentation=match[1];const lines=inlineSnapshot.split(/\\n/g);if(lines.length<=2){return inlineSnapshot;}if(lines[0].trim()!==""||lines[lines.length-1].trim()!==""){return inlineSnapshot;}for(let i=1;i<lines.length-1;i++){if(lines[i]!==""){if(lines[i].indexOf(indentation)!==0){return inlineSnapshot;}lines[i]=lines[i].substring(indentation.length);}}lines[lines.length-1]="";inlineSnapshot=lines.join("\\n");return inlineSnapshot;}async function saveRawSnapshots(environment,snapshots){await Promise.all(snapshots.map(async snap=>{if(!snap.readonly)await environment.saveSnapshotFile(snap.file,snap.snapshot);}));}class SnapshotState{constructor(testFilePath,snapshotPath,snapshotContent,options){this.testFilePath=testFilePath;this.snapshotPath=snapshotPath;const _getSnapshotData=getSnapshotData(snapshotContent,options),data=_getSnapshotData.data,dirty=_getSnapshotData.dirty;this._fileExists=snapshotContent!=null;this._initialData=data;this._snapshotData=data;this._dirty=dirty;this._inlineSnapshots=[];this._rawSnapshots=[];this._uncheckedKeys=new Set(Object.keys(this._snapshotData));this._counters=/* @__PURE__ */new Map();this.expand=options.expand||false;this.added=0;this.matched=0;this.unmatched=0;this._updateSnapshot=options.updateSnapshot;this.updated=0;this._snapshotFormat=_objectSpread({printBasicPrototype:false,escapeString:false},options.snapshotFormat);this._environment=options.snapshotEnvironment;}_counters;_dirty;_updateSnapshot;_snapshotData;_initialData;_inlineSnapshots;_rawSnapshots;_uncheckedKeys;_snapshotFormat;_environment;_fileExists;added;expand;matched;unmatched;updated;static async create(testFilePath,options){const snapshotPath=await options.snapshotEnvironment.resolvePath(testFilePath);const content=await options.snapshotEnvironment.readSnapshotFile(snapshotPath);return new SnapshotState(testFilePath,snapshotPath,content,options);}get environment(){return this._environment;}markSnapshotsAsCheckedForTest(testName){this._uncheckedKeys.forEach(uncheckedKey=>{if(keyToTestName(uncheckedKey)===testName)this._uncheckedKeys.delete(uncheckedKey);});}_inferInlineSnapshotStack(stacks){const promiseIndex=stacks.findIndex(i=>i.method.match(/__VITEST_(RESOLVES|REJECTS)__/));if(promiseIndex!==-1)return stacks[promiseIndex+3];const stackIndex=stacks.findIndex(i=>i.method.includes("__INLINE_SNAPSHOT__"));return stackIndex!==-1?stacks[stackIndex+2]:null;}_addSnapshot(key,receivedSerialized,options){this._dirty=true;if(options.isInline){const stacks=parseErrorStacktrace(options.error||new Error("snapshot"),{ignoreStackEntries:[]});const stack=this._inferInlineSnapshotStack(stacks);if(!stack){throw new Error(\`@vitest/snapshot: Couldn't infer stack frame for inline snapshot.
\${JSON.stringify(stacks)}\`);}stack.column--;this._inlineSnapshots.push(_objectSpread({snapshot:receivedSerialized},stack));}else if(options.rawSnapshot){this._rawSnapshots.push(_objectSpread(_objectSpread({},options.rawSnapshot),{},{snapshot:receivedSerialized}));}else{this._snapshotData[key]=receivedSerialized;}}clear(){this._snapshotData=this._initialData;this._counters=/* @__PURE__ */new Map();this.added=0;this.matched=0;this.unmatched=0;this.updated=0;this._dirty=false;}async save(){const hasExternalSnapshots=Object.keys(this._snapshotData).length;const hasInlineSnapshots=this._inlineSnapshots.length;const hasRawSnapshots=this._rawSnapshots.length;const isEmpty=!hasExternalSnapshots&&!hasInlineSnapshots&&!hasRawSnapshots;const status={deleted:false,saved:false};if((this._dirty||this._uncheckedKeys.size)&&!isEmpty){if(hasExternalSnapshots){await saveSnapshotFile(this._environment,this._snapshotData,this.snapshotPath);this._fileExists=true;}if(hasInlineSnapshots)await saveInlineSnapshots(this._environment,this._inlineSnapshots);if(hasRawSnapshots)await saveRawSnapshots(this._environment,this._rawSnapshots);status.saved=true;}else if(!hasExternalSnapshots&&this._fileExists){if(this._updateSnapshot==="all"){await this._environment.removeSnapshotFile(this.snapshotPath);this._fileExists=false;}status.deleted=true;}return status;}getUncheckedCount(){return this._uncheckedKeys.size||0;}getUncheckedKeys(){return Array.from(this._uncheckedKeys);}removeUncheckedKeys(){if(this._updateSnapshot==="all"&&this._uncheckedKeys.size){this._dirty=true;this._uncheckedKeys.forEach(key=>delete this._snapshotData[key]);this._uncheckedKeys.clear();}}match({testName,received,key,inlineSnapshot,isInline,error,rawSnapshot}){this._counters.set(testName,(this._counters.get(testName)||0)+1);const count=Number(this._counters.get(testName));if(!key)key=testNameToKey(testName,count);if(!(isInline&&this._snapshotData[key]!==void 0))this._uncheckedKeys.delete(key);let receivedSerialized=rawSnapshot&&typeof received==="string"?received:serialize(received,void 0,this._snapshotFormat);if(!rawSnapshot)receivedSerialized=addExtraLineBreaks(receivedSerialized);if(rawSnapshot){if(rawSnapshot.content&&rawSnapshot.content.match(/\\r\\n/)&&!receivedSerialized.match(/\\r\\n/))rawSnapshot.content=normalizeNewlines(rawSnapshot.content);}const expected=isInline?inlineSnapshot:rawSnapshot?rawSnapshot.content:this._snapshotData[key];const expectedTrimmed=prepareExpected(expected);const pass=expectedTrimmed===prepareExpected(receivedSerialized);const hasSnapshot=expected!==void 0;const snapshotIsPersisted=isInline||this._fileExists||rawSnapshot&&rawSnapshot.content!=null;if(pass&&!isInline&&!rawSnapshot){this._snapshotData[key]=receivedSerialized;}if(hasSnapshot&&this._updateSnapshot==="all"||(!hasSnapshot||!snapshotIsPersisted)&&(this._updateSnapshot==="new"||this._updateSnapshot==="all")){if(this._updateSnapshot==="all"){if(!pass){if(hasSnapshot)this.updated++;else this.added++;this._addSnapshot(key,receivedSerialized,{error,isInline,rawSnapshot});}else{this.matched++;}}else{this._addSnapshot(key,receivedSerialized,{error,isInline,rawSnapshot});this.added++;}return{actual:"",count,expected:"",key,pass:true};}else{if(!pass){this.unmatched++;return{actual:removeExtraLineBreaks(receivedSerialized),count,expected:expectedTrimmed!==void 0?removeExtraLineBreaks(expectedTrimmed):void 0,key,pass:false};}else{this.matched++;return{actual:"",count,expected:"",key,pass:true};}}}async pack(){const snapshot={filepath:this.testFilePath,added:0,fileDeleted:false,matched:0,unchecked:0,uncheckedKeys:[],unmatched:0,updated:0};const uncheckedCount=this.getUncheckedCount();const uncheckedKeys=this.getUncheckedKeys();if(uncheckedCount)this.removeUncheckedKeys();const status=await this.save();snapshot.fileDeleted=status.deleted;snapshot.added=this.added;snapshot.matched=this.matched;snapshot.unmatched=this.unmatched;snapshot.updated=this.updated;snapshot.unchecked=!status.deleted?uncheckedCount:0;snapshot.uncheckedKeys=Array.from(uncheckedKeys);return snapshot;}}function createMismatchError(message,expand,actual,expected){const error=new Error(message);Object.defineProperty(error,"actual",{value:actual,enumerable:true,configurable:true,writable:true});Object.defineProperty(error,"expected",{value:expected,enumerable:true,configurable:true,writable:true});Object.defineProperty(error,"diffOptions",{value:{expand}});return error;}class SnapshotClient{constructor(options={}){this.options=options;}filepath;name;snapshotState;snapshotStateMap=/* @__PURE__ */new Map();async startCurrentRun(filepath,name,options){var _a;this.filepath=filepath;this.name=name;if(((_a=this.snapshotState)==null?void 0:_a.testFilePath)!==filepath){await this.finishCurrentRun();if(!this.getSnapshotState(filepath)){this.snapshotStateMap.set(filepath,await SnapshotState.create(filepath,options));}this.snapshotState=this.getSnapshotState(filepath);}}getSnapshotState(filepath){return this.snapshotStateMap.get(filepath);}clearTest(){this.filepath=void 0;this.name=void 0;}skipTestSnapshots(name){var _a;(_a=this.snapshotState)==null?void 0:_a.markSnapshotsAsCheckedForTest(name);}assert(options){var _a,_b,_c,_d;const _options$filepath=options.filepath,filepath=_options$filepath===void 0?this.filepath:_options$filepath,_options$name=options.name,name=_options$name===void 0?this.name:_options$name,message=options.message,_options$isInline=options.isInline,isInline=_options$isInline===void 0?false:_options$isInline,properties=options.properties,inlineSnapshot=options.inlineSnapshot,error=options.error,errorMessage=options.errorMessage,rawSnapshot=options.rawSnapshot;let received=options.received;if(!filepath)throw new Error("Snapshot cannot be used outside of test");if(typeof properties==="object"){if(typeof received!=="object"||!received)throw new Error("Received value must be an object when the matcher has properties");try{const pass2=((_b=(_a=this.options).isEqual)==null?void 0:_b.call(_a,received,properties))??false;if(!pass2)throw createMismatchError("Snapshot properties mismatched",(_c=this.snapshotState)==null?void 0:_c.expand,received,properties);else received=deepMergeSnapshot(received,properties);}catch(err){err.message=errorMessage||"Snapshot mismatched";throw err;}}const testName=[name,...(message?[message]:[])].join(" > ");const snapshotState=this.getSnapshotState(filepath);const _snapshotState$match=snapshotState.match({testName,received,isInline,error,inlineSnapshot,rawSnapshot}),actual=_snapshotState$match.actual,expected=_snapshotState$match.expected,key=_snapshotState$match.key,pass=_snapshotState$match.pass;if(!pass)throw createMismatchError(\`Snapshot \\\`\${key||"unknown"}\\\` mismatched\`,(_d=this.snapshotState)==null?void 0:_d.expand,actual==null?void 0:actual.trim(),expected==null?void 0:expected.trim());}async assertRaw(options){if(!options.rawSnapshot)throw new Error("Raw snapshot is required");const _options$filepath2=options.filepath,filepath=_options$filepath2===void 0?this.filepath:_options$filepath2,rawSnapshot=options.rawSnapshot;if(rawSnapshot.content==null){if(!filepath)throw new Error("Snapshot cannot be used outside of test");const snapshotState=this.getSnapshotState(filepath);options.filepath||(options.filepath=filepath);rawSnapshot.file=await snapshotState.environment.resolveRawPath(filepath,rawSnapshot.file);rawSnapshot.content=(await snapshotState.environment.readSnapshotFile(rawSnapshot.file))||void 0;}return this.assert(options);}async finishCurrentRun(){if(!this.snapshotState)return null;const result=await this.snapshotState.pack();this.snapshotState=void 0;return result;}clear(){this.snapshotStateMap.clear();}}function getFullName(task,separator=" > "){return getNames(task).join(separator);}function isChildProcess(){return typeof process!=="undefined"&&!!process.send;}const RealDate=Date;let now=null;class MockDate extends RealDate{constructor(y,m,d,h,M,s,ms){super();let date;switch(arguments.length){case 0:if(now!==null)date=new RealDate(now.valueOf());else date=new RealDate();break;case 1:date=new RealDate(y);break;default:d=typeof d==="undefined"?1:d;h=h||0;M=M||0;s=s||0;ms=ms||0;date=new RealDate(y,m,d,h,M,s,ms);break;}Object.setPrototypeOf(date,MockDate.prototype);return date;}}MockDate.UTC=RealDate.UTC;MockDate.now=function(){return new MockDate().valueOf();};MockDate.parse=function(dateString){return RealDate.parse(dateString);};MockDate.toString=function(){return RealDate.toString();};function mockDate(date){const dateObj=new RealDate(date.valueOf());if(Number.isNaN(dateObj.getTime()))throw new TypeError(\`mockdate: The time set is an invalid date: \${date}\`);globalThis.Date=MockDate;now=dateObj.valueOf();}function resetDate(){globalThis.Date=RealDate;}function resetModules(modules,resetMocks=false){const skipPaths=[// Vitest
/\\/vitest\\/dist\\//,/\\/vite-node\\/dist\\//,// yarn's .store folder
/vitest-virtual-\\w+\\/dist/,// cnpm
/@vitest\\/dist/,// don't clear mocks
...(!resetMocks?[/^mock:/]:[])];modules.forEach((mod,path)=>{if(skipPaths.some(re=>re.test(path)))return;modules.invalidateModule(mod);});}function waitNextTick(){const _getSafeTimers2=getSafeTimers(),setTimeout=_getSafeTimers2.setTimeout;return new Promise(resolve=>setTimeout(resolve,0));}async function waitForImportsToResolve(){await waitNextTick();const state=getWorkerState();const promises=[];let resolvingCount=0;for(const mod of state.moduleCache.values()){if(mod.promise&&!mod.evaluated)promises.push(mod.promise);if(mod.resolving)resolvingCount++;}if(!promises.length&&!resolvingCount)return;await Promise.allSettled(promises);await waitForImportsToResolve();}function commonjsRequire(path){throw new Error('Could not dynamically require "'+path+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');}var chaiSubset={exports:{}};(function(module,exports){(function(){(function(chaiSubset){if(typeof commonjsRequire==='function'&&'object'==='object'&&'object'==='object'){return module.exports=chaiSubset;}else{return chai.use(chaiSubset);}})(function(chai,utils){var Assertion=chai.Assertion;var assertionPrototype=Assertion.prototype;Assertion.addMethod('containSubset',function(expected){var actual=utils.flag(this,'object');var showDiff=chai.config.showDiff;assertionPrototype.assert.call(this,compare(expected,actual),'expected #{act} to contain subset #{exp}','expected #{act} to not contain subset #{exp}',expected,actual,showDiff);});chai.assert.containSubset=function(val,exp,msg){new chai.Assertion(val,msg).to.be.containSubset(exp);};function compare(expected,actual){if(expected===actual){return true;}if(typeof actual!==typeof expected){return false;}if(typeof expected!=='object'||expected===null){return expected===actual;}if(!!expected&&!actual){return false;}if(Array.isArray(expected)){if(typeof actual.length!=='number'){return false;}var aa=Array.prototype.slice.call(actual);return expected.every(function(exp){return aa.some(function(act){return compare(exp,act);});});}if(expected instanceof Date){if(actual instanceof Date){return expected.getTime()===actual.getTime();}else{return false;}}return Object.keys(expected).every(function(key){var eo=expected[key];var ao=actual[key];if(typeof eo==='object'&&eo!==null&&ao!==null){return compare(eo,ao);}if(typeof eo==='function'){return eo(ao);}return ao===eo;});}});}).call(commonjsGlobal);})(chaiSubset);var chaiSubsetExports=chaiSubset.exports;var Subset=/*@__PURE__*/getDefaultExportFromCjs$1(chaiSubsetExports);const MATCHERS_OBJECT=Symbol.for("matchers-object");const JEST_MATCHERS_OBJECT=Symbol.for("$$jest-matchers-object");const GLOBAL_EXPECT=Symbol.for("expect-global");const ASYMMETRIC_MATCHERS_OBJECT=Symbol.for("asymmetric-matchers-object");if(!Object.prototype.hasOwnProperty.call(globalThis,MATCHERS_OBJECT)){const globalState=/* @__PURE__ */new WeakMap();const matchers=/* @__PURE__ */Object.create(null);const customEqualityTesters=[];const assymetricMatchers=/* @__PURE__ */Object.create(null);Object.defineProperty(globalThis,MATCHERS_OBJECT,{get:()=>globalState});Object.defineProperty(globalThis,JEST_MATCHERS_OBJECT,{configurable:true,get:()=>({state:globalState.get(globalThis[GLOBAL_EXPECT]),matchers,customEqualityTesters})});Object.defineProperty(globalThis,ASYMMETRIC_MATCHERS_OBJECT,{get:()=>assymetricMatchers});}function recordAsyncExpect(test,promise){if(test&&promise instanceof Promise){promise=promise.finally(()=>{const index=test.promises.indexOf(promise);if(index!==-1)test.promises.splice(index,1);});if(!test.promises)test.promises=[];test.promises.push(promise);}return promise;}let _client;function getSnapshotClient(){if(!_client){_client=new SnapshotClient({isEqual:(received,expected)=>{return equals(received,expected,[iterableEquality,subsetEquality]);}});}return _client;}function getError(expected,promise){if(typeof expected!=="function"){if(!promise)throw new Error(\`expected must be a function, received \${typeof expected}\`);return expected;}try{expected();}catch(e){return e;}throw new Error("snapshot function didn't throw");}const SnapshotPlugin=(chai,utils)=>{const getTestNames=test=>{var _a;if(!test)return{};return{filepath:(_a=test.file)==null?void 0:_a.filepath,name:getNames(test).slice(1).join(" > ")};};for(const key of["matchSnapshot","toMatchSnapshot"]){utils.addMethod(chai.Assertion.prototype,key,function(properties,message){const isNot=utils.flag(this,"negate");if(isNot)throw new Error(\`\${key} cannot be used with "not"\`);const expected=utils.flag(this,"object");const test=utils.flag(this,"vitest-test");if(typeof properties==="string"&&typeof message==="undefined"){message=properties;properties=void 0;}const errorMessage=utils.flag(this,"message");getSnapshotClient().assert(_objectSpread({received:expected,message,isInline:false,properties,errorMessage},getTestNames(test)));});}utils.addMethod(chai.Assertion.prototype,"toMatchFileSnapshot",function(file,message){const isNot=utils.flag(this,"negate");if(isNot)throw new Error('toMatchFileSnapshot cannot be used with "not"');const expected=utils.flag(this,"object");const test=utils.flag(this,"vitest-test");const errorMessage=utils.flag(this,"message");const promise=getSnapshotClient().assertRaw(_objectSpread({received:expected,message,isInline:false,rawSnapshot:{file},errorMessage},getTestNames(test)));return recordAsyncExpect(test,promise);});utils.addMethod(chai.Assertion.prototype,"toMatchInlineSnapshot",function __INLINE_SNAPSHOT__(properties,inlineSnapshot,message){var _a;const isNot=utils.flag(this,"negate");if(isNot)throw new Error('toMatchInlineSnapshot cannot be used with "not"');const test=utils.flag(this,"vitest-test");const isInsideEach=test&&(test.each||((_a=test.suite)==null?void 0:_a.each));if(isInsideEach)throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");const expected=utils.flag(this,"object");const error=utils.flag(this,"error");if(typeof properties==="string"){message=inlineSnapshot;inlineSnapshot=properties;properties=void 0;}if(inlineSnapshot)inlineSnapshot=stripSnapshotIndentation(inlineSnapshot);const errorMessage=utils.flag(this,"message");getSnapshotClient().assert(_objectSpread({received:expected,message,isInline:true,properties,inlineSnapshot,error,errorMessage},getTestNames(test)));});utils.addMethod(chai.Assertion.prototype,"toThrowErrorMatchingSnapshot",function(message){const isNot=utils.flag(this,"negate");if(isNot)throw new Error('toThrowErrorMatchingSnapshot cannot be used with "not"');const expected=utils.flag(this,"object");const test=utils.flag(this,"vitest-test");const promise=utils.flag(this,"promise");const errorMessage=utils.flag(this,"message");getSnapshotClient().assert(_objectSpread({received:getError(expected,promise),message,errorMessage},getTestNames(test)));});utils.addMethod(chai.Assertion.prototype,"toThrowErrorMatchingInlineSnapshot",function __INLINE_SNAPSHOT__(inlineSnapshot,message){var _a;const isNot=utils.flag(this,"negate");if(isNot)throw new Error('toThrowErrorMatchingInlineSnapshot cannot be used with "not"');const test=utils.flag(this,"vitest-test");const isInsideEach=test&&(test.each||((_a=test.suite)==null?void 0:_a.each));if(isInsideEach)throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");const expected=utils.flag(this,"object");const error=utils.flag(this,"error");const promise=utils.flag(this,"promise");const errorMessage=utils.flag(this,"message");if(inlineSnapshot)inlineSnapshot=stripSnapshotIndentation(inlineSnapshot);getSnapshotClient().assert(_objectSpread({received:getError(expected,promise),message,inlineSnapshot,isInline:true,error,errorMessage},getTestNames(test)));});utils.addMethod(chai.expect,"addSnapshotSerializer",addSerializer);};use(JestExtend);use(JestChaiExpect);use(Subset);use(SnapshotPlugin);use(JestAsymmetricMatchers);function createExpect(test){var _a;const expect$1=(value,message)=>{const _getState=getState(expect$1),assertionCalls=_getState.assertionCalls;setState({assertionCalls:assertionCalls+1,soft:false},expect$1);const assert2=expect(value,message);const _test=test||getCurrentTest();if(_test)return assert2.withTest(_test);else return assert2;};Object.assign(expect$1,expect);Object.assign(expect$1,globalThis[ASYMMETRIC_MATCHERS_OBJECT$1]);expect$1.getState=()=>getState(expect$1);expect$1.setState=state=>setState(state,expect$1);const globalState=getState(globalThis[GLOBAL_EXPECT$1])||{};setState(_objectSpread(_objectSpread({},globalState),{},{assertionCalls:0,isExpectingAssertions:false,isExpectingAssertionsError:null,expectedAssertionsNumber:null,expectedAssertionsNumberErrorGen:null,environment:getCurrentEnvironment(),testPath:test?(_a=test.suite.file)==null?void 0:_a.filepath:globalState.testPath,currentTestName:test?getFullName(test):globalState.currentTestName}),expect$1);expect$1.extend=matchers=>expect.extend(expect$1,matchers);expect$1.addEqualityTesters=customTesters=>addCustomEqualityTesters(customTesters);expect$1.soft=(...args)=>{const assert2=expect$1(...args);expect$1.setState({soft:true});return assert2;};expect$1.unreachable=message=>{assert.fail(\`expected\${message?\` "\${message}" \`:" "}not to be reached\`);};function assertions(expected){const errorGen=()=>new Error(\`expected number of assertions to be \${expected}, but got \${expect$1.getState().assertionCalls}\`);if(Error.captureStackTrace)Error.captureStackTrace(errorGen(),assertions);expect$1.setState({expectedAssertionsNumber:expected,expectedAssertionsNumberErrorGen:errorGen});}function hasAssertions(){const error=new Error("expected any number of assertion, but got none");if(Error.captureStackTrace)Error.captureStackTrace(error,hasAssertions);expect$1.setState({isExpectingAssertions:true,isExpectingAssertionsError:error});}util.addMethod(expect$1,"assertions",assertions);util.addMethod(expect$1,"hasAssertions",hasAssertions);return expect$1;}const globalExpect=createExpect();Object.defineProperty(globalThis,GLOBAL_EXPECT$1,{value:globalExpect,writable:true,configurable:true});/**
 * A reference to the global object
 *
 * @type {object} globalObject
 */var globalObject$1;/* istanbul ignore else */if(typeof commonjsGlobal!=="undefined"){// Node
globalObject$1=commonjsGlobal;}else if(typeof window!=="undefined"){// Browser
globalObject$1=window;}else{// WebWorker
globalObject$1=self;}var global$1=globalObject$1;/**
 * Is true when the environment causes an error to be thrown for accessing the
 * __proto__ property.
 *
 * This is necessary in order to support \`node --disable-proto=throw\`.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto
 *
 * @type {boolean}
 */let throwsOnProto$1;try{const object={};// eslint-disable-next-line no-proto, no-unused-expressions
object.__proto__;throwsOnProto$1=false;}catch(_){// This branch is covered when tests are run with \`--disable-proto=throw\`,
// however we can test both branches at the same time, so this is ignored
/* istanbul ignore next */throwsOnProto$1=true;}var throwsOnProto_1=throwsOnProto$1;var call=Function.call;var throwsOnProto=throwsOnProto_1;var disallowedProperties=[// ignore size because it throws from Map
"size","caller","callee","arguments"];// This branch is covered when tests are run with \`--disable-proto=throw\`,
// however we can test both branches at the same time, so this is ignored
/* istanbul ignore next */if(throwsOnProto){disallowedProperties.push("__proto__");}var copyPrototypeMethods=function copyPrototypeMethods(prototype){// eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods
return Object.getOwnPropertyNames(prototype).reduce(function(result,name){if(disallowedProperties.includes(name)){return result;}if(typeof prototype[name]!=="function"){return result;}result[name]=call.bind(prototype[name]);return result;},Object.create(null));};var copyPrototype$5=copyPrototypeMethods;var array=copyPrototype$5(Array.prototype);var every$1=array.every;/**
 * @private
 */function hasCallsLeft(callMap,spy){if(callMap[spy.id]===undefined){callMap[spy.id]=0;}return callMap[spy.id]<spy.callCount;}/**
 * @private
 */function checkAdjacentCalls(callMap,spy,index,spies){var calledBeforeNext=true;if(index!==spies.length-1){calledBeforeNext=spy.calledBefore(spies[index+1]);}if(hasCallsLeft(callMap,spy)&&calledBeforeNext){callMap[spy.id]+=1;return true;}return false;}/**
 * A Sinon proxy object (fake, spy, stub)
 *
 * @typedef {object} SinonProxy
 * @property {Function} calledBefore - A method that determines if this proxy was called before another one
 * @property {string} id - Some id
 * @property {number} callCount - Number of times this proxy has been called
 */ /**
 * Returns true when the spies have been called in the order they were supplied in
 *
 * @param  {SinonProxy[] | SinonProxy} spies An array of proxies, or several proxies as arguments
 * @returns {boolean} true when spies are called in order, false otherwise
 */function calledInOrder(spies){var callMap={};// eslint-disable-next-line no-underscore-dangle
var _spies=arguments.length>1?arguments:spies;return every$1(_spies,checkAdjacentCalls.bind(null,callMap));}var calledInOrder_1=calledInOrder;/**
 * Returns a display name for a function
 *
 * @param  {Function} func
 * @returns {string}
 */var functionName$1=function functionName(func){if(!func){return"";}try{return func.displayName||func.name||// Use function decomposition as a last resort to get function
// name. Does not rely on function decomposition to work - if it
// doesn't debugging will be slightly less informative
// (i.e. toString will say 'spy' rather than 'myFunc').
(String(func).match(/function ([^\\s(]+)/)||[])[1];}catch(e){// Stringify may fail and we might get an exception, as a last-last
// resort fall back to empty string.
return"";}};var functionName=functionName$1;/**
 * Returns a display name for a value from a constructor
 *
 * @param  {object} value A value to examine
 * @returns {(string|null)} A string or null
 */function className(value){return value.constructor&&value.constructor.name||// The next branch is for IE11 support only:
// Because the name property is not set on the prototype
// of the Function object, we finally try to grab the
// name from its definition. This will never be reached
// in node, so we are not able to test this properly.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
typeof value.constructor==="function"&&/* istanbul ignore next */functionName(value.constructor)||null;}var className_1=className;var deprecated={};/* eslint-disable no-console */(function(exports){/**
   * Returns a function that will invoke the supplied function and print a
   * deprecation warning to the console each time it is called.
   *
   * @param  {Function} func
   * @param  {string} msg
   * @returns {Function}
   */exports.wrap=function(func,msg){var wrapped=function(){exports.printWarning(msg);return func.apply(this,arguments);};if(func.prototype){wrapped.prototype=func.prototype;}return wrapped;};/**
   * Returns a string which can be supplied to \`wrap()\` to notify the user that a
   * particular part of the sinon API has been deprecated.
   *
   * @param  {string} packageName
   * @param  {string} funcName
   * @returns {string}
   */exports.defaultMsg=function(packageName,funcName){return\`\${packageName}.\${funcName} is deprecated and will be removed from the public API in a future version of \${packageName}.\`;};/**
   * Prints a warning on the console, when it exists
   *
   * @param  {string} msg
   * @returns {undefined}
   */exports.printWarning=function(msg){/* istanbul ignore next */if(typeof process==="object"&&process.emitWarning){// Emit Warnings in Node
process.emitWarning(msg);}else if(console.info){console.info(msg);}else{console.log(msg);}};})(deprecated);/**
 * Returns true when fn returns true for all members of obj.
 * This is an every implementation that works for all iterables
 *
 * @param  {object}   obj
 * @param  {Function} fn
 * @returns {boolean}
 */var every=function every(obj,fn){var pass=true;try{// eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods
obj.forEach(function(){if(!fn.apply(this,arguments)){// Throwing an error is the only way to break \`forEach\`
throw new Error();}});}catch(e){pass=false;}return pass;};var sort=array.sort;var slice=array.slice;/**
 * @private
 */function comparator(a,b){// uuid, won't ever be equal
var aCall=a.getCall(0);var bCall=b.getCall(0);var aId=aCall&&aCall.callId||-1;var bId=bCall&&bCall.callId||-1;return aId<bId?-1:1;}/**
 * A Sinon proxy object (fake, spy, stub)
 *
 * @typedef {object} SinonProxy
 * @property {Function} getCall - A method that can return the first call
 */ /**
 * Sorts an array of SinonProxy instances (fake, spy, stub) by their first call
 *
 * @param  {SinonProxy[] | SinonProxy} spies
 * @returns {SinonProxy[]}
 */function orderByFirstCall(spies){return sort(slice(spies),comparator);}var orderByFirstCall_1=orderByFirstCall;var copyPrototype$4=copyPrototypeMethods;var _function=copyPrototype$4(Function.prototype);var copyPrototype$3=copyPrototypeMethods;var map=copyPrototype$3(Map.prototype);var copyPrototype$2=copyPrototypeMethods;var object=copyPrototype$2(Object.prototype);var copyPrototype$1=copyPrototypeMethods;var set=copyPrototype$1(Set.prototype);var copyPrototype=copyPrototypeMethods;var string=copyPrototype(String.prototype);var prototypes={array:array,function:_function,map:map,object:object,set:set,string:string};var typeDetect={exports:{}};(function(module,exports){(function(global,factory){module.exports=factory();})(commonjsGlobal,function(){/* !
     * type-detect
     * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
     * MIT Licensed
     */var promiseExists=typeof Promise==='function';/* eslint-disable no-undef */var globalObject=typeof self==='object'?self:commonjsGlobal;// eslint-disable-line id-blacklist
var symbolExists=typeof Symbol!=='undefined';var mapExists=typeof Map!=='undefined';var setExists=typeof Set!=='undefined';var weakMapExists=typeof WeakMap!=='undefined';var weakSetExists=typeof WeakSet!=='undefined';var dataViewExists=typeof DataView!=='undefined';var symbolIteratorExists=symbolExists&&typeof Symbol.iterator!=='undefined';var symbolToStringTagExists=symbolExists&&typeof Symbol.toStringTag!=='undefined';var setEntriesExists=setExists&&typeof Set.prototype.entries==='function';var mapEntriesExists=mapExists&&typeof Map.prototype.entries==='function';var setIteratorPrototype=setEntriesExists&&Object.getPrototypeOf(new Set().entries());var mapIteratorPrototype=mapEntriesExists&&Object.getPrototypeOf(new Map().entries());var arrayIteratorExists=symbolIteratorExists&&typeof Array.prototype[Symbol.iterator]==='function';var arrayIteratorPrototype=arrayIteratorExists&&Object.getPrototypeOf([][Symbol.iterator]());var stringIteratorExists=symbolIteratorExists&&typeof String.prototype[Symbol.iterator]==='function';var stringIteratorPrototype=stringIteratorExists&&Object.getPrototypeOf(''[Symbol.iterator]());var toStringLeftSliceLength=8;var toStringRightSliceLength=-1;/**
     * ### typeOf (obj)
     *
     * Uses \`Object.prototype.toString\` to determine the type of an object,
     * normalising behaviour across engine versions & well optimised.
     *
     * @param {Mixed} object
     * @return {String} object type
     * @api public
     */function typeDetect(obj){/* ! Speed optimisation
       * Pre:
       *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
       *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
       *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
       *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
       *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
       * Post:
       *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
       *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
       *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
       *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
       *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
       */var typeofObj=typeof obj;if(typeofObj!=='object'){return typeofObj;}/* ! Speed optimisation
       * Pre:
       *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
       * Post:
       *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
       */if(obj===null){return'null';}/* ! Spec Conformance
       * Test: \`Object.prototype.toString.call(window)\`\`
       *  - Node === "[object global]"
       *  - Chrome === "[object global]"
       *  - Firefox === "[object Window]"
       *  - PhantomJS === "[object Window]"
       *  - Safari === "[object Window]"
       *  - IE 11 === "[object Window]"
       *  - IE Edge === "[object Window]"
       * Test: \`Object.prototype.toString.call(this)\`\`
       *  - Chrome Worker === "[object global]"
       *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
       *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
       *  - IE 11 Worker === "[object WorkerGlobalScope]"
       *  - IE Edge Worker === "[object WorkerGlobalScope]"
       */if(obj===globalObject){return'global';}/* ! Speed optimisation
       * Pre:
       *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
       * Post:
       *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
       */if(Array.isArray(obj)&&(symbolToStringTagExists===false||!(Symbol.toStringTag in obj))){return'Array';}// Not caching existence of \`window\` and related properties due to potential
// for \`window\` to be unset before tests in quasi-browser environments.
if(typeof window==='object'&&window!==null){/* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/browsers.html#location)
         * WhatWG HTML$7.7.3 - The \`Location\` interface
         * Test: \`Object.prototype.toString.call(window.location)\`\`
         *  - IE <=11 === "[object Object]"
         *  - IE Edge <=13 === "[object Object]"
         */if(typeof window.location==='object'&&obj===window.location){return'Location';}/* ! Spec Conformance
         * (https://html.spec.whatwg.org/#document)
         * WhatWG HTML$3.1.1 - The \`Document\` object
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         *       WhatWG HTML states:
         *         > For historical reasons, Window objects must also have a
         *         > writable, configurable, non-enumerable property named
         *         > HTMLDocument whose value is the Document interface object.
         * Test: \`Object.prototype.toString.call(document)\`\`
         *  - Chrome === "[object HTMLDocument]"
         *  - Firefox === "[object HTMLDocument]"
         *  - Safari === "[object HTMLDocument]"
         *  - IE <=10 === "[object Document]"
         *  - IE 11 === "[object HTMLDocument]"
         *  - IE Edge <=13 === "[object HTMLDocument]"
         */if(typeof window.document==='object'&&obj===window.document){return'Document';}if(typeof window.navigator==='object'){/* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
           * Test: \`Object.prototype.toString.call(navigator.mimeTypes)\`\`
           *  - IE <=10 === "[object MSMimeTypesCollection]"
           */if(typeof window.navigator.mimeTypes==='object'&&obj===window.navigator.mimeTypes){return'MimeTypeArray';}/* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
           * Test: \`Object.prototype.toString.call(navigator.plugins)\`\`
           *  - IE <=10 === "[object MSPluginsCollection]"
           */if(typeof window.navigator.plugins==='object'&&obj===window.navigator.plugins){return'PluginArray';}}if((typeof window.HTMLElement==='function'||typeof window.HTMLElement==='object')&&obj instanceof window.HTMLElement){/* ! Spec Conformance
          * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
          * WhatWG HTML$4.4.4 - The \`blockquote\` element - Interface \`HTMLQuoteElement\`
          * Test: \`Object.prototype.toString.call(document.createElement('blockquote'))\`\`
          *  - IE <=10 === "[object HTMLBlockElement]"
          */if(obj.tagName==='BLOCKQUOTE'){return'HTMLQuoteElement';}/* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltabledatacellelement)
           * WhatWG HTML$4.9.9 - The \`td\` element - Interface \`HTMLTableDataCellElement\`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('td'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */if(obj.tagName==='TD'){return'HTMLTableDataCellElement';}/* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltableheadercellelement)
           * WhatWG HTML$4.9.9 - The \`td\` element - Interface \`HTMLTableHeaderCellElement\`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('th'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */if(obj.tagName==='TH'){return'HTMLTableHeaderCellElement';}}}/* ! Speed optimisation
      * Pre:
      *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
      *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
      *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
      *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
      *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
      *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
      *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
      *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
      *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
      * Post:
      *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
      *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
      *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
      *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
      *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
      *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
      *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
      *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
      *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
      */var stringTag=symbolToStringTagExists&&obj[Symbol.toStringTag];if(typeof stringTag==='string'){return stringTag;}var objPrototype=Object.getPrototypeOf(obj);/* ! Speed optimisation
      * Pre:
      *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
      *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
      * Post:
      *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
      *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
      */if(objPrototype===RegExp.prototype){return'RegExp';}/* ! Speed optimisation
      * Pre:
      *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
      * Post:
      *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
      */if(objPrototype===Date.prototype){return'Date';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
       * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
       * Test: \`Object.prototype.toString.call(Promise.resolve())\`\`
       *  - Chrome <=47 === "[object Object]"
       *  - Edge <=20 === "[object Object]"
       *  - Firefox 29-Latest === "[object Promise]"
       *  - Safari 7.1-Latest === "[object Promise]"
       */if(promiseExists&&objPrototype===Promise.prototype){return'Promise';}/* ! Speed optimisation
      * Pre:
      *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
      * Post:
      *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
      */if(setExists&&objPrototype===Set.prototype){return'Set';}/* ! Speed optimisation
      * Pre:
      *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
      * Post:
      *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
      */if(mapExists&&objPrototype===Map.prototype){return'Map';}/* ! Speed optimisation
      * Pre:
      *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
      * Post:
      *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
      */if(weakSetExists&&objPrototype===WeakSet.prototype){return'WeakSet';}/* ! Speed optimisation
      * Pre:
      *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
      * Post:
      *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
      */if(weakMapExists&&objPrototype===WeakMap.prototype){return'WeakMap';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
       * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
       * Test: \`Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))\`\`
       *  - Edge <=13 === "[object Object]"
       */if(dataViewExists&&objPrototype===DataView.prototype){return'DataView';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
       * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
       * Test: \`Object.prototype.toString.call(new Map().entries())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(mapExists&&objPrototype===mapIteratorPrototype){return'Map Iterator';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
       * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
       * Test: \`Object.prototype.toString.call(new Set().entries())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(setExists&&objPrototype===setIteratorPrototype){return'Set Iterator';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
       * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
       * Test: \`Object.prototype.toString.call([][Symbol.iterator]())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(arrayIteratorExists&&objPrototype===arrayIteratorPrototype){return'Array Iterator';}/* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
       * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
       * Test: \`Object.prototype.toString.call(''[Symbol.iterator]())\`\`
       *  - Edge <=13 === "[object Object]"
       */if(stringIteratorExists&&objPrototype===stringIteratorPrototype){return'String Iterator';}/* ! Speed optimisation
      * Pre:
      *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
      * Post:
      *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
      */if(objPrototype===null){return'Object';}return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength,toStringRightSliceLength);}return typeDetect;});})(typeDetect);var typeDetectExports=typeDetect.exports;var type=typeDetectExports;/**
 * Returns the lower-case result of running type from type-detect on the value
 *
 * @param  {*} value
 * @returns {string}
 */var typeOf=function typeOf(value){return type(value).toLowerCase();};/**
 * Returns a string representation of the value
 *
 * @param  {*} value
 * @returns {string}
 */function valueToString(value){if(value&&value.toString){// eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods
return value.toString();}return String(value);}var valueToString_1=valueToString;var lib={global:global$1,calledInOrder:calledInOrder_1,className:className_1,deprecated:deprecated,every:every,functionName:functionName$1,orderByFirstCall:orderByFirstCall_1,prototypes:prototypes,typeOf:typeOf,valueToString:valueToString_1};const globalObject=lib.global;let timersModule;if(typeof __vitest_required__!=='undefined'){try{timersModule=__vitest_required__.timers;}catch(e){// ignored
}}/**
 * @typedef {object} IdleDeadline
 * @property {boolean} didTimeout - whether or not the callback was called before reaching the optional timeout
 * @property {function():number} timeRemaining - a floating-point value providing an estimate of the number of milliseconds remaining in the current idle period
 */ /**
 * Queues a function to be called during a browser's idle periods
 *
 * @callback RequestIdleCallback
 * @param {function(IdleDeadline)} callback
 * @param {{timeout: number}} options - an options object
 * @returns {number} the id
 */ /**
 * @callback NextTick
 * @param {VoidVarArgsFunc} callback - the callback to run
 * @param {...*} arguments - optional arguments to call the callback with
 * @returns {void}
 */ /**
 * @callback SetImmediate
 * @param {VoidVarArgsFunc} callback - the callback to run
 * @param {...*} arguments - optional arguments to call the callback with
 * @returns {NodeImmediate}
 */ /**
 * @callback VoidVarArgsFunc
 * @param {...*} callback - the callback to run
 * @returns {void}
 */ /**
 * @typedef RequestAnimationFrame
 * @property {function(number):void} requestAnimationFrame
 * @returns {number} - the id
 */ /**
 * @typedef Performance
 * @property {function(): number} now
 */ /* eslint-disable jsdoc/require-property-description */ /**
 * @typedef {object} Clock
 * @property {number} now - the current time
 * @property {Date} Date - the Date constructor
 * @property {number} loopLimit - the maximum number of timers before assuming an infinite loop
 * @property {RequestIdleCallback} requestIdleCallback
 * @property {function(number):void} cancelIdleCallback
 * @property {setTimeout} setTimeout
 * @property {clearTimeout} clearTimeout
 * @property {NextTick} nextTick
 * @property {queueMicrotask} queueMicrotask
 * @property {setInterval} setInterval
 * @property {clearInterval} clearInterval
 * @property {SetImmediate} setImmediate
 * @property {function(NodeImmediate):void} clearImmediate
 * @property {function():number} countTimers
 * @property {RequestAnimationFrame} requestAnimationFrame
 * @property {function(number):void} cancelAnimationFrame
 * @property {function():void} runMicrotasks
 * @property {function(string | number): number} tick
 * @property {function(string | number): Promise<number>} tickAsync
 * @property {function(): number} next
 * @property {function(): Promise<number>} nextAsync
 * @property {function(): number} runAll
 * @property {function(): number} runToFrame
 * @property {function(): Promise<number>} runAllAsync
 * @property {function(): number} runToLast
 * @property {function(): Promise<number>} runToLastAsync
 * @property {function(): void} reset
 * @property {function(number | Date): void} setSystemTime
 * @property {function(number): void} jump
 * @property {Performance} performance
 * @property {function(number[]): number[]} hrtime - process.hrtime (legacy)
 * @property {function(): void} uninstall Uninstall the clock.
 * @property {Function[]} methods - the methods that are faked
 * @property {boolean} [shouldClearNativeTimers] inherited from config
 * @property {{methodName:string, original:any}[] | undefined} timersModuleMethods
 */ /* eslint-enable jsdoc/require-property-description */ /**
 * Configuration object for the \`install\` method.
 *
 * @typedef {object} Config
 * @property {number|Date} [now] a number (in milliseconds) or a Date object (default epoch)
 * @property {string[]} [toFake] names of the methods that should be faked.
 * @property {number} [loopLimit] the maximum number of timers that will be run when calling runAll()
 * @property {boolean} [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false)
 * @property {number} [advanceTimeDelta] increment mocked time every <<advanceTimeDelta>> ms (default: 20ms)
 * @property {boolean} [shouldClearNativeTimers] forwards clear timer calls to native functions if they are not fakes (default: false)
 */ /* eslint-disable jsdoc/require-property-description */ /**
 * The internal structure to describe a scheduled fake timer
 *
 * @typedef {object} Timer
 * @property {Function} func
 * @property {*[]} args
 * @property {number} delay
 * @property {number} callAt
 * @property {number} createdAt
 * @property {boolean} immediate
 * @property {number} id
 * @property {Error} [error]
 */ /**
 * A Node timer
 *
 * @typedef {object} NodeImmediate
 * @property {function(): boolean} hasRef
 * @property {function(): NodeImmediate} ref
 * @property {function(): NodeImmediate} unref
 */ /* eslint-enable jsdoc/require-property-description */ /* eslint-disable complexity */ /**
 * Mocks available features in the specified global namespace.
 *
 * @param {*} _global Namespace to mock (e.g. \`window\`)
 * @returns {FakeTimers}
 */function withGlobal(_global){const maxTimeout=Math.pow(2,31)-1;//see https://heycam.github.io/webidl/#abstract-opdef-converttoint
const idCounterStart=1e12;// arbitrarily large number to avoid collisions with native timer IDs
const NOOP=function(){return undefined;};const NOOP_ARRAY=function(){return[];};const timeoutResult=_global.setTimeout(NOOP,0);const addTimerReturnsObject=typeof timeoutResult==="object";const hrtimePresent=_global.process&&typeof _global.process.hrtime==="function";const hrtimeBigintPresent=hrtimePresent&&typeof _global.process.hrtime.bigint==="function";const nextTickPresent=_global.process&&typeof _global.process.nextTick==="function";const utilPromisify=_global.process&&_global.__vitest_required__&&_global.__vitest_required__.util.promisify;const performancePresent=_global.performance&&typeof _global.performance.now==="function";const hasPerformancePrototype=_global.Performance&&(typeof _global.Performance).match(/^(function|object)$/);const hasPerformanceConstructorPrototype=_global.performance&&_global.performance.constructor&&_global.performance.constructor.prototype;const queueMicrotaskPresent=_global.hasOwnProperty("queueMicrotask");const requestAnimationFramePresent=_global.requestAnimationFrame&&typeof _global.requestAnimationFrame==="function";const cancelAnimationFramePresent=_global.cancelAnimationFrame&&typeof _global.cancelAnimationFrame==="function";const requestIdleCallbackPresent=_global.requestIdleCallback&&typeof _global.requestIdleCallback==="function";const cancelIdleCallbackPresent=_global.cancelIdleCallback&&typeof _global.cancelIdleCallback==="function";const setImmediatePresent=_global.setImmediate&&typeof _global.setImmediate==="function";const intlPresent=_global.Intl&&typeof _global.Intl==="object";_global.clearTimeout(timeoutResult);const NativeDate=_global.Date;const NativeIntl=_global.Intl;let uniqueTimerId=idCounterStart;/**
   * @param {number} num
   * @returns {boolean}
   */function isNumberFinite(num){if(Number.isFinite){return Number.isFinite(num);}return isFinite(num);}let isNearInfiniteLimit=false;/**
   * @param {Clock} clock
   * @param {number} i
   */function checkIsNearInfiniteLimit(clock,i){if(clock.loopLimit&&i===clock.loopLimit-1){isNearInfiniteLimit=true;}}/**
   *
   */function resetIsNearInfiniteLimit(){isNearInfiniteLimit=false;}/**
   * Parse strings like "01:10:00" (meaning 1 hour, 10 minutes, 0 seconds) into
   * number of milliseconds. This is used to support human-readable strings passed
   * to clock.tick()
   *
   * @param {string} str
   * @returns {number}
   */function parseTime(str){if(!str){return 0;}const strings=str.split(":");const l=strings.length;let i=l;let ms=0;let parsed;if(l>3||!/^(\\d\\d:){0,2}\\d\\d?$/.test(str)){throw new Error("tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits");}while(i--){parsed=parseInt(strings[i],10);if(parsed>=60){throw new Error(\`Invalid time \${str}\`);}ms+=parsed*Math.pow(60,l-i-1);}return ms*1000;}/**
   * Get the decimal part of the millisecond value as nanoseconds
   *
   * @param {number} msFloat the number of milliseconds
   * @returns {number} an integer number of nanoseconds in the range [0,1e6)
   *
   * Example: nanoRemainer(123.456789) -> 456789
   */function nanoRemainder(msFloat){const modulo=1e6;const remainder=msFloat*1e6%modulo;const positiveRemainder=remainder<0?remainder+modulo:remainder;return Math.floor(positiveRemainder);}/**
   * Used to grok the \`now\` parameter to createClock.
   *
   * @param {Date|number} epoch the system time
   * @returns {number}
   */function getEpoch(epoch){if(!epoch){return 0;}if(typeof epoch.getTime==="function"){return epoch.getTime();}if(typeof epoch==="number"){return epoch;}throw new TypeError("now should be milliseconds since UNIX epoch");}/**
   * @param {number} from
   * @param {number} to
   * @param {Timer} timer
   * @returns {boolean}
   */function inRange(from,to,timer){return timer&&timer.callAt>=from&&timer.callAt<=to;}/**
   * @param {Clock} clock
   * @param {Timer} job
   */function getInfiniteLoopError(clock,job){const infiniteLoopError=new Error(\`Aborting after running \${clock.loopLimit} timers, assuming an infinite loop!\`);if(!job.error){return infiniteLoopError;}// pattern never matched in Node
const computedTargetPattern=/target\\.*[<|(|[].*?[>|\\]|)]\\s*/;let clockMethodPattern=new RegExp(String(Object.keys(clock).join("|")));if(addTimerReturnsObject){// node.js environment
clockMethodPattern=new RegExp(\`\\\\s+at (Object\\\\.)?(?:\${Object.keys(clock).join("|")})\\\\s+\`);}let matchedLineIndex=-1;job.error.stack.split("\\n").some(function(line,i){// If we've matched a computed target line (e.g. setTimeout) then we
// don't need to look any further. Return true to stop iterating.
const matchedComputedTarget=line.match(computedTargetPattern);/* istanbul ignore if */if(matchedComputedTarget){matchedLineIndex=i;return true;}// If we've matched a clock method line, then there may still be
// others further down the trace. Return false to keep iterating.
const matchedClockMethod=line.match(clockMethodPattern);if(matchedClockMethod){matchedLineIndex=i;return false;}// If we haven't matched anything on this line, but we matched
// previously and set the matched line index, then we can stop.
// If we haven't matched previously, then we should keep iterating.
return matchedLineIndex>=0;});const stack=\`\${infiniteLoopError}\\n\${job.type||"Microtask"} - \${job.func.name||"anonymous"}\\n\${job.error.stack.split("\\n").slice(matchedLineIndex+1).join("\\n")}\`;try{Object.defineProperty(infiniteLoopError,"stack",{value:stack});}catch(e){// noop
}return infiniteLoopError;}/**
   * @param {Date} target
   * @param {Date} source
   * @returns {Date} the target after modifications
   */function mirrorDateProperties(target,source){let prop;for(prop in source){if(source.hasOwnProperty(prop)){target[prop]=source[prop];}}// set special now implementation
if(source.now){target.now=function now(){return target.clock.now;};}else{delete target.now;}// set special toSource implementation
if(source.toSource){target.toSource=function toSource(){return source.toSource();};}else{delete target.toSource;}// set special toString implementation
target.toString=function toString(){return source.toString();};target.prototype=source.prototype;target.parse=source.parse;target.UTC=source.UTC;target.prototype.toUTCString=source.prototype.toUTCString;target.isFake=true;return target;}//eslint-disable-next-line jsdoc/require-jsdoc
function createDate(){/**
     * @param {number} year
     * @param {number} month
     * @param {number} date
     * @param {number} hour
     * @param {number} minute
     * @param {number} second
     * @param {number} ms
     * @returns {Date}
     */function ClockDate(year,month,date,hour,minute,second,ms){// the Date constructor called as a function, ref Ecma-262 Edition 5.1, section 15.9.2.
// This remains so in the 10th edition of 2019 as well.
if(!(this instanceof ClockDate)){return new NativeDate(ClockDate.clock.now).toString();}// if Date is called as a constructor with 'new' keyword
// Defensive and verbose to avoid potential harm in passing
// explicit undefined when user does not pass argument
switch(arguments.length){case 0:return new NativeDate(ClockDate.clock.now);case 1:return new NativeDate(year);case 2:return new NativeDate(year,month);case 3:return new NativeDate(year,month,date);case 4:return new NativeDate(year,month,date,hour);case 5:return new NativeDate(year,month,date,hour,minute);case 6:return new NativeDate(year,month,date,hour,minute,second);default:return new NativeDate(year,month,date,hour,minute,second,ms);}}return mirrorDateProperties(ClockDate,NativeDate);}//eslint-disable-next-line jsdoc/require-jsdoc
function createIntl(){const ClockIntl=_objectSpread({},NativeIntl);ClockIntl.DateTimeFormat=function(...args){const realFormatter=new NativeIntl.DateTimeFormat(...args);const formatter={};["formatRange","formatRangeToParts","resolvedOptions"].forEach(method=>{formatter[method]=realFormatter[method].bind(realFormatter);});["format","formatToParts"].forEach(method=>{formatter[method]=function(date){return realFormatter[method](date||ClockIntl.clock.now);};});return formatter;};ClockIntl.DateTimeFormat.prototype=Object.create(NativeIntl.DateTimeFormat.prototype);ClockIntl.DateTimeFormat.supportedLocalesOf=NativeIntl.DateTimeFormat.supportedLocalesOf;return ClockIntl;}//eslint-disable-next-line jsdoc/require-jsdoc
function enqueueJob(clock,job){// enqueues a microtick-deferred task - ecma262/#sec-enqueuejob
if(!clock.jobs){clock.jobs=[];}clock.jobs.push(job);}//eslint-disable-next-line jsdoc/require-jsdoc
function runJobs(clock){// runs all microtick-deferred tasks - ecma262/#sec-runjobs
if(!clock.jobs){return;}for(let i=0;i<clock.jobs.length;i++){const job=clock.jobs[i];job.func.apply(null,job.args);checkIsNearInfiniteLimit(clock,i);if(clock.loopLimit&&i>clock.loopLimit){throw getInfiniteLoopError(clock,job);}}resetIsNearInfiniteLimit();clock.jobs=[];}/**
   * @param {Clock} clock
   * @param {Timer} timer
   * @returns {number} id of the created timer
   */function addTimer(clock,timer){if(timer.func===undefined){throw new Error("Callback must be provided to timer calls");}if(addTimerReturnsObject){// Node.js environment
if(typeof timer.func!=="function"){throw new TypeError(\`[ERR_INVALID_CALLBACK]: Callback must be a function. Received \${timer.func} of type \${typeof timer.func}\`);}}if(isNearInfiniteLimit){timer.error=new Error();}timer.type=timer.immediate?"Immediate":"Timeout";if(timer.hasOwnProperty("delay")){if(typeof timer.delay!=="number"){timer.delay=parseInt(timer.delay,10);}if(!isNumberFinite(timer.delay)){timer.delay=0;}timer.delay=timer.delay>maxTimeout?1:timer.delay;timer.delay=Math.max(0,timer.delay);}if(timer.hasOwnProperty("interval")){timer.type="Interval";timer.interval=timer.interval>maxTimeout?1:timer.interval;}if(timer.hasOwnProperty("animation")){timer.type="AnimationFrame";timer.animation=true;}if(timer.hasOwnProperty("idleCallback")){timer.type="IdleCallback";timer.idleCallback=true;}if(!clock.timers){clock.timers={};}timer.id=uniqueTimerId++;timer.createdAt=clock.now;timer.callAt=clock.now+(parseInt(timer.delay)||(clock.duringTick?1:0));clock.timers[timer.id]=timer;if(addTimerReturnsObject){const res={refed:true,ref:function(){this.refed=true;return res;},unref:function(){this.refed=false;return res;},hasRef:function(){return this.refed;},refresh:function(){timer.callAt=clock.now+(parseInt(timer.delay)||(clock.duringTick?1:0));// it _might_ have been removed, but if not the assignment is perfectly fine
clock.timers[timer.id]=timer;return res;},[Symbol.toPrimitive]:function(){return timer.id;}};return res;}return timer.id;}/* eslint consistent-return: "off" */ /**
   * Timer comparitor
   *
   * @param {Timer} a
   * @param {Timer} b
   * @returns {number}
   */function compareTimers(a,b){// Sort first by absolute timing
if(a.callAt<b.callAt){return-1;}if(a.callAt>b.callAt){return 1;}// Sort next by immediate, immediate timers take precedence
if(a.immediate&&!b.immediate){return-1;}if(!a.immediate&&b.immediate){return 1;}// Sort next by creation time, earlier-created timers take precedence
if(a.createdAt<b.createdAt){return-1;}if(a.createdAt>b.createdAt){return 1;}// Sort next by id, lower-id timers take precedence
if(a.id<b.id){return-1;}if(a.id>b.id){return 1;}// As timer ids are unique, no fallback \`0\` is necessary
}/**
   * @param {Clock} clock
   * @param {number} from
   * @param {number} to
   * @returns {Timer}
   */function firstTimerInRange(clock,from,to){const timers=clock.timers;let timer=null;let id,isInRange;for(id in timers){if(timers.hasOwnProperty(id)){isInRange=inRange(from,to,timers[id]);if(isInRange&&(!timer||compareTimers(timer,timers[id])===1)){timer=timers[id];}}}return timer;}/**
   * @param {Clock} clock
   * @returns {Timer}
   */function firstTimer(clock){const timers=clock.timers;let timer=null;let id;for(id in timers){if(timers.hasOwnProperty(id)){if(!timer||compareTimers(timer,timers[id])===1){timer=timers[id];}}}return timer;}/**
   * @param {Clock} clock
   * @returns {Timer}
   */function lastTimer(clock){const timers=clock.timers;let timer=null;let id;for(id in timers){if(timers.hasOwnProperty(id)){if(!timer||compareTimers(timer,timers[id])===-1){timer=timers[id];}}}return timer;}/**
   * @param {Clock} clock
   * @param {Timer} timer
   */function callTimer(clock,timer){if(typeof timer.interval==="number"){clock.timers[timer.id].callAt+=timer.interval;}else{delete clock.timers[timer.id];}if(typeof timer.func==="function"){timer.func.apply(null,timer.args);}else{/* eslint no-eval: "off" */const eval2=eval;(function(){eval2(timer.func);})();}}/**
   * Gets clear handler name for a given timer type
   *
   * @param {string} ttype
   */function getClearHandler(ttype){if(ttype==="IdleCallback"||ttype==="AnimationFrame"){return\`cancel\${ttype}\`;}return\`clear\${ttype}\`;}/**
   * Gets schedule handler name for a given timer type
   *
   * @param {string} ttype
   */function getScheduleHandler(ttype){if(ttype==="IdleCallback"||ttype==="AnimationFrame"){return\`request\${ttype}\`;}return\`set\${ttype}\`;}/**
   * Creates an anonymous function to warn only once
   */function createWarnOnce(){let calls=0;return function(msg){// eslint-disable-next-line
!calls++&&console.warn(msg);};}const warnOnce=createWarnOnce();/**
   * @param {Clock} clock
   * @param {number} timerId
   * @param {string} ttype
   */function clearTimer(clock,timerId,ttype){if(!timerId){// null appears to be allowed in most browsers, and appears to be
// relied upon by some libraries, like Bootstrap carousel
return;}if(!clock.timers){clock.timers={};}// in Node, the ID is stored as the primitive value for \`Timeout\` objects
// for \`Immediate\` objects, no ID exists, so it gets coerced to NaN
const id=Number(timerId);if(Number.isNaN(id)||id<idCounterStart){const handlerName=getClearHandler(ttype);if(clock.shouldClearNativeTimers===true){const nativeHandler=clock[\`_\${handlerName}\`];return typeof nativeHandler==="function"?nativeHandler(timerId):undefined;}warnOnce(\`FakeTimers: \${handlerName} was invoked to clear a native timer instead of one created by this library.\`+"\\nTo automatically clean-up native timers, use \`shouldClearNativeTimers\`.");}if(clock.timers.hasOwnProperty(id)){// check that the ID matches a timer of the correct type
const timer=clock.timers[id];if(timer.type===ttype||timer.type==="Timeout"&&ttype==="Interval"||timer.type==="Interval"&&ttype==="Timeout"){delete clock.timers[id];}else{const clear=getClearHandler(ttype);const schedule=getScheduleHandler(timer.type);throw new Error(\`Cannot clear timer: timer created with \${schedule}() but cleared with \${clear}()\`);}}}/**
   * @param {Clock} clock
   * @param {Config} config
   * @returns {Timer[]}
   */function uninstall(clock,config){let method,i,l;const installedHrTime="_hrtime";const installedNextTick="_nextTick";for(i=0,l=clock.methods.length;i<l;i++){method=clock.methods[i];if(method==="hrtime"&&_global.process){_global.process.hrtime=clock[installedHrTime];}else if(method==="nextTick"&&_global.process){_global.process.nextTick=clock[installedNextTick];}else if(method==="performance"){const originalPerfDescriptor=Object.getOwnPropertyDescriptor(clock,\`_\${method}\`);if(originalPerfDescriptor&&originalPerfDescriptor.get&&!originalPerfDescriptor.set){Object.defineProperty(_global,method,originalPerfDescriptor);}else if(originalPerfDescriptor.configurable){_global[method]=clock[\`_\${method}\`];}}else{if(_global[method]&&_global[method].hadOwnProperty){_global[method]=clock[\`_\${method}\`];}else{try{delete _global[method];}catch(ignore){/* eslint no-empty: "off" */}}}if(clock.timersModuleMethods!==undefined){for(let j=0;j<clock.timersModuleMethods.length;j++){const entry=clock.timersModuleMethods[j];timersModule[entry.methodName]=entry.original;}}}if(config.shouldAdvanceTime===true){_global.clearInterval(clock.attachedInterval);}// Prevent multiple executions which will completely remove these props
clock.methods=[];// return pending timers, to enable checking what timers remained on uninstall
if(!clock.timers){return[];}return Object.keys(clock.timers).map(function mapper(key){return clock.timers[key];});}/**
   * @param {object} target the target containing the method to replace
   * @param {string} method the keyname of the method on the target
   * @param {Clock} clock
   */function hijackMethod(target,method,clock){clock[method].hadOwnProperty=Object.prototype.hasOwnProperty.call(target,method);clock[\`_\${method}\`]=target[method];if(method==="Date"){const date=mirrorDateProperties(clock[method],target[method]);target[method]=date;}else if(method==="Intl"){target[method]=clock[method];}else if(method==="performance"){const originalPerfDescriptor=Object.getOwnPropertyDescriptor(target,method);// JSDOM has a read only performance field so we have to save/copy it differently
if(originalPerfDescriptor&&originalPerfDescriptor.get&&!originalPerfDescriptor.set){Object.defineProperty(clock,\`_\${method}\`,originalPerfDescriptor);const perfDescriptor=Object.getOwnPropertyDescriptor(clock,method);Object.defineProperty(target,method,perfDescriptor);}else{target[method]=clock[method];}}else{target[method]=function(){return clock[method].apply(clock,arguments);};Object.defineProperties(target[method],Object.getOwnPropertyDescriptors(clock[method]));}target[method].clock=clock;}/**
   * @param {Clock} clock
   * @param {number} advanceTimeDelta
   */function doIntervalTick(clock,advanceTimeDelta){clock.tick(advanceTimeDelta);}/**
   * @typedef {object} Timers
   * @property {setTimeout} setTimeout
   * @property {clearTimeout} clearTimeout
   * @property {setInterval} setInterval
   * @property {clearInterval} clearInterval
   * @property {Date} Date
   * @property {Intl} Intl
   * @property {SetImmediate=} setImmediate
   * @property {function(NodeImmediate): void=} clearImmediate
   * @property {function(number[]):number[]=} hrtime
   * @property {NextTick=} nextTick
   * @property {Performance=} performance
   * @property {RequestAnimationFrame=} requestAnimationFrame
   * @property {boolean=} queueMicrotask
   * @property {function(number): void=} cancelAnimationFrame
   * @property {RequestIdleCallback=} requestIdleCallback
   * @property {function(number): void=} cancelIdleCallback
   */ /** @type {Timers} */const timers={setTimeout:_global.setTimeout,clearTimeout:_global.clearTimeout,setInterval:_global.setInterval,clearInterval:_global.clearInterval,Date:_global.Date};if(setImmediatePresent){timers.setImmediate=_global.setImmediate;timers.clearImmediate=_global.clearImmediate;}if(hrtimePresent){timers.hrtime=_global.process.hrtime;}if(nextTickPresent){timers.nextTick=_global.process.nextTick;}if(performancePresent){timers.performance=_global.performance;}if(requestAnimationFramePresent){timers.requestAnimationFrame=_global.requestAnimationFrame;}if(queueMicrotaskPresent){timers.queueMicrotask=true;}if(cancelAnimationFramePresent){timers.cancelAnimationFrame=_global.cancelAnimationFrame;}if(requestIdleCallbackPresent){timers.requestIdleCallback=_global.requestIdleCallback;}if(cancelIdleCallbackPresent){timers.cancelIdleCallback=_global.cancelIdleCallback;}if(intlPresent){timers.Intl=_global.Intl;}const originalSetTimeout=_global.setImmediate||_global.setTimeout;/**
   * @param {Date|number} [start] the system time - non-integer values are floored
   * @param {number} [loopLimit] maximum number of timers that will be run when calling runAll()
   * @returns {Clock}
   */function createClock(start,loopLimit){// eslint-disable-next-line no-param-reassign
start=Math.floor(getEpoch(start));// eslint-disable-next-line no-param-reassign
loopLimit=loopLimit||1000;let nanos=0;const adjustedSystemTime=[0,0];// [millis, nanoremainder]
if(NativeDate===undefined){throw new Error("The global scope doesn't have a \`Date\` object"+" (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)");}const clock={now:start,Date:createDate(),loopLimit:loopLimit};clock.Date.clock=clock;//eslint-disable-next-line jsdoc/require-jsdoc
function getTimeToNextFrame(){return 16-(clock.now-start)%16;}//eslint-disable-next-line jsdoc/require-jsdoc
function hrtime(prev){const millisSinceStart=clock.now-adjustedSystemTime[0]-start;const secsSinceStart=Math.floor(millisSinceStart/1000);const remainderInNanos=(millisSinceStart-secsSinceStart*1e3)*1e6+nanos-adjustedSystemTime[1];if(Array.isArray(prev)){if(prev[1]>1e9){throw new TypeError("Number of nanoseconds can't exceed a billion");}const oldSecs=prev[0];let nanoDiff=remainderInNanos-prev[1];let secDiff=secsSinceStart-oldSecs;if(nanoDiff<0){nanoDiff+=1e9;secDiff-=1;}return[secDiff,nanoDiff];}return[secsSinceStart,remainderInNanos];}function fakePerformanceNow(){const hrt=hrtime();const millis=hrt[0]*1000+hrt[1]/1e6;return millis;}if(hrtimeBigintPresent){hrtime.bigint=function(){const parts=hrtime();return BigInt(parts[0])*BigInt(1e9)+BigInt(parts[1]);// eslint-disable-line
};}if(intlPresent){clock.Intl=createIntl();clock.Intl.clock=clock;}clock.requestIdleCallback=function requestIdleCallback(func,timeout){let timeToNextIdlePeriod=0;if(clock.countTimers()>0){timeToNextIdlePeriod=50;// const for now
}const result=addTimer(clock,{func:func,args:Array.prototype.slice.call(arguments,2),delay:typeof timeout==="undefined"?timeToNextIdlePeriod:Math.min(timeout,timeToNextIdlePeriod),idleCallback:true});return Number(result);};clock.cancelIdleCallback=function cancelIdleCallback(timerId){return clearTimer(clock,timerId,"IdleCallback");};clock.setTimeout=function setTimeout(func,timeout){return addTimer(clock,{func:func,args:Array.prototype.slice.call(arguments,2),delay:timeout});};if(typeof _global.Promise!=="undefined"&&utilPromisify){clock.setTimeout[utilPromisify.custom]=function promisifiedSetTimeout(timeout,arg){return new _global.Promise(function setTimeoutExecutor(resolve){addTimer(clock,{func:resolve,args:[arg],delay:timeout});});};}clock.clearTimeout=function clearTimeout(timerId){return clearTimer(clock,timerId,"Timeout");};clock.nextTick=function nextTick(func){return enqueueJob(clock,{func:func,args:Array.prototype.slice.call(arguments,1),error:isNearInfiniteLimit?new Error():null});};clock.queueMicrotask=function queueMicrotask(func){return clock.nextTick(func);// explicitly drop additional arguments
};clock.setInterval=function setInterval(func,timeout){// eslint-disable-next-line no-param-reassign
timeout=parseInt(timeout,10);return addTimer(clock,{func:func,args:Array.prototype.slice.call(arguments,2),delay:timeout,interval:timeout});};clock.clearInterval=function clearInterval(timerId){return clearTimer(clock,timerId,"Interval");};if(setImmediatePresent){clock.setImmediate=function setImmediate(func){return addTimer(clock,{func:func,args:Array.prototype.slice.call(arguments,1),immediate:true});};if(typeof _global.Promise!=="undefined"&&utilPromisify){clock.setImmediate[utilPromisify.custom]=function promisifiedSetImmediate(arg){return new _global.Promise(function setImmediateExecutor(resolve){addTimer(clock,{func:resolve,args:[arg],immediate:true});});};}clock.clearImmediate=function clearImmediate(timerId){return clearTimer(clock,timerId,"Immediate");};}clock.countTimers=function countTimers(){return Object.keys(clock.timers||{}).length+(clock.jobs||[]).length;};clock.requestAnimationFrame=function requestAnimationFrame(func){const result=addTimer(clock,{func:func,delay:getTimeToNextFrame(),get args(){return[fakePerformanceNow()];},animation:true});return Number(result);};clock.cancelAnimationFrame=function cancelAnimationFrame(timerId){return clearTimer(clock,timerId,"AnimationFrame");};clock.runMicrotasks=function runMicrotasks(){runJobs(clock);};/**
     * @param {number|string} tickValue milliseconds or a string parseable by parseTime
     * @param {boolean} isAsync
     * @param {Function} resolve
     * @param {Function} reject
     * @returns {number|undefined} will return the new \`now\` value or nothing for async
     */function doTick(tickValue,isAsync,resolve,reject){const msFloat=typeof tickValue==="number"?tickValue:parseTime(tickValue);const ms=Math.floor(msFloat);const remainder=nanoRemainder(msFloat);let nanosTotal=nanos+remainder;let tickTo=clock.now+ms;if(msFloat<0){throw new TypeError("Negative ticks are not supported");}// adjust for positive overflow
if(nanosTotal>=1e6){tickTo+=1;nanosTotal-=1e6;}nanos=nanosTotal;let tickFrom=clock.now;let previous=clock.now;// ESLint fails to detect this correctly
/* eslint-disable prefer-const */let timer,firstException,oldNow,nextPromiseTick,compensationCheck,postTimerCall;/* eslint-enable prefer-const */clock.duringTick=true;// perform microtasks
oldNow=clock.now;runJobs(clock);if(oldNow!==clock.now){// compensate for any setSystemTime() call during microtask callback
tickFrom+=clock.now-oldNow;tickTo+=clock.now-oldNow;}//eslint-disable-next-line jsdoc/require-jsdoc
function doTickInner(){// perform each timer in the requested range
timer=firstTimerInRange(clock,tickFrom,tickTo);// eslint-disable-next-line no-unmodified-loop-condition
while(timer&&tickFrom<=tickTo){if(clock.timers[timer.id]){tickFrom=timer.callAt;clock.now=timer.callAt;oldNow=clock.now;try{runJobs(clock);callTimer(clock,timer);}catch(e){firstException=firstException||e;}if(isAsync){// finish up after native setImmediate callback to allow
// all native es6 promises to process their callbacks after
// each timer fires.
originalSetTimeout(nextPromiseTick);return;}compensationCheck();}postTimerCall();}// perform process.nextTick()s again
oldNow=clock.now;runJobs(clock);if(oldNow!==clock.now){// compensate for any setSystemTime() call during process.nextTick() callback
tickFrom+=clock.now-oldNow;tickTo+=clock.now-oldNow;}clock.duringTick=false;// corner case: during runJobs new timers were scheduled which could be in the range [clock.now, tickTo]
timer=firstTimerInRange(clock,tickFrom,tickTo);if(timer){try{clock.tick(tickTo-clock.now);// do it all again - for the remainder of the requested range
}catch(e){firstException=firstException||e;}}else{// no timers remaining in the requested range: move the clock all the way to the end
clock.now=tickTo;// update nanos
nanos=nanosTotal;}if(firstException){throw firstException;}if(isAsync){resolve(clock.now);}else{return clock.now;}}nextPromiseTick=isAsync&&function(){try{compensationCheck();postTimerCall();doTickInner();}catch(e){reject(e);}};compensationCheck=function(){// compensate for any setSystemTime() call during timer callback
if(oldNow!==clock.now){tickFrom+=clock.now-oldNow;tickTo+=clock.now-oldNow;previous+=clock.now-oldNow;}};postTimerCall=function(){timer=firstTimerInRange(clock,previous,tickTo);previous=tickFrom;};return doTickInner();}/**
     * @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
     * @returns {number} will return the new \`now\` value
     */clock.tick=function tick(tickValue){return doTick(tickValue,false);};if(typeof _global.Promise!=="undefined"){/**
       * @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
       * @returns {Promise}
       */clock.tickAsync=function tickAsync(tickValue){return new _global.Promise(function(resolve,reject){originalSetTimeout(function(){try{doTick(tickValue,true,resolve,reject);}catch(e){reject(e);}});});};}clock.next=function next(){runJobs(clock);const timer=firstTimer(clock);if(!timer){return clock.now;}clock.duringTick=true;try{clock.now=timer.callAt;callTimer(clock,timer);runJobs(clock);return clock.now;}finally{clock.duringTick=false;}};if(typeof _global.Promise!=="undefined"){clock.nextAsync=function nextAsync(){return new _global.Promise(function(resolve,reject){originalSetTimeout(function(){try{const timer=firstTimer(clock);if(!timer){resolve(clock.now);return;}let err;clock.duringTick=true;clock.now=timer.callAt;try{callTimer(clock,timer);}catch(e){err=e;}clock.duringTick=false;originalSetTimeout(function(){if(err){reject(err);}else{resolve(clock.now);}});}catch(e){reject(e);}});});};}clock.runAll=function runAll(){let numTimers,i;runJobs(clock);for(i=0;i<clock.loopLimit;i++){if(!clock.timers){resetIsNearInfiniteLimit();return clock.now;}numTimers=Object.keys(clock.timers).length;if(numTimers===0){resetIsNearInfiniteLimit();return clock.now;}clock.next();checkIsNearInfiniteLimit(clock,i);}const excessJob=firstTimer(clock);throw getInfiniteLoopError(clock,excessJob);};clock.runToFrame=function runToFrame(){return clock.tick(getTimeToNextFrame());};if(typeof _global.Promise!=="undefined"){clock.runAllAsync=function runAllAsync(){return new _global.Promise(function(resolve,reject){let i=0;/**
           *
           */function doRun(){originalSetTimeout(function(){try{let numTimers;if(i<clock.loopLimit){if(!clock.timers){resetIsNearInfiniteLimit();resolve(clock.now);return;}numTimers=Object.keys(clock.timers).length;if(numTimers===0){resetIsNearInfiniteLimit();resolve(clock.now);return;}clock.next();i++;doRun();checkIsNearInfiniteLimit(clock,i);return;}const excessJob=firstTimer(clock);reject(getInfiniteLoopError(clock,excessJob));}catch(e){reject(e);}});}doRun();});};}clock.runToLast=function runToLast(){const timer=lastTimer(clock);if(!timer){runJobs(clock);return clock.now;}return clock.tick(timer.callAt-clock.now);};if(typeof _global.Promise!=="undefined"){clock.runToLastAsync=function runToLastAsync(){return new _global.Promise(function(resolve,reject){originalSetTimeout(function(){try{const timer=lastTimer(clock);if(!timer){resolve(clock.now);}resolve(clock.tickAsync(timer.callAt-clock.now));}catch(e){reject(e);}});});};}clock.reset=function reset(){nanos=0;clock.timers={};clock.jobs=[];clock.now=start;};clock.setSystemTime=function setSystemTime(systemTime){// determine time difference
const newNow=getEpoch(systemTime);const difference=newNow-clock.now;let id,timer;adjustedSystemTime[0]=adjustedSystemTime[0]+difference;adjustedSystemTime[1]=adjustedSystemTime[1]+nanos;// update 'system clock'
clock.now=newNow;nanos=0;// update timers and intervals to keep them stable
for(id in clock.timers){if(clock.timers.hasOwnProperty(id)){timer=clock.timers[id];timer.createdAt+=difference;timer.callAt+=difference;}}};/**
     * @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
     * @returns {number} will return the new \`now\` value
     */clock.jump=function jump(tickValue){const msFloat=typeof tickValue==="number"?tickValue:parseTime(tickValue);const ms=Math.floor(msFloat);for(const timer of Object.values(clock.timers)){if(clock.now+ms>timer.callAt){timer.callAt=clock.now+ms;}}clock.tick(ms);};if(performancePresent){clock.performance=Object.create(null);clock.performance.now=fakePerformanceNow;}if(hrtimePresent){clock.hrtime=hrtime;}return clock;}/* eslint-disable complexity */ /**
   * @param {Config=} [config] Optional config
   * @returns {Clock}
   */function install(config){if(arguments.length>1||config instanceof Date||Array.isArray(config)||typeof config==="number"){throw new TypeError(\`FakeTimers.install called with \${String(config)} install requires an object parameter\`);}if(_global.Date.isFake===true){// Timers are already faked; this is a problem.
// Make the user reset timers before continuing.
throw new TypeError("Can't install fake timers twice on the same global object.");}// eslint-disable-next-line no-param-reassign
config=typeof config!=="undefined"?config:{};config.shouldAdvanceTime=config.shouldAdvanceTime||false;config.advanceTimeDelta=config.advanceTimeDelta||20;config.shouldClearNativeTimers=config.shouldClearNativeTimers||false;if(config.target){throw new TypeError("config.target is no longer supported. Use \`withGlobal(target)\` instead.");}let i,l;const clock=createClock(config.now,config.loopLimit);clock.shouldClearNativeTimers=config.shouldClearNativeTimers;clock.uninstall=function(){return uninstall(clock,config);};clock.methods=config.toFake||[];if(clock.methods.length===0){// do not fake nextTick by default - GitHub#126
clock.methods=Object.keys(timers).filter(function(key){return key!=="nextTick"&&key!=="queueMicrotask";});}if(config.shouldAdvanceTime===true){const intervalTick=doIntervalTick.bind(null,clock,config.advanceTimeDelta);const intervalId=_global.setInterval(intervalTick,config.advanceTimeDelta);clock.attachedInterval=intervalId;}if(clock.methods.includes("performance")){const proto=(()=>{if(hasPerformanceConstructorPrototype){return _global.performance.constructor.prototype;}if(hasPerformancePrototype){return _global.Performance.prototype;}})();if(proto){Object.getOwnPropertyNames(proto).forEach(function(name){if(name!=="now"){clock.performance[name]=name.indexOf("getEntries")===0?NOOP_ARRAY:NOOP;}});}else if((config.toFake||[]).includes("performance")){// user explicitly tried to fake performance when not present
throw new ReferenceError("non-existent performance object cannot be faked");}}if(_global===globalObject&&timersModule){clock.timersModuleMethods=[];}for(i=0,l=clock.methods.length;i<l;i++){const nameOfMethodToReplace=clock.methods[i];if(nameOfMethodToReplace==="hrtime"){if(_global.process&&typeof _global.process.hrtime==="function"){hijackMethod(_global.process,nameOfMethodToReplace,clock);}}else if(nameOfMethodToReplace==="nextTick"){if(_global.process&&typeof _global.process.nextTick==="function"){hijackMethod(_global.process,nameOfMethodToReplace,clock);}}else{hijackMethod(_global,nameOfMethodToReplace,clock);}if(clock.timersModuleMethods!==undefined&&timersModule[nameOfMethodToReplace]){const original=timersModule[nameOfMethodToReplace];clock.timersModuleMethods.push({methodName:nameOfMethodToReplace,original:original});timersModule[nameOfMethodToReplace]=_global[nameOfMethodToReplace];}}return clock;}/* eslint-enable complexity */return{timers:timers,createClock:createClock,install:install,withGlobal:withGlobal};}/**
 * @typedef {object} FakeTimers
 * @property {Timers} timers
 * @property {createClock} createClock
 * @property {Function} install
 * @property {withGlobal} withGlobal
 */ /* eslint-enable complexity */ /** @type {FakeTimers} */const defaultImplementation=withGlobal(globalObject);defaultImplementation.timers;defaultImplementation.createClock;defaultImplementation.install;var withGlobal_1=withGlobal;class FakeTimers{_global;_clock;_fakingTime;_fakingDate;_fakeTimers;_userConfig;_now=RealDate.now;constructor({global,config}){this._userConfig=config;this._fakingDate=false;this._fakingTime=false;this._fakeTimers=withGlobal_1(global);this._global=global;}clearAllTimers(){if(this._fakingTime)this._clock.reset();}dispose(){this.useRealTimers();}runAllTimers(){if(this._checkFakeTimers())this._clock.runAll();}async runAllTimersAsync(){if(this._checkFakeTimers())await this._clock.runAllAsync();}runOnlyPendingTimers(){if(this._checkFakeTimers())this._clock.runToLast();}async runOnlyPendingTimersAsync(){if(this._checkFakeTimers())await this._clock.runToLastAsync();}advanceTimersToNextTimer(steps=1){if(this._checkFakeTimers()){for(let i=steps;i>0;i--){this._clock.next();this._clock.tick(0);if(this._clock.countTimers()===0)break;}}}async advanceTimersToNextTimerAsync(steps=1){if(this._checkFakeTimers()){for(let i=steps;i>0;i--){await this._clock.nextAsync();this._clock.tick(0);if(this._clock.countTimers()===0)break;}}}advanceTimersByTime(msToRun){if(this._checkFakeTimers())this._clock.tick(msToRun);}async advanceTimersByTimeAsync(msToRun){if(this._checkFakeTimers())await this._clock.tickAsync(msToRun);}runAllTicks(){if(this._checkFakeTimers()){this._clock.runMicrotasks();}}useRealTimers(){if(this._fakingDate){resetDate();this._fakingDate=false;}if(this._fakingTime){this._clock.uninstall();this._fakingTime=false;}}useFakeTimers(){var _a,_b,_c;if(this._fakingDate){throw new Error('"setSystemTime" was called already and date was mocked. Reset timers using \`vi.useRealTimers()\` if you want to use fake timers again.');}if(!this._fakingTime){const toFake=Object.keys(this._fakeTimers.timers).filter(timer=>timer!=="nextTick");if(((_b=(_a=this._userConfig)==null?void 0:_a.toFake)==null?void 0:_b.includes("nextTick"))&&isChildProcess())throw new Error("process.nextTick cannot be mocked inside child_process");const existingFakedMethods=(((_c=this._userConfig)==null?void 0:_c.toFake)||toFake).filter(method=>{switch(method){case"setImmediate":case"clearImmediate":return method in this._global&&this._global[method];default:return true;}});this._clock=this._fakeTimers.install(_objectSpread(_objectSpread({now:Date.now()},this._userConfig),{},{toFake:existingFakedMethods}));this._fakingTime=true;}}reset(){if(this._checkFakeTimers()){const now=this._clock.now;this._clock.reset();this._clock.setSystemTime(now);}}setSystemTime(now){if(this._fakingTime){this._clock.setSystemTime(now);}else{mockDate(now??this.getRealSystemTime());this._fakingDate=true;}}getRealSystemTime(){return this._now();}getTimerCount(){if(this._checkFakeTimers())return this._clock.countTimers();return 0;}configure(config){this._userConfig=config;}isFakeTimers(){return this._fakingTime;}_checkFakeTimers(){if(!this._fakingTime){throw new Error('Timers are not mocked. Try calling "vi.useFakeTimers()" first.');}return this._fakingTime;}}function copyStackTrace(target,source){if(source.stack!==void 0)target.stack=source.stack.replace(source.message,target.message);return target;}function waitFor(callback,options={}){const _getSafeTimers3=getSafeTimers(),setTimeout=_getSafeTimers3.setTimeout,setInterval=_getSafeTimers3.setInterval,clearTimeout=_getSafeTimers3.clearTimeout,clearInterval=_getSafeTimers3.clearInterval;const _ref12=typeof options==="number"?{timeout:options}:options,_ref12$interval=_ref12.interval,interval=_ref12$interval===void 0?50:_ref12$interval,_ref12$timeout=_ref12.timeout,timeout=_ref12$timeout===void 0?1e3:_ref12$timeout;const STACK_TRACE_ERROR=new Error("STACK_TRACE_ERROR");return new Promise((resolve,reject)=>{let lastError;let promiseStatus="idle";let timeoutId;let intervalId;const onResolve=result=>{if(timeoutId)clearTimeout(timeoutId);if(intervalId)clearInterval(intervalId);resolve(result);};const handleTimeout=()=>{let error=lastError;if(!error)error=copyStackTrace(new Error("Timed out in waitFor!"),STACK_TRACE_ERROR);reject(error);};const checkCallback=()=>{if(vi.isFakeTimers())vi.advanceTimersByTime(interval);if(promiseStatus==="pending")return;try{const result=callback();if(result!==null&&typeof result==="object"&&typeof result.then==="function"){const thenable=result;promiseStatus="pending";thenable.then(resolvedValue=>{promiseStatus="resolved";onResolve(resolvedValue);},rejectedValue=>{promiseStatus="rejected";lastError=rejectedValue;});}else{onResolve(result);return true;}}catch(error){lastError=error;}};if(checkCallback()===true)return;timeoutId=setTimeout(handleTimeout,timeout);intervalId=setInterval(checkCallback,interval);});}function waitUntil(callback,options={}){const _getSafeTimers4=getSafeTimers(),setTimeout=_getSafeTimers4.setTimeout,setInterval=_getSafeTimers4.setInterval,clearTimeout=_getSafeTimers4.clearTimeout,clearInterval=_getSafeTimers4.clearInterval;const _ref13=typeof options==="number"?{timeout:options}:options,_ref13$interval=_ref13.interval,interval=_ref13$interval===void 0?50:_ref13$interval,_ref13$timeout=_ref13.timeout,timeout=_ref13$timeout===void 0?1e3:_ref13$timeout;const STACK_TRACE_ERROR=new Error("STACK_TRACE_ERROR");return new Promise((resolve,reject)=>{let promiseStatus="idle";let timeoutId;let intervalId;const onReject=error=>{if(!error)error=copyStackTrace(new Error("Timed out in waitUntil!"),STACK_TRACE_ERROR);reject(error);};const onResolve=result=>{if(!result)return;if(timeoutId)clearTimeout(timeoutId);if(intervalId)clearInterval(intervalId);resolve(result);return true;};const checkCallback=()=>{if(vi.isFakeTimers())vi.advanceTimersByTime(interval);if(promiseStatus==="pending")return;try{const result=callback();if(result!==null&&typeof result==="object"&&typeof result.then==="function"){const thenable=result;promiseStatus="pending";thenable.then(resolvedValue=>{promiseStatus="resolved";onResolve(resolvedValue);},rejectedValue=>{promiseStatus="rejected";onReject(rejectedValue);});}else{return onResolve(result);}}catch(error){onReject(error);}};if(checkCallback()===true)return;timeoutId=setTimeout(onReject,timeout);intervalId=setInterval(checkCallback,interval);});}function createVitest(){const _mocker=typeof __vitest_mocker__!=="undefined"?__vitest_mocker__:new Proxy({},{get(_,name){throw new Error(\`Vitest mocker was not initialized in this environment. vi.\${String(name)}() is forbidden.\`);}});let _mockedDate=null;let _config=null;const workerState=getWorkerState();let _timers;const timers=()=>_timers||(_timers=new FakeTimers({global:globalThis,config:workerState.config.fakeTimers}));const _stubsGlobal=/* @__PURE__ */new Map();const _stubsEnv=/* @__PURE__ */new Map();const _envBooleans=["PROD","DEV","SSR"];const getImporter=()=>{const stackTrace=createSimpleStackTrace({stackTraceLimit:4});const importerStack=stackTrace.split("\\n")[4];const stack=parseSingleStack(importerStack);return(stack==null?void 0:stack.file)||"";};const utils={useFakeTimers(config){var _a,_b,_c,_d;if(isChildProcess()){if(((_a=config==null?void 0:config.toFake)==null?void 0:_a.includes("nextTick"))||((_d=(_c=(_b=workerState.config)==null?void 0:_b.fakeTimers)==null?void 0:_c.toFake)==null?void 0:_d.includes("nextTick"))){throw new Error('vi.useFakeTimers({ toFake: ["nextTick"] }) is not supported in node:child_process. Use --pool=threads if mocking nextTick is required.');}}if(config)timers().configure(_objectSpread(_objectSpread({},workerState.config.fakeTimers),config));else timers().configure(workerState.config.fakeTimers);timers().useFakeTimers();return utils;},isFakeTimers(){return timers().isFakeTimers();},useRealTimers(){timers().useRealTimers();_mockedDate=null;return utils;},runOnlyPendingTimers(){timers().runOnlyPendingTimers();return utils;},async runOnlyPendingTimersAsync(){await timers().runOnlyPendingTimersAsync();return utils;},runAllTimers(){timers().runAllTimers();return utils;},async runAllTimersAsync(){await timers().runAllTimersAsync();return utils;},runAllTicks(){timers().runAllTicks();return utils;},advanceTimersByTime(ms){timers().advanceTimersByTime(ms);return utils;},async advanceTimersByTimeAsync(ms){await timers().advanceTimersByTimeAsync(ms);return utils;},advanceTimersToNextTimer(){timers().advanceTimersToNextTimer();return utils;},async advanceTimersToNextTimerAsync(){await timers().advanceTimersToNextTimerAsync();return utils;},getTimerCount(){return timers().getTimerCount();},setSystemTime(time){const date=time instanceof Date?time:new Date(time);_mockedDate=date;timers().setSystemTime(date);return utils;},getMockedSystemTime(){return _mockedDate;},getRealSystemTime(){return timers().getRealSystemTime();},clearAllTimers(){timers().clearAllTimers();return utils;},// mocks
spyOn,fn,waitFor,waitUntil,hoisted(factory){assertTypes(factory,'"vi.hoisted" factory',["function"]);return factory();},mock(path,factory){const importer=getImporter();_mocker.queueMock(path,importer,factory?()=>factory(()=>_mocker.importActual(path,importer,_mocker.getMockContext().callstack)):void 0,true);},unmock(path){_mocker.queueUnmock(path,getImporter());},doMock(path,factory){const importer=getImporter();_mocker.queueMock(path,importer,factory?()=>factory(()=>_mocker.importActual(path,importer,_mocker.getMockContext().callstack)):void 0,false);},doUnmock(path){_mocker.queueUnmock(path,getImporter());},async importActual(path){return _mocker.importActual(path,getImporter(),_mocker.getMockContext().callstack);},async importMock(path){return _mocker.importMock(path,getImporter());},// this is typed in the interface so it's not necessary to type it here
mocked(item,_options={}){return item;},isMockFunction(fn2){return isMockFunction(fn2);},clearAllMocks(){mocks.forEach(spy=>spy.mockClear());return utils;},resetAllMocks(){mocks.forEach(spy=>spy.mockReset());return utils;},restoreAllMocks(){mocks.forEach(spy=>spy.mockRestore());return utils;},stubGlobal(name,value){if(!_stubsGlobal.has(name))_stubsGlobal.set(name,Object.getOwnPropertyDescriptor(globalThis,name));Object.defineProperty(globalThis,name,{value,writable:true,configurable:true,enumerable:true});return utils;},stubEnv(name,value){if(!_stubsEnv.has(name))_stubsEnv.set(name,process.env[name]);if(_envBooleans.includes(name))process.env[name]=value?"1":"";else process.env[name]=String(value);return utils;},unstubAllGlobals(){_stubsGlobal.forEach((original,name)=>{if(!original)Reflect.deleteProperty(globalThis,name);else Object.defineProperty(globalThis,name,original);});_stubsGlobal.clear();return utils;},unstubAllEnvs(){_stubsEnv.forEach((original,name)=>{if(original===void 0)delete process.env[name];else process.env[name]=original;});_stubsEnv.clear();return utils;},resetModules(){resetModules(workerState.moduleCache);return utils;},async dynamicImportSettled(){return waitForImportsToResolve();},setConfig(config){if(!_config)_config=_objectSpread({},workerState.config);Object.assign(workerState.config,config);},resetConfig(){if(_config)Object.assign(workerState.config,_config);}};return utils;}const vitest=createVitest();const vi=vitest;class Spy{called=false;mock=()=>{};method(){}}function spy(){const inst=new Spy();return vi.fn(inst.mock);}async function wait(){}exports.spy=spy;exports.wait=wait;
//# sourceMappingURL=test.js.map
"
`;

exports[`Outputs (swc) > artifacts > builds all the artifacts with rollup > umd/client.js 1`] = `
"(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define("Packemon", ["exports"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.Packemon = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.createClient = createClient;
  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
  function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  // Bundled with Packemon: https://packemon.dev
  // Platform: browser, Support: legacy, Format: umd
  var Client = /*#__PURE__*/_createClass(function Client() {
    _classCallCheck(this, Client);
    _defineProperty(this, "prop", 123);
  });
  function* gen() {}
  async function wait() {}
  async function createClient() {
    await wait();
    var _iterator = _createForOfIteratorHelper(gen()),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var iterator = _step.value;
        console.log(iterator);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return new Client();
  }
});
//# sourceMappingURL=client.js.map
"
`;

exports[`Outputs (swc) > artifacts > builds all the artifacts with rollup 1`] = `
[
  {
    "format": "lib",
    "stats": {
      "size": 195,
    },
  },
]
`;

exports[`Outputs (swc) > bundle > bundles all files into a single file with rollup > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: lib

'use strict';

function foo() {}
function bar() {}
exports.bar = bar;
exports.foo = foo;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (browser, esm) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (browser, esm) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (browser, esm) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (browser, esm) > esm/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: browser, Support: stable, Format: esm

import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
import '../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (browser, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (browser, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (browser, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (browser, lib) > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: browser, Support: stable, Format: lib

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (browser, umd) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (browser, umd) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (browser, umd) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (browser, umd) > umd/index.js 1`] = `
"(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../assets/globals-107ab52e.css", "../assets/fonts-4e5dc96c.css", "../assets/styles-b11c3a83.css"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../assets/globals-107ab52e.css"), require("../assets/fonts-4e5dc96c.css"), require("../assets/styles-b11c3a83.css"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.globals107ab52e, global.fonts4e5dc96c, global.stylesB11c3a83);
    global.projectAssets = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _globals107ab52e, _fonts4e5dc96c, _stylesB11c3a) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.button = button;
  // Bundled with Packemon: https://packemon.dev
  // Platform: browser, Support: stable, Format: umd

  function button() {}
});
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (electron, esm) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (electron, esm) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (electron, esm) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (electron, esm) > esm/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: electron, Support: stable, Format: esm

import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
import '../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (electron, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (electron, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (electron, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (electron, lib) > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: electron, Support: stable, Format: lib

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (native, esm) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (native, esm) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (native, esm) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (native, esm) > esm/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: native, Support: stable, Format: esm

import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
import '../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (native, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (native, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (native, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (native, lib) > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: native, Support: stable, Format: lib

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (node, cjs) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (node, cjs) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (node, cjs) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (node, cjs) > cjs/index.cjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: cjs

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.cjs.map
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (node, cjs) > cjs/index-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import data from './index.cjs';

export const { button } = data;"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (node, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (node, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (node, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (node, lib) > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: lib

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (node, mjs) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (node, mjs) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (node, mjs) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > bundle with assets > bundles all files and references assets (node, mjs) > mjs/index.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: mjs

import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
import '../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.mjs.map
"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > ../assets/fonts-4e5dc96c.css 2`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > ../assets/fonts-4e5dc96c.css 3`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > ../assets/globals-107ab52e.css 2`] = `
"html {
}
"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > ../assets/globals-107ab52e.css 3`] = `
"html {
}
"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > ../assets/styles-b11c3a83.css 2`] = `
".button {
}
"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > ../assets/styles-b11c3a83.css 3`] = `
".button {
}
"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > cjs/index.cjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: cjs

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.cjs.map
"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > cjs/index-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import data from './index.cjs';

export const { button } = data;"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > esm/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: esm

import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
import '../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > esm/index-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import data from './index.cjs';

export const { button } = data;"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > lib/index.js 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: lib

'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
require('../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > bundle with assets > uses same assets across multiple formats > lib/index-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import data from './index.cjs';

export const { button } = data;"
`;

exports[`Outputs (swc) > no bundle > creates individual files for every source file > lib/index.js 1`] = `
"'use strict';

const other = require('./other.js');
function bar() {}
exports.foo = other.foo;
exports.bar = bar;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle > creates individual files for every source file > lib/not-imported.js 1`] = `
"'use strict';

function baz() {}
exports.baz = baz;
//# sourceMappingURL=not-imported.js.map
"
`;

exports[`Outputs (swc) > no bundle > creates individual files for every source file > lib/other.js 1`] = `
"'use strict';

function foo() {}
exports.foo = foo;
//# sourceMappingURL=other.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, esm) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, esm) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, esm) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, esm) > esm/button/index.js 1`] = `
"import '../../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, esm) > esm/index.js 1`] = `
"import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
export { button } from './button/index.js';
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, lib) > lib/button/index.js 1`] = `
"'use strict';

require('../../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, lib) > lib/index.js 1`] = `
"'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
const index = require('./button/index.js');
exports.button = index.button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, umd) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, umd) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, umd) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, umd) > umd/button/index.js 1`] = `
"(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../../assets/styles-b11c3a83.css"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../../assets/styles-b11c3a83.css"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.stylesB11c3a83);
    global.projectAssets = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _stylesB11c3a) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.button = button;
  function button() {}
});
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (browser, umd) > umd/index.js 1`] = `
"(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../assets/globals-107ab52e.css", "../assets/fonts-4e5dc96c.css", "./button/index.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../assets/globals-107ab52e.css"), require("../assets/fonts-4e5dc96c.css"), require("./button/index.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.globals107ab52e, global.fonts4e5dc96c, global.index);
    global.projectAssets = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _globals107ab52e, _fonts4e5dc96c, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  Object.defineProperty(_exports, "button", {
    enumerable: true,
    get: function () {
      return _index.button;
    }
  });
});
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (electron, esm) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (electron, esm) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (electron, esm) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (electron, esm) > esm/button/index.js 1`] = `
"import '../../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (electron, esm) > esm/index.js 1`] = `
"import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
export { button } from './button/index.js';
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (electron, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (electron, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (electron, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (electron, lib) > lib/button/index.js 1`] = `
"'use strict';

require('../../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (electron, lib) > lib/index.js 1`] = `
"'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
const index = require('./button/index.js');
exports.button = index.button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (native, esm) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (native, esm) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (native, esm) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (native, esm) > esm/button/index.js 1`] = `
"import '../../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (native, esm) > esm/index.js 1`] = `
"import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
export { button } from './button/index.js';
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (native, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (native, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (native, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (native, lib) > lib/button/index.js 1`] = `
"'use strict';

require('../../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (native, lib) > lib/index.js 1`] = `
"'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
const index = require('./button/index.js');
exports.button = index.button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, cjs) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, cjs) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, cjs) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, cjs) > cjs/button/index.cjs 1`] = `
"'use strict';

require('../../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.cjs.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, cjs) > cjs/index.cjs 1`] = `
"'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
const index = require('./button/index.cjs');
exports.button = index.button;
//# sourceMappingURL=index.cjs.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, cjs) > cjs/index-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import data from './index.cjs';

export const { button } = data;"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, lib) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, lib) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, lib) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, lib) > lib/button/index.js 1`] = `
"'use strict';

require('../../assets/styles-b11c3a83.css');
function button() {}
exports.button = button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, lib) > lib/index.js 1`] = `
"'use strict';

require('../assets/globals-107ab52e.css');
require('../assets/fonts-4e5dc96c.css');
const index = require('./button/index.js');
exports.button = index.button;
//# sourceMappingURL=index.js.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, mjs) > ../assets/fonts-4e5dc96c.css 1`] = `
"@font-face {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, mjs) > ../assets/globals-107ab52e.css 1`] = `
"html {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, mjs) > ../assets/styles-b11c3a83.css 1`] = `
".button {
}
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, mjs) > mjs/button/index.mjs 1`] = `
"import '../../assets/styles-b11c3a83.css';
function button() {}
export { button };
//# sourceMappingURL=index.mjs.map
"
`;

exports[`Outputs (swc) > no bundle with assets > creates individual files and references assets (node, mjs) > mjs/index.mjs 1`] = `
"import '../assets/globals-107ab52e.css';
import '../assets/fonts-4e5dc96c.css';
export { button } from './button/index.mjs';
//# sourceMappingURL=index.mjs.map
"
`;

exports[`Special formats > cjs > supports .ts -> .cjs / .d.cts (compat) > cjs/index.cjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: cjs

'use strict';

function test() {
  return 123;
}
module.exports = test;
//# sourceMappingURL=index.cjs.map
"
`;

exports[`Special formats > cjs > supports .ts -> .cjs / .d.cts (compat) > cjs/index-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import data from './index.cjs';

export default data;"
`;

exports[`Special formats > cjs > supports .ts -> .cjs / .d.cts (compat) 1`] = `
"export default function test(): number;
//# sourceMappingURL=index.d.cts.map
"
`;

exports[`Special formats > cjs > supports .ts -> .cjs / .d.cts (compat) 2`] = `
"{"version":3,"file":"index.d.cts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,OAAO,UAAU,IAAI,WAE3B"}
"
`;

exports[`Special formats > cts > supports .cts -> .cjs / .d.cts > cjs/index.cjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: cjs

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = test;
function test() {
  return 123;
}
//# sourceMappingURL=index.cjs.map
"
`;

exports[`Special formats > cts > supports .cts -> .cjs / .d.cts > cjs/index-wrapper.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// This is an MJS wrapper for a sibling CJS file

import './index.cjs';"
`;

exports[`Special formats > cts > supports .cts -> .cjs / .d.cts 1`] = `
"export default function test(): number;
//# sourceMappingURL=index.d.cts.map"
`;

exports[`Special formats > mts > supports .mts -> .mjs / .d.mts > mjs/index.mjs 1`] = `
"// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: mjs

function test() {
  return 'abc';
}
export { test as default };
//# sourceMappingURL=index.mjs.map
"
`;

exports[`Special formats > mts > supports .mts -> .mjs / .d.mts 1`] = `
"export default function test(): string;
//# sourceMappingURL=index.d.mts.map"
`;
